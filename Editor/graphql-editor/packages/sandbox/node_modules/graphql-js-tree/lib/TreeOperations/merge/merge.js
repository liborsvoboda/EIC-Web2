"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.mergeSDLs = exports.mergeTrees = void 0;
const Models_1 = require("../../Models");
const Parser_1 = require("../../Parser");
const arguments_1 = require("./arguments");
const common_1 = require("./common");
const shared_1 = require("../shared");
const TreeToGraphQL_1 = require("../../TreeToGraphQL");
const shared_2 = require("../../shared");
const detectConflictOnBaseNode = (n1, n2) => {
    if (n1.data.type !== n2.data.type)
        throw new common_1.MergeError({
            conflictingNode: n1.name,
            message: `Data type conflict of nodes ${n1.name} and ${n2.name}`,
        });
    if (JSON.stringify(n1.interfaces) !== JSON.stringify(n2.interfaces))
        throw new common_1.MergeError({
            conflictingNode: n1.name,
            message: `Data type conflict of nodes ${n1.name} and ${n2.name}`,
        });
};
const detectConflictOnFieldNode = (parentName, f1, f2) => {
    const [f1Type, f2Type] = [(0, shared_2.getTypeName)(f1.type.fieldType), (0, shared_2.getTypeName)(f2.type.fieldType)];
    if (f1Type !== f2Type)
        throw new common_1.MergeError({
            conflictingNode: parentName,
            conflictingField: f1.name,
            message: `Data type conflict of node ${parentName} field ${f1.name} `,
        });
};
const addFromLibrary = (n) => (Object.assign(Object.assign({}, n), { fromLibrary: true }));
const mergeFields = (parentName, fields1, fields2) => {
    const mergedCommonFieldsAndF1Fields = fields1
        .map((f1) => {
        const commonField = fields2.find((f2) => f2.name === f1.name);
        if (!commonField)
            return f1;
        detectConflictOnFieldNode(parentName, f1, commonField);
        const mergedField = Object.assign(Object.assign({}, f1), { args: (0, arguments_1.mergeArguments)(f1.name, f1.args, commonField.args) });
        return mergedField;
    })
        .filter((f) => !!f);
    const otherF2Fields = fields2.filter((f2) => !fields1.find((f1) => f1.name === f2.name));
    return [...mergedCommonFieldsAndF1Fields, ...otherF2Fields];
};
const mergeNode = (n1, n2) => {
    detectConflictOnBaseNode(n1, n2);
    const args = n1.data.type === Models_1.TypeDefinition.InputObjectTypeDefinition
        ? (0, arguments_1.mergeArguments)(n1.name, n1.args, n2.args)
        : mergeFields(n1.name, n1.args, n2.args.map(addFromLibrary));
    const mergedNode = Object.assign(Object.assign({}, n1), { id: (0, shared_2.generateNodeId)(n1.name, n1.data.type, args), args, directives: [...n1.directives, ...n2.directives.map(addFromLibrary)], interfaces: [...n1.interfaces, ...n2.interfaces] });
    mergedNode.directives = mergedNode.directives.filter((a, i) => mergedNode.directives.findIndex((aa) => aa.name === a.name) === i);
    mergedNode.interfaces = mergedNode.interfaces.filter((a, i) => mergedNode.interfaces.findIndex((aa) => aa === a) === i);
    return mergedNode;
};
const mergeTrees = (tree1, tree2) => {
    const mergedNodesT1 = [];
    const mergedNodesT2 = [];
    const mergeResultNodes = [];
    const errors = [];
    const filteredTree2Nodes = tree2.nodes.filter((t) => t.data.type !== Models_1.TypeSystemDefinition.SchemaDefinition);
    tree1.nodes.forEach((t1n) => {
        const matchingNode = filteredTree2Nodes.find((t2n) => t2n.name === t1n.name && t1n.data.type === t2n.data.type);
        if (matchingNode) {
            if ((0, shared_1.isExtensionNode)(matchingNode.data.type)) {
                t1n.args.forEach((t1nA) => {
                    const matchingArg = matchingNode.args.find((mNA) => mNA.name === t1nA.name);
                    if (matchingArg) {
                        if (JSON.stringify(matchingArg) !== JSON.stringify(t1nA)) {
                            errors.push({
                                conflictingField: t1nA.name,
                                conflictingNode: t1n.name,
                            });
                        }
                    }
                });
                return;
            }
            mergedNodesT1.push(t1n);
            mergedNodesT2.push(matchingNode);
            try {
                const mergeNodeResult = mergeNode(t1n, matchingNode);
                mergeResultNodes.push(mergeNodeResult);
            }
            catch (error) {
                if (error instanceof common_1.MergeError) {
                    errors.push({
                        conflictingNode: error.errorParams.conflictingNode,
                        conflictingField: error.errorParams.conflictingField,
                    });
                }
            }
        }
    });
    if (errors.length) {
        return {
            __typename: 'error',
            errors,
        };
    }
    const t1Nodes = tree1.nodes.filter((t1n) => !mergedNodesT1.find((mtn1) => mtn1 === t1n));
    const t2Nodes = filteredTree2Nodes
        .filter((t2n) => !mergedNodesT2.find((mtn2) => mtn2 === t2n))
        .map((n) => (Object.assign(Object.assign({}, n), { fromLibrary: true })));
    return {
        __typename: 'success',
        nodes: [...t1Nodes, ...mergeResultNodes, ...t2Nodes],
    };
};
exports.mergeTrees = mergeTrees;
const mergeSDLs = (sdl1, sdl2) => {
    const t1 = Parser_1.Parser.parse(sdl1);
    const t2 = Parser_1.Parser.parse(sdl2);
    const mergeResult = (0, exports.mergeTrees)(t1, {
        nodes: t2.nodes.filter((n) => n.data.type !== Models_1.TypeSystemDefinition.SchemaDefinition),
    });
    if (mergeResult.__typename === 'success') {
        const sdl = TreeToGraphQL_1.TreeToGraphQL.parse(mergeResult);
        return Object.assign(Object.assign({}, mergeResult), { sdl });
    }
    return mergeResult;
};
exports.mergeSDLs = mergeSDLs;
