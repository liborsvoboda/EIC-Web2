{"version":3,"file":"1982.js","mappings":"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","sources":["webpack://demo/../../node_modules/monaco-editor/esm/vs/base/common/buffer.js","webpack://demo/../../node_modules/monaco-editor/esm/vs/editor/common/services/semanticTokensDto.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Lazy } from './lazy.js';\nconst hasBuffer = (typeof Buffer !== 'undefined');\nconst indexOfTable = new Lazy(() => new Uint8Array(256));\nlet textDecoder;\nexport class VSBuffer {\n    /**\n     * When running in a nodejs context, if `actual` is not a nodejs Buffer, the backing store for\n     * the returned `VSBuffer` instance might use a nodejs Buffer allocated from node's Buffer pool,\n     * which is not transferrable.\n     */\n    static wrap(actual) {\n        if (hasBuffer && !(Buffer.isBuffer(actual))) {\n            // https://nodejs.org/dist/latest-v10.x/docs/api/buffer.html#buffer_class_method_buffer_from_arraybuffer_byteoffset_length\n            // Create a zero-copy Buffer wrapper around the ArrayBuffer pointed to by the Uint8Array\n            actual = Buffer.from(actual.buffer, actual.byteOffset, actual.byteLength);\n        }\n        return new VSBuffer(actual);\n    }\n    constructor(buffer) {\n        this.buffer = buffer;\n        this.byteLength = this.buffer.byteLength;\n    }\n    toString() {\n        if (hasBuffer) {\n            return this.buffer.toString();\n        }\n        else {\n            if (!textDecoder) {\n                textDecoder = new TextDecoder();\n            }\n            return textDecoder.decode(this.buffer);\n        }\n    }\n}\nexport function readUInt16LE(source, offset) {\n    return (((source[offset + 0] << 0) >>> 0) |\n        ((source[offset + 1] << 8) >>> 0));\n}\nexport function writeUInt16LE(destination, value, offset) {\n    destination[offset + 0] = (value & 0b11111111);\n    value = value >>> 8;\n    destination[offset + 1] = (value & 0b11111111);\n}\nexport function readUInt32BE(source, offset) {\n    return (source[offset] * 2 ** 24\n        + source[offset + 1] * 2 ** 16\n        + source[offset + 2] * 2 ** 8\n        + source[offset + 3]);\n}\nexport function writeUInt32BE(destination, value, offset) {\n    destination[offset + 3] = value;\n    value = value >>> 8;\n    destination[offset + 2] = value;\n    value = value >>> 8;\n    destination[offset + 1] = value;\n    value = value >>> 8;\n    destination[offset] = value;\n}\nexport function readUInt8(source, offset) {\n    return source[offset];\n}\nexport function writeUInt8(destination, value, offset) {\n    destination[offset] = value;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { VSBuffer } from '../../../base/common/buffer.js';\nimport * as platform from '../../../base/common/platform.js';\nfunction reverseEndianness(arr) {\n    for (let i = 0, len = arr.length; i < len; i += 4) {\n        // flip bytes 0<->3 and 1<->2\n        const b0 = arr[i + 0];\n        const b1 = arr[i + 1];\n        const b2 = arr[i + 2];\n        const b3 = arr[i + 3];\n        arr[i + 0] = b3;\n        arr[i + 1] = b2;\n        arr[i + 2] = b1;\n        arr[i + 3] = b0;\n    }\n}\nfunction toLittleEndianBuffer(arr) {\n    const uint8Arr = new Uint8Array(arr.buffer, arr.byteOffset, arr.length * 4);\n    if (!platform.isLittleEndian()) {\n        // the byte order must be changed\n        reverseEndianness(uint8Arr);\n    }\n    return VSBuffer.wrap(uint8Arr);\n}\nexport function encodeSemanticTokensDto(semanticTokens) {\n    const dest = new Uint32Array(encodeSemanticTokensDtoSize(semanticTokens));\n    let offset = 0;\n    dest[offset++] = semanticTokens.id;\n    if (semanticTokens.type === 'full') {\n        dest[offset++] = 1 /* EncodedSemanticTokensType.Full */;\n        dest[offset++] = semanticTokens.data.length;\n        dest.set(semanticTokens.data, offset);\n        offset += semanticTokens.data.length;\n    }\n    else {\n        dest[offset++] = 2 /* EncodedSemanticTokensType.Delta */;\n        dest[offset++] = semanticTokens.deltas.length;\n        for (const delta of semanticTokens.deltas) {\n            dest[offset++] = delta.start;\n            dest[offset++] = delta.deleteCount;\n            if (delta.data) {\n                dest[offset++] = delta.data.length;\n                dest.set(delta.data, offset);\n                offset += delta.data.length;\n            }\n            else {\n                dest[offset++] = 0;\n            }\n        }\n    }\n    return toLittleEndianBuffer(dest);\n}\nfunction encodeSemanticTokensDtoSize(semanticTokens) {\n    let result = 0;\n    result += (+1 // id\n        + 1 // type\n    );\n    if (semanticTokens.type === 'full') {\n        result += (+1 // data length\n            + semanticTokens.data.length);\n    }\n    else {\n        result += (+1 // delta count\n        );\n        result += (+1 // start\n            + 1 // deleteCount\n            + 1 // data length\n        ) * semanticTokens.deltas.length;\n        for (const delta of semanticTokens.deltas) {\n            if (delta.data) {\n                result += delta.data.length;\n            }\n        }\n    }\n    return result;\n}\n"],"names":["hasBuffer","Buffer","textDecoder","Uint8Array","VSBuffer","wrap","actual","isBuffer","from","buffer","byteOffset","byteLength","constructor","this","toString","TextDecoder","decode","readUInt16LE","source","offset","writeUInt16LE","destination","value","readUInt32BE","writeUInt32BE","readUInt8","writeUInt8","encodeSemanticTokensDto","semanticTokens","dest","Uint32Array","result","type","data","length","deltas","delta","encodeSemanticTokensDtoSize","id","set","start","deleteCount","arr","uint8Arr","i","len","b0","b1","b2","b3","reverseEndianness","toLittleEndianBuffer"],"sourceRoot":""}