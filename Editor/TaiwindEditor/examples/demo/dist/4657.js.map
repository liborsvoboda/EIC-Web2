{"version":3,"file":"4657.js","mappings":"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","sources":["webpack://demo/../../node_modules/monaco-editor/esm/vs/base/common/buffer.js","webpack://demo/../../node_modules/monaco-editor/esm/vs/editor/common/core/cursorColumns.js","webpack://demo/../../node_modules/monaco-editor/esm/vs/editor/common/core/indentation.js","webpack://demo/../../node_modules/monaco-editor/esm/vs/editor/common/core/stringBuilder.js","webpack://demo/../../node_modules/monaco-editor/esm/vs/editor/common/core/textChange.js","webpack://demo/../../node_modules/monaco-editor/esm/vs/editor/common/core/textModelDefaults.js","webpack://demo/../../node_modules/monaco-editor/esm/vs/editor/common/languages/languageConfiguration.js","webpack://demo/../../node_modules/monaco-editor/esm/vs/editor/common/languages/supports/characterPair.js","webpack://demo/../../node_modules/monaco-editor/esm/vs/editor/common/languages/supports/electricCharacter.js","webpack://demo/../../node_modules/monaco-editor/esm/vs/editor/common/languages/supports/indentRules.js","webpack://demo/../../node_modules/monaco-editor/esm/vs/editor/common/languages/supports/onEnter.js","webpack://demo/../../node_modules/monaco-editor/esm/vs/editor/common/languages/supports/languageBracketsConfiguration.js","webpack://demo/../../node_modules/monaco-editor/esm/vs/editor/common/languages/languageConfigurationRegistry.js","webpack://demo/../../node_modules/monaco-editor/esm/vs/editor/common/languages/nullTokenize.js","webpack://demo/../../node_modules/monaco-editor/esm/vs/editor/common/languages/supports.js","webpack://demo/../../node_modules/monaco-editor/esm/vs/editor/common/languages/supports/richEditBrackets.js","webpack://demo/../../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/ast.js","webpack://demo/../../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/beforeEditPositionMapper.js","webpack://demo/../../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/brackets.js","webpack://demo/../../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/combineTextEditInfos.js","webpack://demo/../../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/length.js","webpack://demo/../../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/concat23Trees.js","webpack://demo/../../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/nodeReader.js","webpack://demo/../../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/parser.js","webpack://demo/../../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/smallImmutableSet.js","webpack://demo/../../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/tokenizer.js","webpack://demo/../../node_modules/monaco-editor/esm/vs/editor/common/model/editStack.js","webpack://demo/../../node_modules/monaco-editor/esm/vs/editor/common/model/guidesTextModelPart.js","webpack://demo/../../node_modules/monaco-editor/esm/vs/editor/common/textModelBracketPairs.js","webpack://demo/../../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/bracketPairsTree.js","webpack://demo/../../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsImpl.js","webpack://demo/../../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/colorizedBracketPairsDecorationProvider.js","webpack://demo/../../node_modules/monaco-editor/esm/vs/editor/common/model/indentationGuesser.js","webpack://demo/../../node_modules/monaco-editor/esm/vs/editor/common/model/intervalTree.js","webpack://demo/../../node_modules/monaco-editor/esm/vs/editor/common/model/pieceTreeTextBuffer/rbTreeBase.js","webpack://demo/../../node_modules/monaco-editor/esm/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeBase.js","webpack://demo/../../node_modules/monaco-editor/esm/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBuffer.js","webpack://demo/../../node_modules/monaco-editor/esm/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBufferBuilder.js","webpack://demo/../../node_modules/monaco-editor/esm/vs/editor/common/model/fixedArray.js","webpack://demo/../../node_modules/monaco-editor/esm/vs/editor/common/tokens/contiguousMultilineTokens.js","webpack://demo/../../node_modules/monaco-editor/esm/vs/editor/common/tokens/contiguousMultilineTokensBuilder.js","webpack://demo/../../node_modules/monaco-editor/esm/vs/editor/common/model/textModelTokens.js","webpack://demo/../../node_modules/monaco-editor/esm/vs/editor/common/model/tokens.js","webpack://demo/../../node_modules/monaco-editor/esm/vs/editor/common/model/treeSitterTokens.js","webpack://demo/../../node_modules/monaco-editor/esm/vs/editor/common/tokens/contiguousTokensEditing.js","webpack://demo/../../node_modules/monaco-editor/esm/vs/editor/common/tokens/contiguousTokensStore.js","webpack://demo/../../node_modules/monaco-editor/esm/vs/editor/common/tokens/sparseTokensStore.js","webpack://demo/../../node_modules/monaco-editor/esm/vs/editor/common/model/tokenizationTextModelPart.js","webpack://demo/../../node_modules/monaco-editor/esm/vs/editor/common/model/textModel.js","webpack://demo/../../node_modules/monaco-editor/esm/vs/editor/common/model/textModelPart.js","webpack://demo/../../node_modules/monaco-editor/esm/vs/editor/common/model/utils.js","webpack://demo/../../node_modules/monaco-editor/esm/vs/editor/common/services/modelService.js","webpack://demo/../../node_modules/monaco-editor/esm/vs/editor/common/services/textResourceConfiguration.js","webpack://demo/../../node_modules/monaco-editor/esm/vs/editor/common/services/treeSitterParserService.js","webpack://demo/../../node_modules/monaco-editor/esm/vs/editor/common/textModelEvents.js","webpack://demo/../../node_modules/monaco-editor/esm/vs/editor/common/textModelGuides.js","webpack://demo/../../node_modules/monaco-editor/esm/vs/editor/common/tokens/lineTokens.js","webpack://demo/../../node_modules/monaco-editor/esm/vs/platform/instantiation/common/descriptors.js","webpack://demo/../../node_modules/monaco-editor/esm/vs/platform/instantiation/common/extensions.js","webpack://demo/../../node_modules/monaco-editor/esm/vs/platform/undoRedo/common/undoRedo.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Lazy } from './lazy.js';\nconst hasBuffer = (typeof Buffer !== 'undefined');\nconst indexOfTable = new Lazy(() => new Uint8Array(256));\nlet textDecoder;\nexport class VSBuffer {\n    /**\n     * When running in a nodejs context, if `actual` is not a nodejs Buffer, the backing store for\n     * the returned `VSBuffer` instance might use a nodejs Buffer allocated from node's Buffer pool,\n     * which is not transferrable.\n     */\n    static wrap(actual) {\n        if (hasBuffer && !(Buffer.isBuffer(actual))) {\n            // https://nodejs.org/dist/latest-v10.x/docs/api/buffer.html#buffer_class_method_buffer_from_arraybuffer_byteoffset_length\n            // Create a zero-copy Buffer wrapper around the ArrayBuffer pointed to by the Uint8Array\n            actual = Buffer.from(actual.buffer, actual.byteOffset, actual.byteLength);\n        }\n        return new VSBuffer(actual);\n    }\n    constructor(buffer) {\n        this.buffer = buffer;\n        this.byteLength = this.buffer.byteLength;\n    }\n    toString() {\n        if (hasBuffer) {\n            return this.buffer.toString();\n        }\n        else {\n            if (!textDecoder) {\n                textDecoder = new TextDecoder();\n            }\n            return textDecoder.decode(this.buffer);\n        }\n    }\n}\nexport function readUInt16LE(source, offset) {\n    return (((source[offset + 0] << 0) >>> 0) |\n        ((source[offset + 1] << 8) >>> 0));\n}\nexport function writeUInt16LE(destination, value, offset) {\n    destination[offset + 0] = (value & 0b11111111);\n    value = value >>> 8;\n    destination[offset + 1] = (value & 0b11111111);\n}\nexport function readUInt32BE(source, offset) {\n    return (source[offset] * 2 ** 24\n        + source[offset + 1] * 2 ** 16\n        + source[offset + 2] * 2 ** 8\n        + source[offset + 3]);\n}\nexport function writeUInt32BE(destination, value, offset) {\n    destination[offset + 3] = value;\n    value = value >>> 8;\n    destination[offset + 2] = value;\n    value = value >>> 8;\n    destination[offset + 1] = value;\n    value = value >>> 8;\n    destination[offset] = value;\n}\nexport function readUInt8(source, offset) {\n    return source[offset];\n}\nexport function writeUInt8(destination, value, offset) {\n    destination[offset] = value;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\n/**\n * A column in a position is the gap between two adjacent characters. The methods here\n * work with a concept called \"visible column\". A visible column is a very rough approximation\n * of the horizontal screen position of a column. For example, using a tab size of 4:\n * ```txt\n * |<TAB>|<TAB>|T|ext\n * |     |     | \\---- column = 4, visible column = 9\n * |     |     \\------ column = 3, visible column = 8\n * |     \\------------ column = 2, visible column = 4\n * \\------------------ column = 1, visible column = 0\n * ```\n *\n * **NOTE**: Visual columns do not work well for RTL text or variable-width fonts or characters.\n *\n * **NOTE**: These methods work and make sense both on the model and on the view model.\n */\nexport class CursorColumns {\n    static _nextVisibleColumn(codePoint, visibleColumn, tabSize) {\n        if (codePoint === 9 /* CharCode.Tab */) {\n            return CursorColumns.nextRenderTabStop(visibleColumn, tabSize);\n        }\n        if (strings.isFullWidthCharacter(codePoint) || strings.isEmojiImprecise(codePoint)) {\n            return visibleColumn + 2;\n        }\n        return visibleColumn + 1;\n    }\n    /**\n     * Returns a visible column from a column.\n     * @see {@link CursorColumns}\n     */\n    static visibleColumnFromColumn(lineContent, column, tabSize) {\n        const textLen = Math.min(column - 1, lineContent.length);\n        const text = lineContent.substring(0, textLen);\n        const iterator = new strings.GraphemeIterator(text);\n        let result = 0;\n        while (!iterator.eol()) {\n            const codePoint = strings.getNextCodePoint(text, textLen, iterator.offset);\n            iterator.nextGraphemeLength();\n            result = this._nextVisibleColumn(codePoint, result, tabSize);\n        }\n        return result;\n    }\n    /**\n     * Returns a column from a visible column.\n     * @see {@link CursorColumns}\n     */\n    static columnFromVisibleColumn(lineContent, visibleColumn, tabSize) {\n        if (visibleColumn <= 0) {\n            return 1;\n        }\n        const lineContentLength = lineContent.length;\n        const iterator = new strings.GraphemeIterator(lineContent);\n        let beforeVisibleColumn = 0;\n        let beforeColumn = 1;\n        while (!iterator.eol()) {\n            const codePoint = strings.getNextCodePoint(lineContent, lineContentLength, iterator.offset);\n            iterator.nextGraphemeLength();\n            const afterVisibleColumn = this._nextVisibleColumn(codePoint, beforeVisibleColumn, tabSize);\n            const afterColumn = iterator.offset + 1;\n            if (afterVisibleColumn >= visibleColumn) {\n                const beforeDelta = visibleColumn - beforeVisibleColumn;\n                const afterDelta = afterVisibleColumn - visibleColumn;\n                if (afterDelta < beforeDelta) {\n                    return afterColumn;\n                }\n                else {\n                    return beforeColumn;\n                }\n            }\n            beforeVisibleColumn = afterVisibleColumn;\n            beforeColumn = afterColumn;\n        }\n        // walked the entire string\n        return lineContentLength + 1;\n    }\n    /**\n     * ATTENTION: This works with 0-based columns (as opposed to the regular 1-based columns)\n     * @see {@link CursorColumns}\n     */\n    static nextRenderTabStop(visibleColumn, tabSize) {\n        return visibleColumn + tabSize - visibleColumn % tabSize;\n    }\n    /**\n     * ATTENTION: This works with 0-based columns (as opposed to the regular 1-based columns)\n     * @see {@link CursorColumns}\n     */\n    static nextIndentTabStop(visibleColumn, indentSize) {\n        return visibleColumn + indentSize - visibleColumn % indentSize;\n    }\n    /**\n     * ATTENTION: This works with 0-based columns (as opposed to the regular 1-based columns)\n     * @see {@link CursorColumns}\n     */\n    static prevRenderTabStop(column, tabSize) {\n        return Math.max(0, column - 1 - (column - 1) % tabSize);\n    }\n    /**\n     * ATTENTION: This works with 0-based columns (as opposed to the regular 1-based columns)\n     * @see {@link CursorColumns}\n     */\n    static prevIndentTabStop(column, indentSize) {\n        return Math.max(0, column - 1 - (column - 1) % indentSize);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { CursorColumns } from './cursorColumns.js';\nfunction _normalizeIndentationFromWhitespace(str, indentSize, insertSpaces) {\n    let spacesCnt = 0;\n    for (let i = 0; i < str.length; i++) {\n        if (str.charAt(i) === '\\t') {\n            spacesCnt = CursorColumns.nextIndentTabStop(spacesCnt, indentSize);\n        }\n        else {\n            spacesCnt++;\n        }\n    }\n    let result = '';\n    if (!insertSpaces) {\n        const tabsCnt = Math.floor(spacesCnt / indentSize);\n        spacesCnt = spacesCnt % indentSize;\n        for (let i = 0; i < tabsCnt; i++) {\n            result += '\\t';\n        }\n    }\n    for (let i = 0; i < spacesCnt; i++) {\n        result += ' ';\n    }\n    return result;\n}\nexport function normalizeIndentation(str, indentSize, insertSpaces) {\n    let firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(str);\n    if (firstNonWhitespaceIndex === -1) {\n        firstNonWhitespaceIndex = str.length;\n    }\n    return _normalizeIndentationFromWhitespace(str.substring(0, firstNonWhitespaceIndex), indentSize, insertSpaces) + str.substring(firstNonWhitespaceIndex);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport * as platform from '../../../base/common/platform.js';\nimport * as buffer from '../../../base/common/buffer.js';\nlet _utf16LE_TextDecoder;\nfunction getUTF16LE_TextDecoder() {\n    if (!_utf16LE_TextDecoder) {\n        _utf16LE_TextDecoder = new TextDecoder('UTF-16LE');\n    }\n    return _utf16LE_TextDecoder;\n}\nlet _utf16BE_TextDecoder;\nfunction getUTF16BE_TextDecoder() {\n    if (!_utf16BE_TextDecoder) {\n        _utf16BE_TextDecoder = new TextDecoder('UTF-16BE');\n    }\n    return _utf16BE_TextDecoder;\n}\nlet _platformTextDecoder;\nexport function getPlatformTextDecoder() {\n    if (!_platformTextDecoder) {\n        _platformTextDecoder = platform.isLittleEndian() ? getUTF16LE_TextDecoder() : getUTF16BE_TextDecoder();\n    }\n    return _platformTextDecoder;\n}\nexport function decodeUTF16LE(source, offset, len) {\n    const view = new Uint16Array(source.buffer, offset, len);\n    if (len > 0 && (view[0] === 0xFEFF || view[0] === 0xFFFE)) {\n        // UTF16 sometimes starts with a BOM https://de.wikipedia.org/wiki/Byte_Order_Mark\n        // It looks like TextDecoder.decode will eat up a leading BOM (0xFEFF or 0xFFFE)\n        // We don't want that behavior because we know the string is UTF16LE and the BOM should be maintained\n        // So we use the manual decoder\n        return compatDecodeUTF16LE(source, offset, len);\n    }\n    return getUTF16LE_TextDecoder().decode(view);\n}\nfunction compatDecodeUTF16LE(source, offset, len) {\n    const result = [];\n    let resultLen = 0;\n    for (let i = 0; i < len; i++) {\n        const charCode = buffer.readUInt16LE(source, offset);\n        offset += 2;\n        result[resultLen++] = String.fromCharCode(charCode);\n    }\n    return result.join('');\n}\nexport class StringBuilder {\n    constructor(capacity) {\n        this._capacity = capacity | 0;\n        this._buffer = new Uint16Array(this._capacity);\n        this._completedStrings = null;\n        this._bufferLength = 0;\n    }\n    reset() {\n        this._completedStrings = null;\n        this._bufferLength = 0;\n    }\n    build() {\n        if (this._completedStrings !== null) {\n            this._flushBuffer();\n            return this._completedStrings.join('');\n        }\n        return this._buildBuffer();\n    }\n    _buildBuffer() {\n        if (this._bufferLength === 0) {\n            return '';\n        }\n        const view = new Uint16Array(this._buffer.buffer, 0, this._bufferLength);\n        return getPlatformTextDecoder().decode(view);\n    }\n    _flushBuffer() {\n        const bufferString = this._buildBuffer();\n        this._bufferLength = 0;\n        if (this._completedStrings === null) {\n            this._completedStrings = [bufferString];\n        }\n        else {\n            this._completedStrings[this._completedStrings.length] = bufferString;\n        }\n    }\n    /**\n     * Append a char code (<2^16)\n     */\n    appendCharCode(charCode) {\n        const remainingSpace = this._capacity - this._bufferLength;\n        if (remainingSpace <= 1) {\n            if (remainingSpace === 0 || strings.isHighSurrogate(charCode)) {\n                this._flushBuffer();\n            }\n        }\n        this._buffer[this._bufferLength++] = charCode;\n    }\n    /**\n     * Append an ASCII char code (<2^8)\n     */\n    appendASCIICharCode(charCode) {\n        if (this._bufferLength === this._capacity) {\n            // buffer is full\n            this._flushBuffer();\n        }\n        this._buffer[this._bufferLength++] = charCode;\n    }\n    appendString(str) {\n        const strLen = str.length;\n        if (this._bufferLength + strLen >= this._capacity) {\n            // This string does not fit in the remaining buffer space\n            this._flushBuffer();\n            this._completedStrings[this._completedStrings.length] = str;\n            return;\n        }\n        for (let i = 0; i < strLen; i++) {\n            this._buffer[this._bufferLength++] = str.charCodeAt(i);\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as buffer from '../../../base/common/buffer.js';\nimport { decodeUTF16LE } from './stringBuilder.js';\nfunction escapeNewLine(str) {\n    return (str\n        .replace(/\\n/g, '\\\\n')\n        .replace(/\\r/g, '\\\\r'));\n}\nexport class TextChange {\n    get oldLength() {\n        return this.oldText.length;\n    }\n    get oldEnd() {\n        return this.oldPosition + this.oldText.length;\n    }\n    get newLength() {\n        return this.newText.length;\n    }\n    get newEnd() {\n        return this.newPosition + this.newText.length;\n    }\n    constructor(oldPosition, oldText, newPosition, newText) {\n        this.oldPosition = oldPosition;\n        this.oldText = oldText;\n        this.newPosition = newPosition;\n        this.newText = newText;\n    }\n    toString() {\n        if (this.oldText.length === 0) {\n            return `(insert@${this.oldPosition} \"${escapeNewLine(this.newText)}\")`;\n        }\n        if (this.newText.length === 0) {\n            return `(delete@${this.oldPosition} \"${escapeNewLine(this.oldText)}\")`;\n        }\n        return `(replace@${this.oldPosition} \"${escapeNewLine(this.oldText)}\" with \"${escapeNewLine(this.newText)}\")`;\n    }\n    static _writeStringSize(str) {\n        return (4 + 2 * str.length);\n    }\n    static _writeString(b, str, offset) {\n        const len = str.length;\n        buffer.writeUInt32BE(b, len, offset);\n        offset += 4;\n        for (let i = 0; i < len; i++) {\n            buffer.writeUInt16LE(b, str.charCodeAt(i), offset);\n            offset += 2;\n        }\n        return offset;\n    }\n    static _readString(b, offset) {\n        const len = buffer.readUInt32BE(b, offset);\n        offset += 4;\n        return decodeUTF16LE(b, offset, len);\n    }\n    writeSize() {\n        return (+4 // oldPosition\n            + 4 // newPosition\n            + TextChange._writeStringSize(this.oldText)\n            + TextChange._writeStringSize(this.newText));\n    }\n    write(b, offset) {\n        buffer.writeUInt32BE(b, this.oldPosition, offset);\n        offset += 4;\n        buffer.writeUInt32BE(b, this.newPosition, offset);\n        offset += 4;\n        offset = TextChange._writeString(b, this.oldText, offset);\n        offset = TextChange._writeString(b, this.newText, offset);\n        return offset;\n    }\n    static read(b, offset, dest) {\n        const oldPosition = buffer.readUInt32BE(b, offset);\n        offset += 4;\n        const newPosition = buffer.readUInt32BE(b, offset);\n        offset += 4;\n        const oldText = TextChange._readString(b, offset);\n        offset += TextChange._writeStringSize(oldText);\n        const newText = TextChange._readString(b, offset);\n        offset += TextChange._writeStringSize(newText);\n        dest.push(new TextChange(oldPosition, oldText, newPosition, newText));\n        return offset;\n    }\n}\nexport function compressConsecutiveTextChanges(prevEdits, currEdits) {\n    if (prevEdits === null || prevEdits.length === 0) {\n        return currEdits;\n    }\n    const compressor = new TextChangeCompressor(prevEdits, currEdits);\n    return compressor.compress();\n}\nclass TextChangeCompressor {\n    constructor(prevEdits, currEdits) {\n        this._prevEdits = prevEdits;\n        this._currEdits = currEdits;\n        this._result = [];\n        this._resultLen = 0;\n        this._prevLen = this._prevEdits.length;\n        this._prevDeltaOffset = 0;\n        this._currLen = this._currEdits.length;\n        this._currDeltaOffset = 0;\n    }\n    compress() {\n        let prevIndex = 0;\n        let currIndex = 0;\n        let prevEdit = this._getPrev(prevIndex);\n        let currEdit = this._getCurr(currIndex);\n        while (prevIndex < this._prevLen || currIndex < this._currLen) {\n            if (prevEdit === null) {\n                this._acceptCurr(currEdit);\n                currEdit = this._getCurr(++currIndex);\n                continue;\n            }\n            if (currEdit === null) {\n                this._acceptPrev(prevEdit);\n                prevEdit = this._getPrev(++prevIndex);\n                continue;\n            }\n            if (currEdit.oldEnd <= prevEdit.newPosition) {\n                this._acceptCurr(currEdit);\n                currEdit = this._getCurr(++currIndex);\n                continue;\n            }\n            if (prevEdit.newEnd <= currEdit.oldPosition) {\n                this._acceptPrev(prevEdit);\n                prevEdit = this._getPrev(++prevIndex);\n                continue;\n            }\n            if (currEdit.oldPosition < prevEdit.newPosition) {\n                const [e1, e2] = TextChangeCompressor._splitCurr(currEdit, prevEdit.newPosition - currEdit.oldPosition);\n                this._acceptCurr(e1);\n                currEdit = e2;\n                continue;\n            }\n            if (prevEdit.newPosition < currEdit.oldPosition) {\n                const [e1, e2] = TextChangeCompressor._splitPrev(prevEdit, currEdit.oldPosition - prevEdit.newPosition);\n                this._acceptPrev(e1);\n                prevEdit = e2;\n                continue;\n            }\n            // At this point, currEdit.oldPosition === prevEdit.newPosition\n            let mergePrev;\n            let mergeCurr;\n            if (currEdit.oldEnd === prevEdit.newEnd) {\n                mergePrev = prevEdit;\n                mergeCurr = currEdit;\n                prevEdit = this._getPrev(++prevIndex);\n                currEdit = this._getCurr(++currIndex);\n            }\n            else if (currEdit.oldEnd < prevEdit.newEnd) {\n                const [e1, e2] = TextChangeCompressor._splitPrev(prevEdit, currEdit.oldLength);\n                mergePrev = e1;\n                mergeCurr = currEdit;\n                prevEdit = e2;\n                currEdit = this._getCurr(++currIndex);\n            }\n            else {\n                const [e1, e2] = TextChangeCompressor._splitCurr(currEdit, prevEdit.newLength);\n                mergePrev = prevEdit;\n                mergeCurr = e1;\n                prevEdit = this._getPrev(++prevIndex);\n                currEdit = e2;\n            }\n            this._result[this._resultLen++] = new TextChange(mergePrev.oldPosition, mergePrev.oldText, mergeCurr.newPosition, mergeCurr.newText);\n            this._prevDeltaOffset += mergePrev.newLength - mergePrev.oldLength;\n            this._currDeltaOffset += mergeCurr.newLength - mergeCurr.oldLength;\n        }\n        const merged = TextChangeCompressor._merge(this._result);\n        const cleaned = TextChangeCompressor._removeNoOps(merged);\n        return cleaned;\n    }\n    _acceptCurr(currEdit) {\n        this._result[this._resultLen++] = TextChangeCompressor._rebaseCurr(this._prevDeltaOffset, currEdit);\n        this._currDeltaOffset += currEdit.newLength - currEdit.oldLength;\n    }\n    _getCurr(currIndex) {\n        return (currIndex < this._currLen ? this._currEdits[currIndex] : null);\n    }\n    _acceptPrev(prevEdit) {\n        this._result[this._resultLen++] = TextChangeCompressor._rebasePrev(this._currDeltaOffset, prevEdit);\n        this._prevDeltaOffset += prevEdit.newLength - prevEdit.oldLength;\n    }\n    _getPrev(prevIndex) {\n        return (prevIndex < this._prevLen ? this._prevEdits[prevIndex] : null);\n    }\n    static _rebaseCurr(prevDeltaOffset, currEdit) {\n        return new TextChange(currEdit.oldPosition - prevDeltaOffset, currEdit.oldText, currEdit.newPosition, currEdit.newText);\n    }\n    static _rebasePrev(currDeltaOffset, prevEdit) {\n        return new TextChange(prevEdit.oldPosition, prevEdit.oldText, prevEdit.newPosition + currDeltaOffset, prevEdit.newText);\n    }\n    static _splitPrev(edit, offset) {\n        const preText = edit.newText.substr(0, offset);\n        const postText = edit.newText.substr(offset);\n        return [\n            new TextChange(edit.oldPosition, edit.oldText, edit.newPosition, preText),\n            new TextChange(edit.oldEnd, '', edit.newPosition + offset, postText)\n        ];\n    }\n    static _splitCurr(edit, offset) {\n        const preText = edit.oldText.substr(0, offset);\n        const postText = edit.oldText.substr(offset);\n        return [\n            new TextChange(edit.oldPosition, preText, edit.newPosition, edit.newText),\n            new TextChange(edit.oldPosition + offset, postText, edit.newEnd, '')\n        ];\n    }\n    static _merge(edits) {\n        if (edits.length === 0) {\n            return edits;\n        }\n        const result = [];\n        let resultLen = 0;\n        let prev = edits[0];\n        for (let i = 1; i < edits.length; i++) {\n            const curr = edits[i];\n            if (prev.oldEnd === curr.oldPosition) {\n                // Merge into `prev`\n                prev = new TextChange(prev.oldPosition, prev.oldText + curr.oldText, prev.newPosition, prev.newText + curr.newText);\n            }\n            else {\n                result[resultLen++] = prev;\n                prev = curr;\n            }\n        }\n        result[resultLen++] = prev;\n        return result;\n    }\n    static _removeNoOps(edits) {\n        if (edits.length === 0) {\n            return edits;\n        }\n        const result = [];\n        let resultLen = 0;\n        for (let i = 0; i < edits.length; i++) {\n            const edit = edits[i];\n            if (edit.oldText === edit.newText) {\n                continue;\n            }\n            result[resultLen++] = edit;\n        }\n        return result;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport const EDITOR_MODEL_DEFAULTS = {\n    tabSize: 4,\n    indentSize: 4,\n    insertSpaces: true,\n    detectIndentation: true,\n    trimAutoWhitespace: true,\n    largeFileOptimizations: true,\n    bracketPairColorizationOptions: {\n        enabled: true,\n        independentColorPoolPerBracketType: false,\n    },\n};\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n * Describes what to do with the indentation when pressing Enter.\n */\nexport var IndentAction;\n(function (IndentAction) {\n    /**\n     * Insert new line and copy the previous line's indentation.\n     */\n    IndentAction[IndentAction[\"None\"] = 0] = \"None\";\n    /**\n     * Insert new line and indent once (relative to the previous line's indentation).\n     */\n    IndentAction[IndentAction[\"Indent\"] = 1] = \"Indent\";\n    /**\n     * Insert two new lines:\n     *  - the first one indented which will hold the cursor\n     *  - the second one at the same indentation level\n     */\n    IndentAction[IndentAction[\"IndentOutdent\"] = 2] = \"IndentOutdent\";\n    /**\n     * Insert new line and outdent once (relative to the previous line's indentation).\n     */\n    IndentAction[IndentAction[\"Outdent\"] = 3] = \"Outdent\";\n})(IndentAction || (IndentAction = {}));\n/**\n * @internal\n */\nexport class StandardAutoClosingPairConditional {\n    constructor(source) {\n        this._neutralCharacter = null;\n        this._neutralCharacterSearched = false;\n        this.open = source.open;\n        this.close = source.close;\n        // initially allowed in all tokens\n        this._inString = true;\n        this._inComment = true;\n        this._inRegEx = true;\n        if (Array.isArray(source.notIn)) {\n            for (let i = 0, len = source.notIn.length; i < len; i++) {\n                const notIn = source.notIn[i];\n                switch (notIn) {\n                    case 'string':\n                        this._inString = false;\n                        break;\n                    case 'comment':\n                        this._inComment = false;\n                        break;\n                    case 'regex':\n                        this._inRegEx = false;\n                        break;\n                }\n            }\n        }\n    }\n    isOK(standardToken) {\n        switch (standardToken) {\n            case 0 /* StandardTokenType.Other */:\n                return true;\n            case 1 /* StandardTokenType.Comment */:\n                return this._inComment;\n            case 2 /* StandardTokenType.String */:\n                return this._inString;\n            case 3 /* StandardTokenType.RegEx */:\n                return this._inRegEx;\n        }\n    }\n    shouldAutoClose(context, column) {\n        // Always complete on empty line\n        if (context.getTokenCount() === 0) {\n            return true;\n        }\n        const tokenIndex = context.findTokenIndexAtOffset(column - 2);\n        const standardTokenType = context.getStandardTokenType(tokenIndex);\n        return this.isOK(standardTokenType);\n    }\n    _findNeutralCharacterInRange(fromCharCode, toCharCode) {\n        for (let charCode = fromCharCode; charCode <= toCharCode; charCode++) {\n            const character = String.fromCharCode(charCode);\n            if (!this.open.includes(character) && !this.close.includes(character)) {\n                return character;\n            }\n        }\n        return null;\n    }\n    /**\n     * Find a character in the range [0-9a-zA-Z] that does not appear in the open or close\n     */\n    findNeutralCharacter() {\n        if (!this._neutralCharacterSearched) {\n            this._neutralCharacterSearched = true;\n            if (!this._neutralCharacter) {\n                this._neutralCharacter = this._findNeutralCharacterInRange(48 /* CharCode.Digit0 */, 57 /* CharCode.Digit9 */);\n            }\n            if (!this._neutralCharacter) {\n                this._neutralCharacter = this._findNeutralCharacterInRange(97 /* CharCode.a */, 122 /* CharCode.z */);\n            }\n            if (!this._neutralCharacter) {\n                this._neutralCharacter = this._findNeutralCharacterInRange(65 /* CharCode.A */, 90 /* CharCode.Z */);\n            }\n        }\n        return this._neutralCharacter;\n    }\n}\n/**\n * @internal\n */\nexport class AutoClosingPairs {\n    constructor(autoClosingPairs) {\n        this.autoClosingPairsOpenByStart = new Map();\n        this.autoClosingPairsOpenByEnd = new Map();\n        this.autoClosingPairsCloseByStart = new Map();\n        this.autoClosingPairsCloseByEnd = new Map();\n        this.autoClosingPairsCloseSingleChar = new Map();\n        for (const pair of autoClosingPairs) {\n            appendEntry(this.autoClosingPairsOpenByStart, pair.open.charAt(0), pair);\n            appendEntry(this.autoClosingPairsOpenByEnd, pair.open.charAt(pair.open.length - 1), pair);\n            appendEntry(this.autoClosingPairsCloseByStart, pair.close.charAt(0), pair);\n            appendEntry(this.autoClosingPairsCloseByEnd, pair.close.charAt(pair.close.length - 1), pair);\n            if (pair.close.length === 1 && pair.open.length === 1) {\n                appendEntry(this.autoClosingPairsCloseSingleChar, pair.close, pair);\n            }\n        }\n    }\n}\nfunction appendEntry(target, key, value) {\n    if (target.has(key)) {\n        target.get(key).push(value);\n    }\n    else {\n        target.set(key, [value]);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { StandardAutoClosingPairConditional } from '../languageConfiguration.js';\nexport class CharacterPairSupport {\n    static { this.DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED_QUOTES = ';:.,=}])> \\n\\t'; }\n    static { this.DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED_BRACKETS = '\\'\"`;:.,=}])> \\n\\t'; }\n    constructor(config) {\n        if (config.autoClosingPairs) {\n            this._autoClosingPairs = config.autoClosingPairs.map(el => new StandardAutoClosingPairConditional(el));\n        }\n        else if (config.brackets) {\n            this._autoClosingPairs = config.brackets.map(b => new StandardAutoClosingPairConditional({ open: b[0], close: b[1] }));\n        }\n        else {\n            this._autoClosingPairs = [];\n        }\n        if (config.__electricCharacterSupport && config.__electricCharacterSupport.docComment) {\n            const docComment = config.__electricCharacterSupport.docComment;\n            // IDocComment is legacy, only partially supported\n            this._autoClosingPairs.push(new StandardAutoClosingPairConditional({ open: docComment.open, close: docComment.close || '' }));\n        }\n        this._autoCloseBeforeForQuotes = typeof config.autoCloseBefore === 'string' ? config.autoCloseBefore : CharacterPairSupport.DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED_QUOTES;\n        this._autoCloseBeforeForBrackets = typeof config.autoCloseBefore === 'string' ? config.autoCloseBefore : CharacterPairSupport.DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED_BRACKETS;\n        this._surroundingPairs = config.surroundingPairs || this._autoClosingPairs;\n    }\n    getAutoClosingPairs() {\n        return this._autoClosingPairs;\n    }\n    getAutoCloseBeforeSet(forQuotes) {\n        return (forQuotes ? this._autoCloseBeforeForQuotes : this._autoCloseBeforeForBrackets);\n    }\n    getSurroundingPairs() {\n        return this._surroundingPairs;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { distinct } from '../../../../base/common/arrays.js';\nimport { ignoreBracketsInToken } from '../supports.js';\nimport { BracketsUtils } from './richEditBrackets.js';\nexport class BracketElectricCharacterSupport {\n    constructor(richEditBrackets) {\n        this._richEditBrackets = richEditBrackets;\n    }\n    getElectricCharacters() {\n        const result = [];\n        if (this._richEditBrackets) {\n            for (const bracket of this._richEditBrackets.brackets) {\n                for (const close of bracket.close) {\n                    const lastChar = close.charAt(close.length - 1);\n                    result.push(lastChar);\n                }\n            }\n        }\n        return distinct(result);\n    }\n    onElectricCharacter(character, context, column) {\n        if (!this._richEditBrackets || this._richEditBrackets.brackets.length === 0) {\n            return null;\n        }\n        const tokenIndex = context.findTokenIndexAtOffset(column - 1);\n        if (ignoreBracketsInToken(context.getStandardTokenType(tokenIndex))) {\n            return null;\n        }\n        const reversedBracketRegex = this._richEditBrackets.reversedRegex;\n        const text = context.getLineContent().substring(0, column - 1) + character;\n        const r = BracketsUtils.findPrevBracketInRange(reversedBracketRegex, 1, text, 0, text.length);\n        if (!r) {\n            return null;\n        }\n        const bracketText = text.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();\n        const isOpen = this._richEditBrackets.textIsOpenBracket[bracketText];\n        if (isOpen) {\n            return null;\n        }\n        const textBeforeBracket = context.getActualLineContentBefore(r.startColumn - 1);\n        if (!/^\\s*$/.test(textBeforeBracket)) {\n            // There is other text on the line before the bracket\n            return null;\n        }\n        return {\n            matchOpenBracket: bracketText\n        };\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nfunction resetGlobalRegex(reg) {\n    if (reg.global) {\n        reg.lastIndex = 0;\n    }\n    return true;\n}\nexport class IndentRulesSupport {\n    constructor(indentationRules) {\n        this._indentationRules = indentationRules;\n    }\n    shouldIncrease(text) {\n        if (this._indentationRules) {\n            if (this._indentationRules.increaseIndentPattern && resetGlobalRegex(this._indentationRules.increaseIndentPattern) && this._indentationRules.increaseIndentPattern.test(text)) {\n                return true;\n            }\n            // if (this._indentationRules.indentNextLinePattern && this._indentationRules.indentNextLinePattern.test(text)) {\n            // \treturn true;\n            // }\n        }\n        return false;\n    }\n    shouldDecrease(text) {\n        if (this._indentationRules && this._indentationRules.decreaseIndentPattern && resetGlobalRegex(this._indentationRules.decreaseIndentPattern) && this._indentationRules.decreaseIndentPattern.test(text)) {\n            return true;\n        }\n        return false;\n    }\n    shouldIndentNextLine(text) {\n        if (this._indentationRules && this._indentationRules.indentNextLinePattern && resetGlobalRegex(this._indentationRules.indentNextLinePattern) && this._indentationRules.indentNextLinePattern.test(text)) {\n            return true;\n        }\n        return false;\n    }\n    shouldIgnore(text) {\n        // the text matches `unIndentedLinePattern`\n        if (this._indentationRules && this._indentationRules.unIndentedLinePattern && resetGlobalRegex(this._indentationRules.unIndentedLinePattern) && this._indentationRules.unIndentedLinePattern.test(text)) {\n            return true;\n        }\n        return false;\n    }\n    getIndentMetadata(text) {\n        let ret = 0;\n        if (this.shouldIncrease(text)) {\n            ret += 1 /* IndentConsts.INCREASE_MASK */;\n        }\n        if (this.shouldDecrease(text)) {\n            ret += 2 /* IndentConsts.DECREASE_MASK */;\n        }\n        if (this.shouldIndentNextLine(text)) {\n            ret += 4 /* IndentConsts.INDENT_NEXTLINE_MASK */;\n        }\n        if (this.shouldIgnore(text)) {\n            ret += 8 /* IndentConsts.UNINDENT_MASK */;\n        }\n        return ret;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { onUnexpectedError } from '../../../../base/common/errors.js';\nimport * as strings from '../../../../base/common/strings.js';\nimport { IndentAction } from '../languageConfiguration.js';\nexport class OnEnterSupport {\n    constructor(opts) {\n        opts = opts || {};\n        opts.brackets = opts.brackets || [\n            ['(', ')'],\n            ['{', '}'],\n            ['[', ']']\n        ];\n        this._brackets = [];\n        opts.brackets.forEach((bracket) => {\n            const openRegExp = OnEnterSupport._createOpenBracketRegExp(bracket[0]);\n            const closeRegExp = OnEnterSupport._createCloseBracketRegExp(bracket[1]);\n            if (openRegExp && closeRegExp) {\n                this._brackets.push({\n                    open: bracket[0],\n                    openRegExp: openRegExp,\n                    close: bracket[1],\n                    closeRegExp: closeRegExp,\n                });\n            }\n        });\n        this._regExpRules = opts.onEnterRules || [];\n    }\n    onEnter(autoIndent, previousLineText, beforeEnterText, afterEnterText) {\n        // (1): `regExpRules`\n        if (autoIndent >= 3 /* EditorAutoIndentStrategy.Advanced */) {\n            for (let i = 0, len = this._regExpRules.length; i < len; i++) {\n                const rule = this._regExpRules[i];\n                const regResult = [{\n                        reg: rule.beforeText,\n                        text: beforeEnterText\n                    }, {\n                        reg: rule.afterText,\n                        text: afterEnterText\n                    }, {\n                        reg: rule.previousLineText,\n                        text: previousLineText\n                    }].every((obj) => {\n                    if (!obj.reg) {\n                        return true;\n                    }\n                    obj.reg.lastIndex = 0; // To disable the effect of the \"g\" flag.\n                    return obj.reg.test(obj.text);\n                });\n                if (regResult) {\n                    return rule.action;\n                }\n            }\n        }\n        // (2): Special indent-outdent\n        if (autoIndent >= 2 /* EditorAutoIndentStrategy.Brackets */) {\n            if (beforeEnterText.length > 0 && afterEnterText.length > 0) {\n                for (let i = 0, len = this._brackets.length; i < len; i++) {\n                    const bracket = this._brackets[i];\n                    if (bracket.openRegExp.test(beforeEnterText) && bracket.closeRegExp.test(afterEnterText)) {\n                        return { indentAction: IndentAction.IndentOutdent };\n                    }\n                }\n            }\n        }\n        // (4): Open bracket based logic\n        if (autoIndent >= 2 /* EditorAutoIndentStrategy.Brackets */) {\n            if (beforeEnterText.length > 0) {\n                for (let i = 0, len = this._brackets.length; i < len; i++) {\n                    const bracket = this._brackets[i];\n                    if (bracket.openRegExp.test(beforeEnterText)) {\n                        return { indentAction: IndentAction.Indent };\n                    }\n                }\n            }\n        }\n        return null;\n    }\n    static _createOpenBracketRegExp(bracket) {\n        let str = strings.escapeRegExpCharacters(bracket);\n        if (!/\\B/.test(str.charAt(0))) {\n            str = '\\\\b' + str;\n        }\n        str += '\\\\s*$';\n        return OnEnterSupport._safeRegExp(str);\n    }\n    static _createCloseBracketRegExp(bracket) {\n        let str = strings.escapeRegExpCharacters(bracket);\n        if (!/\\B/.test(str.charAt(str.length - 1))) {\n            str = str + '\\\\b';\n        }\n        str = '^\\\\s*' + str;\n        return OnEnterSupport._safeRegExp(str);\n    }\n    static _safeRegExp(def) {\n        try {\n            return new RegExp(def);\n        }\n        catch (err) {\n            onUnexpectedError(err);\n            return null;\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { CachedFunction } from '../../../../base/common/cache.js';\nimport { createBracketOrRegExp } from './richEditBrackets.js';\n/**\n * Captures all bracket related configurations for a single language.\n * Immutable.\n*/\nexport class LanguageBracketsConfiguration {\n    constructor(languageId, config) {\n        this.languageId = languageId;\n        const bracketPairs = config.brackets ? filterValidBrackets(config.brackets) : [];\n        const openingBracketInfos = new CachedFunction((bracket) => {\n            const closing = new Set();\n            return {\n                info: new OpeningBracketKind(this, bracket, closing),\n                closing,\n            };\n        });\n        const closingBracketInfos = new CachedFunction((bracket) => {\n            const opening = new Set();\n            const openingColorized = new Set();\n            return {\n                info: new ClosingBracketKind(this, bracket, opening, openingColorized),\n                opening,\n                openingColorized,\n            };\n        });\n        for (const [open, close] of bracketPairs) {\n            const opening = openingBracketInfos.get(open);\n            const closing = closingBracketInfos.get(close);\n            opening.closing.add(closing.info);\n            closing.opening.add(opening.info);\n        }\n        // Treat colorized brackets as brackets, and mark them as colorized.\n        const colorizedBracketPairs = config.colorizedBracketPairs\n            ? filterValidBrackets(config.colorizedBracketPairs)\n            // If not configured: Take all brackets except `<` ... `>`\n            // Many languages set < ... > as bracket pair, even though they also use it as comparison operator.\n            // This leads to problems when colorizing this bracket, so we exclude it if not explicitly configured otherwise.\n            // https://github.com/microsoft/vscode/issues/132476\n            : bracketPairs.filter((p) => !(p[0] === '<' && p[1] === '>'));\n        for (const [open, close] of colorizedBracketPairs) {\n            const opening = openingBracketInfos.get(open);\n            const closing = closingBracketInfos.get(close);\n            opening.closing.add(closing.info);\n            closing.openingColorized.add(opening.info);\n            closing.opening.add(opening.info);\n        }\n        this._openingBrackets = new Map([...openingBracketInfos.cachedValues].map(([k, v]) => [k, v.info]));\n        this._closingBrackets = new Map([...closingBracketInfos.cachedValues].map(([k, v]) => [k, v.info]));\n    }\n    /**\n     * No two brackets have the same bracket text.\n    */\n    get openingBrackets() {\n        return [...this._openingBrackets.values()];\n    }\n    /**\n     * No two brackets have the same bracket text.\n    */\n    get closingBrackets() {\n        return [...this._closingBrackets.values()];\n    }\n    getOpeningBracketInfo(bracketText) {\n        return this._openingBrackets.get(bracketText);\n    }\n    getClosingBracketInfo(bracketText) {\n        return this._closingBrackets.get(bracketText);\n    }\n    getBracketInfo(bracketText) {\n        return this.getOpeningBracketInfo(bracketText) || this.getClosingBracketInfo(bracketText);\n    }\n    getBracketRegExp(options) {\n        const brackets = Array.from([...this._openingBrackets.keys(), ...this._closingBrackets.keys()]);\n        return createBracketOrRegExp(brackets, options);\n    }\n}\nfunction filterValidBrackets(bracketPairs) {\n    return bracketPairs.filter(([open, close]) => open !== '' && close !== '');\n}\nexport class BracketKindBase {\n    constructor(config, bracketText) {\n        this.config = config;\n        this.bracketText = bracketText;\n    }\n    get languageId() {\n        return this.config.languageId;\n    }\n}\nexport class OpeningBracketKind extends BracketKindBase {\n    constructor(config, bracketText, openedBrackets) {\n        super(config, bracketText);\n        this.openedBrackets = openedBrackets;\n        this.isOpeningBracket = true;\n    }\n}\nexport class ClosingBracketKind extends BracketKindBase {\n    constructor(config, bracketText, \n    /**\n     * Non empty array of all opening brackets this bracket closes.\n    */\n    openingBrackets, openingColorizedBrackets) {\n        super(config, bracketText);\n        this.openingBrackets = openingBrackets;\n        this.openingColorizedBrackets = openingColorizedBrackets;\n        this.isOpeningBracket = false;\n    }\n    /**\n     * Checks if this bracket closes the given other bracket.\n     * If the bracket infos come from different configurations, this method will return false.\n    */\n    closes(other) {\n        if (other['config'] !== this.config) {\n            return false;\n        }\n        return this.openingBrackets.has(other);\n    }\n    closesColorized(other) {\n        if (other['config'] !== this.config) {\n            return false;\n        }\n        return this.openingColorizedBrackets.has(other);\n    }\n    getOpeningBrackets() {\n        return [...this.openingBrackets];\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable, toDisposable } from '../../../base/common/lifecycle.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { DEFAULT_WORD_REGEXP, ensureValidWordDefinition } from '../core/wordHelper.js';\nimport { AutoClosingPairs } from './languageConfiguration.js';\nimport { CharacterPairSupport } from './supports/characterPair.js';\nimport { BracketElectricCharacterSupport } from './supports/electricCharacter.js';\nimport { IndentRulesSupport } from './supports/indentRules.js';\nimport { OnEnterSupport } from './supports/onEnter.js';\nimport { RichEditBrackets } from './supports/richEditBrackets.js';\nimport { createDecorator } from '../../../platform/instantiation/common/instantiation.js';\nimport { IConfigurationService } from '../../../platform/configuration/common/configuration.js';\nimport { ILanguageService } from './language.js';\nimport { registerSingleton } from '../../../platform/instantiation/common/extensions.js';\nimport { PLAINTEXT_LANGUAGE_ID } from './modesRegistry.js';\nimport { LanguageBracketsConfiguration } from './supports/languageBracketsConfiguration.js';\nexport class LanguageConfigurationServiceChangeEvent {\n    constructor(languageId) {\n        this.languageId = languageId;\n    }\n    affects(languageId) {\n        return !this.languageId ? true : this.languageId === languageId;\n    }\n}\nexport const ILanguageConfigurationService = createDecorator('languageConfigurationService');\nlet LanguageConfigurationService = class LanguageConfigurationService extends Disposable {\n    constructor(configurationService, languageService) {\n        super();\n        this.configurationService = configurationService;\n        this.languageService = languageService;\n        this._registry = this._register(new LanguageConfigurationRegistry());\n        this.onDidChangeEmitter = this._register(new Emitter());\n        this.onDidChange = this.onDidChangeEmitter.event;\n        this.configurations = new Map();\n        const languageConfigKeys = new Set(Object.values(customizedLanguageConfigKeys));\n        this._register(this.configurationService.onDidChangeConfiguration((e) => {\n            const globalConfigChanged = e.change.keys.some((k) => languageConfigKeys.has(k));\n            const localConfigChanged = e.change.overrides\n                .filter(([overrideLangName, keys]) => keys.some((k) => languageConfigKeys.has(k)))\n                .map(([overrideLangName]) => overrideLangName);\n            if (globalConfigChanged) {\n                this.configurations.clear();\n                this.onDidChangeEmitter.fire(new LanguageConfigurationServiceChangeEvent(undefined));\n            }\n            else {\n                for (const languageId of localConfigChanged) {\n                    if (this.languageService.isRegisteredLanguageId(languageId)) {\n                        this.configurations.delete(languageId);\n                        this.onDidChangeEmitter.fire(new LanguageConfigurationServiceChangeEvent(languageId));\n                    }\n                }\n            }\n        }));\n        this._register(this._registry.onDidChange((e) => {\n            this.configurations.delete(e.languageId);\n            this.onDidChangeEmitter.fire(new LanguageConfigurationServiceChangeEvent(e.languageId));\n        }));\n    }\n    register(languageId, configuration, priority) {\n        return this._registry.register(languageId, configuration, priority);\n    }\n    getLanguageConfiguration(languageId) {\n        let result = this.configurations.get(languageId);\n        if (!result) {\n            result = computeConfig(languageId, this._registry, this.configurationService, this.languageService);\n            this.configurations.set(languageId, result);\n        }\n        return result;\n    }\n};\nLanguageConfigurationService = __decorate([\n    __param(0, IConfigurationService),\n    __param(1, ILanguageService)\n], LanguageConfigurationService);\nexport { LanguageConfigurationService };\nfunction computeConfig(languageId, registry, configurationService, languageService) {\n    let languageConfig = registry.getLanguageConfiguration(languageId);\n    if (!languageConfig) {\n        if (!languageService.isRegisteredLanguageId(languageId)) {\n            // this happens for the null language, which can be returned by monarch.\n            // Instead of throwing an error, we just return a default config.\n            return new ResolvedLanguageConfiguration(languageId, {});\n        }\n        languageConfig = new ResolvedLanguageConfiguration(languageId, {});\n    }\n    const customizedConfig = getCustomizedLanguageConfig(languageConfig.languageId, configurationService);\n    const data = combineLanguageConfigurations([languageConfig.underlyingConfig, customizedConfig]);\n    const config = new ResolvedLanguageConfiguration(languageConfig.languageId, data);\n    return config;\n}\nconst customizedLanguageConfigKeys = {\n    brackets: 'editor.language.brackets',\n    colorizedBracketPairs: 'editor.language.colorizedBracketPairs'\n};\nfunction getCustomizedLanguageConfig(languageId, configurationService) {\n    const brackets = configurationService.getValue(customizedLanguageConfigKeys.brackets, {\n        overrideIdentifier: languageId,\n    });\n    const colorizedBracketPairs = configurationService.getValue(customizedLanguageConfigKeys.colorizedBracketPairs, {\n        overrideIdentifier: languageId,\n    });\n    return {\n        brackets: validateBracketPairs(brackets),\n        colorizedBracketPairs: validateBracketPairs(colorizedBracketPairs),\n    };\n}\nfunction validateBracketPairs(data) {\n    if (!Array.isArray(data)) {\n        return undefined;\n    }\n    return data.map(pair => {\n        if (!Array.isArray(pair) || pair.length !== 2) {\n            return undefined;\n        }\n        return [pair[0], pair[1]];\n    }).filter((p) => !!p);\n}\nexport function getIndentationAtPosition(model, lineNumber, column) {\n    const lineText = model.getLineContent(lineNumber);\n    let indentation = strings.getLeadingWhitespace(lineText);\n    if (indentation.length > column - 1) {\n        indentation = indentation.substring(0, column - 1);\n    }\n    return indentation;\n}\nclass ComposedLanguageConfiguration {\n    constructor(languageId) {\n        this.languageId = languageId;\n        this._resolved = null;\n        this._entries = [];\n        this._order = 0;\n        this._resolved = null;\n    }\n    register(configuration, priority) {\n        const entry = new LanguageConfigurationContribution(configuration, priority, ++this._order);\n        this._entries.push(entry);\n        this._resolved = null;\n        return toDisposable(() => {\n            for (let i = 0; i < this._entries.length; i++) {\n                if (this._entries[i] === entry) {\n                    this._entries.splice(i, 1);\n                    this._resolved = null;\n                    break;\n                }\n            }\n        });\n    }\n    getResolvedConfiguration() {\n        if (!this._resolved) {\n            const config = this._resolve();\n            if (config) {\n                this._resolved = new ResolvedLanguageConfiguration(this.languageId, config);\n            }\n        }\n        return this._resolved;\n    }\n    _resolve() {\n        if (this._entries.length === 0) {\n            return null;\n        }\n        this._entries.sort(LanguageConfigurationContribution.cmp);\n        return combineLanguageConfigurations(this._entries.map(e => e.configuration));\n    }\n}\nfunction combineLanguageConfigurations(configs) {\n    let result = {\n        comments: undefined,\n        brackets: undefined,\n        wordPattern: undefined,\n        indentationRules: undefined,\n        onEnterRules: undefined,\n        autoClosingPairs: undefined,\n        surroundingPairs: undefined,\n        autoCloseBefore: undefined,\n        folding: undefined,\n        colorizedBracketPairs: undefined,\n        __electricCharacterSupport: undefined,\n    };\n    for (const entry of configs) {\n        result = {\n            comments: entry.comments || result.comments,\n            brackets: entry.brackets || result.brackets,\n            wordPattern: entry.wordPattern || result.wordPattern,\n            indentationRules: entry.indentationRules || result.indentationRules,\n            onEnterRules: entry.onEnterRules || result.onEnterRules,\n            autoClosingPairs: entry.autoClosingPairs || result.autoClosingPairs,\n            surroundingPairs: entry.surroundingPairs || result.surroundingPairs,\n            autoCloseBefore: entry.autoCloseBefore || result.autoCloseBefore,\n            folding: entry.folding || result.folding,\n            colorizedBracketPairs: entry.colorizedBracketPairs || result.colorizedBracketPairs,\n            __electricCharacterSupport: entry.__electricCharacterSupport || result.__electricCharacterSupport,\n        };\n    }\n    return result;\n}\nclass LanguageConfigurationContribution {\n    constructor(configuration, priority, order) {\n        this.configuration = configuration;\n        this.priority = priority;\n        this.order = order;\n    }\n    static cmp(a, b) {\n        if (a.priority === b.priority) {\n            // higher order last\n            return a.order - b.order;\n        }\n        // higher priority last\n        return a.priority - b.priority;\n    }\n}\nexport class LanguageConfigurationChangeEvent {\n    constructor(languageId) {\n        this.languageId = languageId;\n    }\n}\nexport class LanguageConfigurationRegistry extends Disposable {\n    constructor() {\n        super();\n        this._entries = new Map();\n        this._onDidChange = this._register(new Emitter());\n        this.onDidChange = this._onDidChange.event;\n        this._register(this.register(PLAINTEXT_LANGUAGE_ID, {\n            brackets: [\n                ['(', ')'],\n                ['[', ']'],\n                ['{', '}'],\n            ],\n            surroundingPairs: [\n                { open: '{', close: '}' },\n                { open: '[', close: ']' },\n                { open: '(', close: ')' },\n                { open: '<', close: '>' },\n                { open: '\\\"', close: '\\\"' },\n                { open: '\\'', close: '\\'' },\n                { open: '`', close: '`' },\n            ],\n            colorizedBracketPairs: [],\n            folding: {\n                offSide: true\n            }\n        }, 0));\n    }\n    /**\n     * @param priority Use a higher number for higher priority\n     */\n    register(languageId, configuration, priority = 0) {\n        let entries = this._entries.get(languageId);\n        if (!entries) {\n            entries = new ComposedLanguageConfiguration(languageId);\n            this._entries.set(languageId, entries);\n        }\n        const disposable = entries.register(configuration, priority);\n        this._onDidChange.fire(new LanguageConfigurationChangeEvent(languageId));\n        return toDisposable(() => {\n            disposable.dispose();\n            this._onDidChange.fire(new LanguageConfigurationChangeEvent(languageId));\n        });\n    }\n    getLanguageConfiguration(languageId) {\n        const entries = this._entries.get(languageId);\n        return entries?.getResolvedConfiguration() || null;\n    }\n}\n/**\n * Immutable.\n*/\nexport class ResolvedLanguageConfiguration {\n    constructor(languageId, underlyingConfig) {\n        this.languageId = languageId;\n        this.underlyingConfig = underlyingConfig;\n        this._brackets = null;\n        this._electricCharacter = null;\n        this._onEnterSupport =\n            this.underlyingConfig.brackets ||\n                this.underlyingConfig.indentationRules ||\n                this.underlyingConfig.onEnterRules\n                ? new OnEnterSupport(this.underlyingConfig)\n                : null;\n        this.comments = ResolvedLanguageConfiguration._handleComments(this.underlyingConfig);\n        this.characterPair = new CharacterPairSupport(this.underlyingConfig);\n        this.wordDefinition = this.underlyingConfig.wordPattern || DEFAULT_WORD_REGEXP;\n        this.indentationRules = this.underlyingConfig.indentationRules;\n        if (this.underlyingConfig.indentationRules) {\n            this.indentRulesSupport = new IndentRulesSupport(this.underlyingConfig.indentationRules);\n        }\n        else {\n            this.indentRulesSupport = null;\n        }\n        this.foldingRules = this.underlyingConfig.folding || {};\n        this.bracketsNew = new LanguageBracketsConfiguration(languageId, this.underlyingConfig);\n    }\n    getWordDefinition() {\n        return ensureValidWordDefinition(this.wordDefinition);\n    }\n    get brackets() {\n        if (!this._brackets && this.underlyingConfig.brackets) {\n            this._brackets = new RichEditBrackets(this.languageId, this.underlyingConfig.brackets);\n        }\n        return this._brackets;\n    }\n    get electricCharacter() {\n        if (!this._electricCharacter) {\n            this._electricCharacter = new BracketElectricCharacterSupport(this.brackets);\n        }\n        return this._electricCharacter;\n    }\n    onEnter(autoIndent, previousLineText, beforeEnterText, afterEnterText) {\n        if (!this._onEnterSupport) {\n            return null;\n        }\n        return this._onEnterSupport.onEnter(autoIndent, previousLineText, beforeEnterText, afterEnterText);\n    }\n    getAutoClosingPairs() {\n        return new AutoClosingPairs(this.characterPair.getAutoClosingPairs());\n    }\n    getAutoCloseBeforeSet(forQuotes) {\n        return this.characterPair.getAutoCloseBeforeSet(forQuotes);\n    }\n    getSurroundingPairs() {\n        return this.characterPair.getSurroundingPairs();\n    }\n    static _handleComments(conf) {\n        const commentRule = conf.comments;\n        if (!commentRule) {\n            return null;\n        }\n        // comment configuration\n        const comments = {};\n        if (commentRule.lineComment) {\n            comments.lineCommentToken = commentRule.lineComment;\n        }\n        if (commentRule.blockComment) {\n            const [blockStart, blockEnd] = commentRule.blockComment;\n            comments.blockCommentStartToken = blockStart;\n            comments.blockCommentEndToken = blockEnd;\n        }\n        return comments;\n    }\n}\nregisterSingleton(ILanguageConfigurationService, LanguageConfigurationService, 1 /* InstantiationType.Delayed */);\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Token, TokenizationResult, EncodedTokenizationResult } from '../languages.js';\nexport const NullState = new class {\n    clone() {\n        return this;\n    }\n    equals(other) {\n        return (this === other);\n    }\n};\nexport function nullTokenize(languageId, state) {\n    return new TokenizationResult([new Token(0, '', languageId)], state);\n}\nexport function nullTokenizeEncoded(languageId, state) {\n    const tokens = new Uint32Array(2);\n    tokens[0] = 0;\n    tokens[1] = ((languageId << 0 /* MetadataConsts.LANGUAGEID_OFFSET */)\n        | (0 /* StandardTokenType.Other */ << 8 /* MetadataConsts.TOKEN_TYPE_OFFSET */)\n        | (0 /* FontStyle.None */ << 11 /* MetadataConsts.FONT_STYLE_OFFSET */)\n        | (1 /* ColorId.DefaultForeground */ << 15 /* MetadataConsts.FOREGROUND_OFFSET */)\n        | (2 /* ColorId.DefaultBackground */ << 24 /* MetadataConsts.BACKGROUND_OFFSET */)) >>> 0;\n    return new EncodedTokenizationResult(tokens, state === null ? NullState : state);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport function createScopedLineTokens(context, offset) {\n    const tokenCount = context.getCount();\n    const tokenIndex = context.findTokenIndexAtOffset(offset);\n    const desiredLanguageId = context.getLanguageId(tokenIndex);\n    let lastTokenIndex = tokenIndex;\n    while (lastTokenIndex + 1 < tokenCount && context.getLanguageId(lastTokenIndex + 1) === desiredLanguageId) {\n        lastTokenIndex++;\n    }\n    let firstTokenIndex = tokenIndex;\n    while (firstTokenIndex > 0 && context.getLanguageId(firstTokenIndex - 1) === desiredLanguageId) {\n        firstTokenIndex--;\n    }\n    return new ScopedLineTokens(context, desiredLanguageId, firstTokenIndex, lastTokenIndex + 1, context.getStartOffset(firstTokenIndex), context.getEndOffset(lastTokenIndex));\n}\nexport class ScopedLineTokens {\n    constructor(actual, languageId, firstTokenIndex, lastTokenIndex, firstCharOffset, lastCharOffset) {\n        this._scopedLineTokensBrand = undefined;\n        this._actual = actual;\n        this.languageId = languageId;\n        this._firstTokenIndex = firstTokenIndex;\n        this._lastTokenIndex = lastTokenIndex;\n        this.firstCharOffset = firstCharOffset;\n        this._lastCharOffset = lastCharOffset;\n        this.languageIdCodec = actual.languageIdCodec;\n    }\n    getLineContent() {\n        const actualLineContent = this._actual.getLineContent();\n        return actualLineContent.substring(this.firstCharOffset, this._lastCharOffset);\n    }\n    getLineLength() {\n        return this._lastCharOffset - this.firstCharOffset;\n    }\n    getActualLineContentBefore(offset) {\n        const actualLineContent = this._actual.getLineContent();\n        return actualLineContent.substring(0, this.firstCharOffset + offset);\n    }\n    getTokenCount() {\n        return this._lastTokenIndex - this._firstTokenIndex;\n    }\n    findTokenIndexAtOffset(offset) {\n        return this._actual.findTokenIndexAtOffset(offset + this.firstCharOffset) - this._firstTokenIndex;\n    }\n    getStandardTokenType(tokenIndex) {\n        return this._actual.getStandardTokenType(tokenIndex + this._firstTokenIndex);\n    }\n    toIViewLineTokens() {\n        return this._actual.sliceAndInflate(this.firstCharOffset, this._lastCharOffset, 0);\n    }\n}\nexport function ignoreBracketsInToken(standardTokenType) {\n    return (standardTokenType & 3 /* IgnoreBracketsInTokens.value */) !== 0;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../../base/common/strings.js';\nimport * as stringBuilder from '../../core/stringBuilder.js';\nimport { Range } from '../../core/range.js';\n/**\n * Represents a grouping of colliding bracket pairs.\n *\n * Most of the times this contains a single bracket pair,\n * but sometimes this contains multiple bracket pairs in cases\n * where the same string appears as a closing bracket for multiple\n * bracket pairs, or the same string appears an opening bracket for\n * multiple bracket pairs.\n *\n * e.g. of a group containing a single pair:\n *   open: ['{'], close: ['}']\n *\n * e.g. of a group containing multiple pairs:\n *   open: ['if', 'for'], close: ['end', 'end']\n */\nexport class RichEditBracket {\n    constructor(languageId, index, open, close, forwardRegex, reversedRegex) {\n        this._richEditBracketBrand = undefined;\n        this.languageId = languageId;\n        this.index = index;\n        this.open = open;\n        this.close = close;\n        this.forwardRegex = forwardRegex;\n        this.reversedRegex = reversedRegex;\n        this._openSet = RichEditBracket._toSet(this.open);\n        this._closeSet = RichEditBracket._toSet(this.close);\n    }\n    /**\n     * Check if the provided `text` is an open bracket in this group.\n     */\n    isOpen(text) {\n        return this._openSet.has(text);\n    }\n    /**\n     * Check if the provided `text` is a close bracket in this group.\n     */\n    isClose(text) {\n        return this._closeSet.has(text);\n    }\n    static _toSet(arr) {\n        const result = new Set();\n        for (const element of arr) {\n            result.add(element);\n        }\n        return result;\n    }\n}\n/**\n * Groups together brackets that have equal open or close sequences.\n *\n * For example, if the following brackets are defined:\n *   ['IF','END']\n *   ['for','end']\n *   ['{','}']\n *\n * Then the grouped brackets would be:\n *   { open: ['if', 'for'], close: ['end', 'end'] }\n *   { open: ['{'], close: ['}'] }\n *\n */\nfunction groupFuzzyBrackets(brackets) {\n    const N = brackets.length;\n    brackets = brackets.map(b => [b[0].toLowerCase(), b[1].toLowerCase()]);\n    const group = [];\n    for (let i = 0; i < N; i++) {\n        group[i] = i;\n    }\n    const areOverlapping = (a, b) => {\n        const [aOpen, aClose] = a;\n        const [bOpen, bClose] = b;\n        return (aOpen === bOpen || aOpen === bClose || aClose === bOpen || aClose === bClose);\n    };\n    const mergeGroups = (g1, g2) => {\n        const newG = Math.min(g1, g2);\n        const oldG = Math.max(g1, g2);\n        for (let i = 0; i < N; i++) {\n            if (group[i] === oldG) {\n                group[i] = newG;\n            }\n        }\n    };\n    // group together brackets that have the same open or the same close sequence\n    for (let i = 0; i < N; i++) {\n        const a = brackets[i];\n        for (let j = i + 1; j < N; j++) {\n            const b = brackets[j];\n            if (areOverlapping(a, b)) {\n                mergeGroups(group[i], group[j]);\n            }\n        }\n    }\n    const result = [];\n    for (let g = 0; g < N; g++) {\n        const currentOpen = [];\n        const currentClose = [];\n        for (let i = 0; i < N; i++) {\n            if (group[i] === g) {\n                const [open, close] = brackets[i];\n                currentOpen.push(open);\n                currentClose.push(close);\n            }\n        }\n        if (currentOpen.length > 0) {\n            result.push({\n                open: currentOpen,\n                close: currentClose\n            });\n        }\n    }\n    return result;\n}\nexport class RichEditBrackets {\n    constructor(languageId, _brackets) {\n        this._richEditBracketsBrand = undefined;\n        const brackets = groupFuzzyBrackets(_brackets);\n        this.brackets = brackets.map((b, index) => {\n            return new RichEditBracket(languageId, index, b.open, b.close, getRegexForBracketPair(b.open, b.close, brackets, index), getReversedRegexForBracketPair(b.open, b.close, brackets, index));\n        });\n        this.forwardRegex = getRegexForBrackets(this.brackets);\n        this.reversedRegex = getReversedRegexForBrackets(this.brackets);\n        this.textIsBracket = {};\n        this.textIsOpenBracket = {};\n        this.maxBracketLength = 0;\n        for (const bracket of this.brackets) {\n            for (const open of bracket.open) {\n                this.textIsBracket[open] = bracket;\n                this.textIsOpenBracket[open] = true;\n                this.maxBracketLength = Math.max(this.maxBracketLength, open.length);\n            }\n            for (const close of bracket.close) {\n                this.textIsBracket[close] = bracket;\n                this.textIsOpenBracket[close] = false;\n                this.maxBracketLength = Math.max(this.maxBracketLength, close.length);\n            }\n        }\n    }\n}\nfunction collectSuperstrings(str, brackets, currentIndex, dest) {\n    for (let i = 0, len = brackets.length; i < len; i++) {\n        if (i === currentIndex) {\n            continue;\n        }\n        const bracket = brackets[i];\n        for (const open of bracket.open) {\n            if (open.indexOf(str) >= 0) {\n                dest.push(open);\n            }\n        }\n        for (const close of bracket.close) {\n            if (close.indexOf(str) >= 0) {\n                dest.push(close);\n            }\n        }\n    }\n}\nfunction lengthcmp(a, b) {\n    return a.length - b.length;\n}\nfunction unique(arr) {\n    if (arr.length <= 1) {\n        return arr;\n    }\n    const result = [];\n    const seen = new Set();\n    for (const element of arr) {\n        if (seen.has(element)) {\n            continue;\n        }\n        result.push(element);\n        seen.add(element);\n    }\n    return result;\n}\n/**\n * Create a regular expression that can be used to search forward in a piece of text\n * for a group of bracket pairs. But this regex must be built in a way in which\n * it is aware of the other bracket pairs defined for the language.\n *\n * For example, if a language contains the following bracket pairs:\n *   ['begin', 'end']\n *   ['if', 'end if']\n * The two bracket pairs do not collide because no open or close brackets are equal.\n * So the function getRegexForBracketPair is called twice, once with\n * the ['begin'], ['end'] group consisting of one bracket pair, and once with\n * the ['if'], ['end if'] group consiting of the other bracket pair.\n *\n * But there could be a situation where an occurrence of 'end if' is mistaken\n * for an occurrence of 'end'.\n *\n * Therefore, for the bracket pair ['begin', 'end'], the regex will also\n * target 'end if'. The regex will be something like:\n *   /(\\bend if\\b)|(\\bend\\b)|(\\bif\\b)/\n *\n * The regex also searches for \"superstrings\" (other brackets that might be mistaken with the current bracket).\n *\n */\nfunction getRegexForBracketPair(open, close, brackets, currentIndex) {\n    // search in all brackets for other brackets that are a superstring of these brackets\n    let pieces = [];\n    pieces = pieces.concat(open);\n    pieces = pieces.concat(close);\n    for (let i = 0, len = pieces.length; i < len; i++) {\n        collectSuperstrings(pieces[i], brackets, currentIndex, pieces);\n    }\n    pieces = unique(pieces);\n    pieces.sort(lengthcmp);\n    pieces.reverse();\n    return createBracketOrRegExp(pieces);\n}\n/**\n * Matching a regular expression in JS can only be done \"forwards\". So JS offers natively only\n * methods to find the first match of a regex in a string. But sometimes, it is useful to\n * find the last match of a regex in a string. For such a situation, a nice solution is to\n * simply reverse the string and then search for a reversed regex.\n *\n * This function also has the fine details of `getRegexForBracketPair`. For the same example\n * given above, the regex produced here would look like:\n *   /(\\bfi dne\\b)|(\\bdne\\b)|(\\bfi\\b)/\n */\nfunction getReversedRegexForBracketPair(open, close, brackets, currentIndex) {\n    // search in all brackets for other brackets that are a superstring of these brackets\n    let pieces = [];\n    pieces = pieces.concat(open);\n    pieces = pieces.concat(close);\n    for (let i = 0, len = pieces.length; i < len; i++) {\n        collectSuperstrings(pieces[i], brackets, currentIndex, pieces);\n    }\n    pieces = unique(pieces);\n    pieces.sort(lengthcmp);\n    pieces.reverse();\n    return createBracketOrRegExp(pieces.map(toReversedString));\n}\n/**\n * Creates a regular expression that targets all bracket pairs.\n *\n * e.g. for the bracket pairs:\n *  ['{','}']\n *  ['begin,'end']\n *  ['for','end']\n * the regex would look like:\n *  /(\\{)|(\\})|(\\bbegin\\b)|(\\bend\\b)|(\\bfor\\b)/\n */\nfunction getRegexForBrackets(brackets) {\n    let pieces = [];\n    for (const bracket of brackets) {\n        for (const open of bracket.open) {\n            pieces.push(open);\n        }\n        for (const close of bracket.close) {\n            pieces.push(close);\n        }\n    }\n    pieces = unique(pieces);\n    return createBracketOrRegExp(pieces);\n}\n/**\n * Matching a regular expression in JS can only be done \"forwards\". So JS offers natively only\n * methods to find the first match of a regex in a string. But sometimes, it is useful to\n * find the last match of a regex in a string. For such a situation, a nice solution is to\n * simply reverse the string and then search for a reversed regex.\n *\n * e.g. for the bracket pairs:\n *  ['{','}']\n *  ['begin,'end']\n *  ['for','end']\n * the regex would look like:\n *  /(\\{)|(\\})|(\\bnigeb\\b)|(\\bdne\\b)|(\\brof\\b)/\n */\nfunction getReversedRegexForBrackets(brackets) {\n    let pieces = [];\n    for (const bracket of brackets) {\n        for (const open of bracket.open) {\n            pieces.push(open);\n        }\n        for (const close of bracket.close) {\n            pieces.push(close);\n        }\n    }\n    pieces = unique(pieces);\n    return createBracketOrRegExp(pieces.map(toReversedString));\n}\nfunction prepareBracketForRegExp(str) {\n    // This bracket pair uses letters like e.g. \"begin\" - \"end\"\n    const insertWordBoundaries = (/^[\\w ]+$/.test(str));\n    str = strings.escapeRegExpCharacters(str);\n    return (insertWordBoundaries ? `\\\\b${str}\\\\b` : str);\n}\nexport function createBracketOrRegExp(pieces, options) {\n    const regexStr = `(${pieces.map(prepareBracketForRegExp).join(')|(')})`;\n    return strings.createRegExp(regexStr, true, options);\n}\nconst toReversedString = (function () {\n    function reverse(str) {\n        // create a Uint16Array and then use a TextDecoder to create a string\n        const arr = new Uint16Array(str.length);\n        let offset = 0;\n        for (let i = str.length - 1; i >= 0; i--) {\n            arr[offset++] = str.charCodeAt(i);\n        }\n        return stringBuilder.getPlatformTextDecoder().decode(arr);\n    }\n    let lastInput = null;\n    let lastOutput = null;\n    return function toReversedString(str) {\n        if (lastInput !== str) {\n            lastInput = str;\n            lastOutput = reverse(lastInput);\n        }\n        return lastOutput;\n    };\n})();\nexport class BracketsUtils {\n    static _findPrevBracketInText(reversedBracketRegex, lineNumber, reversedText, offset) {\n        const m = reversedText.match(reversedBracketRegex);\n        if (!m) {\n            return null;\n        }\n        const matchOffset = reversedText.length - (m.index || 0);\n        const matchLength = m[0].length;\n        const absoluteMatchOffset = offset + matchOffset;\n        return new Range(lineNumber, absoluteMatchOffset - matchLength + 1, lineNumber, absoluteMatchOffset + 1);\n    }\n    static findPrevBracketInRange(reversedBracketRegex, lineNumber, lineText, startOffset, endOffset) {\n        // Because JS does not support backwards regex search, we search forwards in a reversed string with a reversed regex ;)\n        const reversedLineText = toReversedString(lineText);\n        const reversedSubstr = reversedLineText.substring(lineText.length - endOffset, lineText.length - startOffset);\n        return this._findPrevBracketInText(reversedBracketRegex, lineNumber, reversedSubstr, startOffset);\n    }\n    static findNextBracketInText(bracketRegex, lineNumber, text, offset) {\n        const m = text.match(bracketRegex);\n        if (!m) {\n            return null;\n        }\n        const matchOffset = m.index || 0;\n        const matchLength = m[0].length;\n        if (matchLength === 0) {\n            return null;\n        }\n        const absoluteMatchOffset = offset + matchOffset;\n        return new Range(lineNumber, absoluteMatchOffset + 1, lineNumber, absoluteMatchOffset + 1 + matchLength);\n    }\n    static findNextBracketInRange(bracketRegex, lineNumber, lineText, startOffset, endOffset) {\n        const substr = lineText.substring(startOffset, endOffset);\n        return this.findNextBracketInText(bracketRegex, lineNumber, substr, startOffset);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { BugIndicatingError } from '../../../../../base/common/errors.js';\nimport { CursorColumns } from '../../../core/cursorColumns.js';\nimport { lengthAdd, lengthGetLineCount, lengthToObj, lengthZero } from './length.js';\nimport { SmallImmutableSet } from './smallImmutableSet.js';\n/**\n * The base implementation for all AST nodes.\n*/\nclass BaseAstNode {\n    /**\n     * The length of the entire node, which should equal the sum of lengths of all children.\n    */\n    get length() {\n        return this._length;\n    }\n    constructor(length) {\n        this._length = length;\n    }\n}\n/**\n * Represents a bracket pair including its child (e.g. `{ ... }`).\n * Might be unclosed.\n * Immutable, if all children are immutable.\n*/\nexport class PairAstNode extends BaseAstNode {\n    static create(openingBracket, child, closingBracket) {\n        let length = openingBracket.length;\n        if (child) {\n            length = lengthAdd(length, child.length);\n        }\n        if (closingBracket) {\n            length = lengthAdd(length, closingBracket.length);\n        }\n        return new PairAstNode(length, openingBracket, child, closingBracket, child ? child.missingOpeningBracketIds : SmallImmutableSet.getEmpty());\n    }\n    get kind() {\n        return 2 /* AstNodeKind.Pair */;\n    }\n    get listHeight() {\n        return 0;\n    }\n    get childrenLength() {\n        return 3;\n    }\n    getChild(idx) {\n        switch (idx) {\n            case 0: return this.openingBracket;\n            case 1: return this.child;\n            case 2: return this.closingBracket;\n        }\n        throw new Error('Invalid child index');\n    }\n    /**\n     * Avoid using this property, it allocates an array!\n    */\n    get children() {\n        const result = [];\n        result.push(this.openingBracket);\n        if (this.child) {\n            result.push(this.child);\n        }\n        if (this.closingBracket) {\n            result.push(this.closingBracket);\n        }\n        return result;\n    }\n    constructor(length, openingBracket, child, closingBracket, missingOpeningBracketIds) {\n        super(length);\n        this.openingBracket = openingBracket;\n        this.child = child;\n        this.closingBracket = closingBracket;\n        this.missingOpeningBracketIds = missingOpeningBracketIds;\n    }\n    canBeReused(openBracketIds) {\n        if (this.closingBracket === null) {\n            // Unclosed pair ast nodes only\n            // end at the end of the document\n            // or when a parent node is closed.\n            // This could be improved:\n            // Only return false if some next token is neither \"undefined\" nor a bracket that closes a parent.\n            return false;\n        }\n        if (openBracketIds.intersects(this.missingOpeningBracketIds)) {\n            return false;\n        }\n        return true;\n    }\n    deepClone() {\n        return new PairAstNode(this.length, this.openingBracket.deepClone(), this.child && this.child.deepClone(), this.closingBracket && this.closingBracket.deepClone(), this.missingOpeningBracketIds);\n    }\n    computeMinIndentation(offset, textModel) {\n        return this.child ? this.child.computeMinIndentation(lengthAdd(offset, this.openingBracket.length), textModel) : Number.MAX_SAFE_INTEGER;\n    }\n}\nexport class ListAstNode extends BaseAstNode {\n    /**\n     * This method uses more memory-efficient list nodes that can only store 2 or 3 children.\n    */\n    static create23(item1, item2, item3, immutable = false) {\n        let length = item1.length;\n        let missingBracketIds = item1.missingOpeningBracketIds;\n        if (item1.listHeight !== item2.listHeight) {\n            throw new Error('Invalid list heights');\n        }\n        length = lengthAdd(length, item2.length);\n        missingBracketIds = missingBracketIds.merge(item2.missingOpeningBracketIds);\n        if (item3) {\n            if (item1.listHeight !== item3.listHeight) {\n                throw new Error('Invalid list heights');\n            }\n            length = lengthAdd(length, item3.length);\n            missingBracketIds = missingBracketIds.merge(item3.missingOpeningBracketIds);\n        }\n        return immutable\n            ? new Immutable23ListAstNode(length, item1.listHeight + 1, item1, item2, item3, missingBracketIds)\n            : new TwoThreeListAstNode(length, item1.listHeight + 1, item1, item2, item3, missingBracketIds);\n    }\n    static getEmpty() {\n        return new ImmutableArrayListAstNode(lengthZero, 0, [], SmallImmutableSet.getEmpty());\n    }\n    get kind() {\n        return 4 /* AstNodeKind.List */;\n    }\n    get missingOpeningBracketIds() {\n        return this._missingOpeningBracketIds;\n    }\n    /**\n     * Use ListAstNode.create.\n    */\n    constructor(length, listHeight, _missingOpeningBracketIds) {\n        super(length);\n        this.listHeight = listHeight;\n        this._missingOpeningBracketIds = _missingOpeningBracketIds;\n        this.cachedMinIndentation = -1;\n    }\n    throwIfImmutable() {\n        // NOOP\n    }\n    makeLastElementMutable() {\n        this.throwIfImmutable();\n        const childCount = this.childrenLength;\n        if (childCount === 0) {\n            return undefined;\n        }\n        const lastChild = this.getChild(childCount - 1);\n        const mutable = lastChild.kind === 4 /* AstNodeKind.List */ ? lastChild.toMutable() : lastChild;\n        if (lastChild !== mutable) {\n            this.setChild(childCount - 1, mutable);\n        }\n        return mutable;\n    }\n    makeFirstElementMutable() {\n        this.throwIfImmutable();\n        const childCount = this.childrenLength;\n        if (childCount === 0) {\n            return undefined;\n        }\n        const firstChild = this.getChild(0);\n        const mutable = firstChild.kind === 4 /* AstNodeKind.List */ ? firstChild.toMutable() : firstChild;\n        if (firstChild !== mutable) {\n            this.setChild(0, mutable);\n        }\n        return mutable;\n    }\n    canBeReused(openBracketIds) {\n        if (openBracketIds.intersects(this.missingOpeningBracketIds)) {\n            return false;\n        }\n        if (this.childrenLength === 0) {\n            // Don't reuse empty lists.\n            return false;\n        }\n        let lastChild = this;\n        while (lastChild.kind === 4 /* AstNodeKind.List */) {\n            const lastLength = lastChild.childrenLength;\n            if (lastLength === 0) {\n                // Empty lists should never be contained in other lists.\n                throw new BugIndicatingError();\n            }\n            lastChild = lastChild.getChild(lastLength - 1);\n        }\n        return lastChild.canBeReused(openBracketIds);\n    }\n    handleChildrenChanged() {\n        this.throwIfImmutable();\n        const count = this.childrenLength;\n        let length = this.getChild(0).length;\n        let unopenedBrackets = this.getChild(0).missingOpeningBracketIds;\n        for (let i = 1; i < count; i++) {\n            const child = this.getChild(i);\n            length = lengthAdd(length, child.length);\n            unopenedBrackets = unopenedBrackets.merge(child.missingOpeningBracketIds);\n        }\n        this._length = length;\n        this._missingOpeningBracketIds = unopenedBrackets;\n        this.cachedMinIndentation = -1;\n    }\n    computeMinIndentation(offset, textModel) {\n        if (this.cachedMinIndentation !== -1) {\n            return this.cachedMinIndentation;\n        }\n        let minIndentation = Number.MAX_SAFE_INTEGER;\n        let childOffset = offset;\n        for (let i = 0; i < this.childrenLength; i++) {\n            const child = this.getChild(i);\n            if (child) {\n                minIndentation = Math.min(minIndentation, child.computeMinIndentation(childOffset, textModel));\n                childOffset = lengthAdd(childOffset, child.length);\n            }\n        }\n        this.cachedMinIndentation = minIndentation;\n        return minIndentation;\n    }\n}\nclass TwoThreeListAstNode extends ListAstNode {\n    get childrenLength() {\n        return this._item3 !== null ? 3 : 2;\n    }\n    getChild(idx) {\n        switch (idx) {\n            case 0: return this._item1;\n            case 1: return this._item2;\n            case 2: return this._item3;\n        }\n        throw new Error('Invalid child index');\n    }\n    setChild(idx, node) {\n        switch (idx) {\n            case 0:\n                this._item1 = node;\n                return;\n            case 1:\n                this._item2 = node;\n                return;\n            case 2:\n                this._item3 = node;\n                return;\n        }\n        throw new Error('Invalid child index');\n    }\n    get children() {\n        return this._item3 ? [this._item1, this._item2, this._item3] : [this._item1, this._item2];\n    }\n    get item1() {\n        return this._item1;\n    }\n    get item2() {\n        return this._item2;\n    }\n    get item3() {\n        return this._item3;\n    }\n    constructor(length, listHeight, _item1, _item2, _item3, missingOpeningBracketIds) {\n        super(length, listHeight, missingOpeningBracketIds);\n        this._item1 = _item1;\n        this._item2 = _item2;\n        this._item3 = _item3;\n    }\n    deepClone() {\n        return new TwoThreeListAstNode(this.length, this.listHeight, this._item1.deepClone(), this._item2.deepClone(), this._item3 ? this._item3.deepClone() : null, this.missingOpeningBracketIds);\n    }\n    appendChildOfSameHeight(node) {\n        if (this._item3) {\n            throw new Error('Cannot append to a full (2,3) tree node');\n        }\n        this.throwIfImmutable();\n        this._item3 = node;\n        this.handleChildrenChanged();\n    }\n    unappendChild() {\n        if (!this._item3) {\n            throw new Error('Cannot remove from a non-full (2,3) tree node');\n        }\n        this.throwIfImmutable();\n        const result = this._item3;\n        this._item3 = null;\n        this.handleChildrenChanged();\n        return result;\n    }\n    prependChildOfSameHeight(node) {\n        if (this._item3) {\n            throw new Error('Cannot prepend to a full (2,3) tree node');\n        }\n        this.throwIfImmutable();\n        this._item3 = this._item2;\n        this._item2 = this._item1;\n        this._item1 = node;\n        this.handleChildrenChanged();\n    }\n    unprependChild() {\n        if (!this._item3) {\n            throw new Error('Cannot remove from a non-full (2,3) tree node');\n        }\n        this.throwIfImmutable();\n        const result = this._item1;\n        this._item1 = this._item2;\n        this._item2 = this._item3;\n        this._item3 = null;\n        this.handleChildrenChanged();\n        return result;\n    }\n    toMutable() {\n        return this;\n    }\n}\n/**\n * Immutable, if all children are immutable.\n*/\nclass Immutable23ListAstNode extends TwoThreeListAstNode {\n    toMutable() {\n        return new TwoThreeListAstNode(this.length, this.listHeight, this.item1, this.item2, this.item3, this.missingOpeningBracketIds);\n    }\n    throwIfImmutable() {\n        throw new Error('this instance is immutable');\n    }\n}\n/**\n * For debugging.\n*/\nclass ArrayListAstNode extends ListAstNode {\n    get childrenLength() {\n        return this._children.length;\n    }\n    getChild(idx) {\n        return this._children[idx];\n    }\n    setChild(idx, child) {\n        this._children[idx] = child;\n    }\n    get children() {\n        return this._children;\n    }\n    constructor(length, listHeight, _children, missingOpeningBracketIds) {\n        super(length, listHeight, missingOpeningBracketIds);\n        this._children = _children;\n    }\n    deepClone() {\n        const children = new Array(this._children.length);\n        for (let i = 0; i < this._children.length; i++) {\n            children[i] = this._children[i].deepClone();\n        }\n        return new ArrayListAstNode(this.length, this.listHeight, children, this.missingOpeningBracketIds);\n    }\n    appendChildOfSameHeight(node) {\n        this.throwIfImmutable();\n        this._children.push(node);\n        this.handleChildrenChanged();\n    }\n    unappendChild() {\n        this.throwIfImmutable();\n        const item = this._children.pop();\n        this.handleChildrenChanged();\n        return item;\n    }\n    prependChildOfSameHeight(node) {\n        this.throwIfImmutable();\n        this._children.unshift(node);\n        this.handleChildrenChanged();\n    }\n    unprependChild() {\n        this.throwIfImmutable();\n        const item = this._children.shift();\n        this.handleChildrenChanged();\n        return item;\n    }\n    toMutable() {\n        return this;\n    }\n}\n/**\n * Immutable, if all children are immutable.\n*/\nclass ImmutableArrayListAstNode extends ArrayListAstNode {\n    toMutable() {\n        return new ArrayListAstNode(this.length, this.listHeight, [...this.children], this.missingOpeningBracketIds);\n    }\n    throwIfImmutable() {\n        throw new Error('this instance is immutable');\n    }\n}\nconst emptyArray = [];\nclass ImmutableLeafAstNode extends BaseAstNode {\n    get listHeight() {\n        return 0;\n    }\n    get childrenLength() {\n        return 0;\n    }\n    getChild(idx) {\n        return null;\n    }\n    get children() {\n        return emptyArray;\n    }\n    deepClone() {\n        return this;\n    }\n}\nexport class TextAstNode extends ImmutableLeafAstNode {\n    get kind() {\n        return 0 /* AstNodeKind.Text */;\n    }\n    get missingOpeningBracketIds() {\n        return SmallImmutableSet.getEmpty();\n    }\n    canBeReused(_openedBracketIds) {\n        return true;\n    }\n    computeMinIndentation(offset, textModel) {\n        const start = lengthToObj(offset);\n        // Text ast nodes don't have partial indentation (ensured by the tokenizer).\n        // Thus, if this text node does not start at column 0, the first line cannot have any indentation at all.\n        const startLineNumber = (start.columnCount === 0 ? start.lineCount : start.lineCount + 1) + 1;\n        const endLineNumber = lengthGetLineCount(lengthAdd(offset, this.length)) + 1;\n        let result = Number.MAX_SAFE_INTEGER;\n        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n            const firstNonWsColumn = textModel.getLineFirstNonWhitespaceColumn(lineNumber);\n            const lineContent = textModel.getLineContent(lineNumber);\n            if (firstNonWsColumn === 0) {\n                continue;\n            }\n            const visibleColumn = CursorColumns.visibleColumnFromColumn(lineContent, firstNonWsColumn, textModel.getOptions().tabSize);\n            result = Math.min(result, visibleColumn);\n        }\n        return result;\n    }\n}\nexport class BracketAstNode extends ImmutableLeafAstNode {\n    static create(length, bracketInfo, bracketIds) {\n        const node = new BracketAstNode(length, bracketInfo, bracketIds);\n        return node;\n    }\n    get kind() {\n        return 1 /* AstNodeKind.Bracket */;\n    }\n    get missingOpeningBracketIds() {\n        return SmallImmutableSet.getEmpty();\n    }\n    constructor(length, bracketInfo, \n    /**\n     * In case of a opening bracket, this is the id of the opening bracket.\n     * In case of a closing bracket, this contains the ids of all opening brackets it can close.\n    */\n    bracketIds) {\n        super(length);\n        this.bracketInfo = bracketInfo;\n        this.bracketIds = bracketIds;\n    }\n    get text() {\n        return this.bracketInfo.bracketText;\n    }\n    get languageId() {\n        return this.bracketInfo.languageId;\n    }\n    canBeReused(_openedBracketIds) {\n        // These nodes could be reused,\n        // but not in a general way.\n        // Their parent may be reused.\n        return false;\n    }\n    computeMinIndentation(offset, textModel) {\n        return Number.MAX_SAFE_INTEGER;\n    }\n}\nexport class InvalidBracketAstNode extends ImmutableLeafAstNode {\n    get kind() {\n        return 3 /* AstNodeKind.UnexpectedClosingBracket */;\n    }\n    constructor(closingBrackets, length) {\n        super(length);\n        this.missingOpeningBracketIds = closingBrackets;\n    }\n    canBeReused(openedBracketIds) {\n        return !openedBracketIds.intersects(this.missingOpeningBracketIds);\n    }\n    computeMinIndentation(offset, textModel) {\n        return Number.MAX_SAFE_INTEGER;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Range } from '../../../core/range.js';\nimport { lengthAdd, lengthDiffNonNegative, lengthLessThanEqual, lengthOfString, lengthToObj, positionToLength, toLength } from './length.js';\nexport class TextEditInfo {\n    static fromModelContentChanges(changes) {\n        // Must be sorted in ascending order\n        const edits = changes.map(c => {\n            const range = Range.lift(c.range);\n            return new TextEditInfo(positionToLength(range.getStartPosition()), positionToLength(range.getEndPosition()), lengthOfString(c.text));\n        }).reverse();\n        return edits;\n    }\n    constructor(startOffset, endOffset, newLength) {\n        this.startOffset = startOffset;\n        this.endOffset = endOffset;\n        this.newLength = newLength;\n    }\n    toString() {\n        return `[${lengthToObj(this.startOffset)}...${lengthToObj(this.endOffset)}) -> ${lengthToObj(this.newLength)}`;\n    }\n}\nexport class BeforeEditPositionMapper {\n    /**\n     * @param edits Must be sorted by offset in ascending order.\n    */\n    constructor(edits) {\n        this.nextEditIdx = 0;\n        this.deltaOldToNewLineCount = 0;\n        this.deltaOldToNewColumnCount = 0;\n        this.deltaLineIdxInOld = -1;\n        this.edits = edits.map(edit => TextEditInfoCache.from(edit));\n    }\n    /**\n     * @param offset Must be equal to or greater than the last offset this method has been called with.\n    */\n    getOffsetBeforeChange(offset) {\n        this.adjustNextEdit(offset);\n        return this.translateCurToOld(offset);\n    }\n    /**\n     * @param offset Must be equal to or greater than the last offset this method has been called with.\n     * Returns null if there is no edit anymore.\n    */\n    getDistanceToNextChange(offset) {\n        this.adjustNextEdit(offset);\n        const nextEdit = this.edits[this.nextEditIdx];\n        const nextChangeOffset = nextEdit ? this.translateOldToCur(nextEdit.offsetObj) : null;\n        if (nextChangeOffset === null) {\n            return null;\n        }\n        return lengthDiffNonNegative(offset, nextChangeOffset);\n    }\n    translateOldToCur(oldOffsetObj) {\n        if (oldOffsetObj.lineCount === this.deltaLineIdxInOld) {\n            return toLength(oldOffsetObj.lineCount + this.deltaOldToNewLineCount, oldOffsetObj.columnCount + this.deltaOldToNewColumnCount);\n        }\n        else {\n            return toLength(oldOffsetObj.lineCount + this.deltaOldToNewLineCount, oldOffsetObj.columnCount);\n        }\n    }\n    translateCurToOld(newOffset) {\n        const offsetObj = lengthToObj(newOffset);\n        if (offsetObj.lineCount - this.deltaOldToNewLineCount === this.deltaLineIdxInOld) {\n            return toLength(offsetObj.lineCount - this.deltaOldToNewLineCount, offsetObj.columnCount - this.deltaOldToNewColumnCount);\n        }\n        else {\n            return toLength(offsetObj.lineCount - this.deltaOldToNewLineCount, offsetObj.columnCount);\n        }\n    }\n    adjustNextEdit(offset) {\n        while (this.nextEditIdx < this.edits.length) {\n            const nextEdit = this.edits[this.nextEditIdx];\n            // After applying the edit, what is its end offset (considering all previous edits)?\n            const nextEditEndOffsetInCur = this.translateOldToCur(nextEdit.endOffsetAfterObj);\n            if (lengthLessThanEqual(nextEditEndOffsetInCur, offset)) {\n                // We are after the edit, skip it\n                this.nextEditIdx++;\n                const nextEditEndOffsetInCurObj = lengthToObj(nextEditEndOffsetInCur);\n                // Before applying the edit, what is its end offset (considering all previous edits)?\n                const nextEditEndOffsetBeforeInCurObj = lengthToObj(this.translateOldToCur(nextEdit.endOffsetBeforeObj));\n                const lineDelta = nextEditEndOffsetInCurObj.lineCount - nextEditEndOffsetBeforeInCurObj.lineCount;\n                this.deltaOldToNewLineCount += lineDelta;\n                const previousColumnDelta = this.deltaLineIdxInOld === nextEdit.endOffsetBeforeObj.lineCount ? this.deltaOldToNewColumnCount : 0;\n                const columnDelta = nextEditEndOffsetInCurObj.columnCount - nextEditEndOffsetBeforeInCurObj.columnCount;\n                this.deltaOldToNewColumnCount = previousColumnDelta + columnDelta;\n                this.deltaLineIdxInOld = nextEdit.endOffsetBeforeObj.lineCount;\n            }\n            else {\n                // We are in or before the edit.\n                break;\n            }\n        }\n    }\n}\nclass TextEditInfoCache {\n    static from(edit) {\n        return new TextEditInfoCache(edit.startOffset, edit.endOffset, edit.newLength);\n    }\n    constructor(startOffset, endOffset, textLength) {\n        this.endOffsetBeforeObj = lengthToObj(endOffset);\n        this.endOffsetAfterObj = lengthToObj(lengthAdd(startOffset, textLength));\n        this.offsetObj = lengthToObj(startOffset);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { escapeRegExpCharacters } from '../../../../../base/common/strings.js';\nimport { BracketAstNode } from './ast.js';\nimport { toLength } from './length.js';\nimport { identityKeyProvider, SmallImmutableSet } from './smallImmutableSet.js';\nimport { Token } from './tokenizer.js';\nexport class BracketTokens {\n    static createFromLanguage(configuration, denseKeyProvider) {\n        function getId(bracketInfo) {\n            return denseKeyProvider.getKey(`${bracketInfo.languageId}:::${bracketInfo.bracketText}`);\n        }\n        const map = new Map();\n        for (const openingBracket of configuration.bracketsNew.openingBrackets) {\n            const length = toLength(0, openingBracket.bracketText.length);\n            const openingTextId = getId(openingBracket);\n            const bracketIds = SmallImmutableSet.getEmpty().add(openingTextId, identityKeyProvider);\n            map.set(openingBracket.bracketText, new Token(length, 1 /* TokenKind.OpeningBracket */, openingTextId, bracketIds, BracketAstNode.create(length, openingBracket, bracketIds)));\n        }\n        for (const closingBracket of configuration.bracketsNew.closingBrackets) {\n            const length = toLength(0, closingBracket.bracketText.length);\n            let bracketIds = SmallImmutableSet.getEmpty();\n            const closingBrackets = closingBracket.getOpeningBrackets();\n            for (const bracket of closingBrackets) {\n                bracketIds = bracketIds.add(getId(bracket), identityKeyProvider);\n            }\n            map.set(closingBracket.bracketText, new Token(length, 2 /* TokenKind.ClosingBracket */, getId(closingBrackets[0]), bracketIds, BracketAstNode.create(length, closingBracket, bracketIds)));\n        }\n        return new BracketTokens(map);\n    }\n    constructor(map) {\n        this.map = map;\n        this.hasRegExp = false;\n        this._regExpGlobal = null;\n    }\n    getRegExpStr() {\n        if (this.isEmpty) {\n            return null;\n        }\n        else {\n            const keys = [...this.map.keys()];\n            keys.sort();\n            keys.reverse();\n            return keys.map(k => prepareBracketForRegExp(k)).join('|');\n        }\n    }\n    /**\n     * Returns null if there is no such regexp (because there are no brackets).\n    */\n    get regExpGlobal() {\n        if (!this.hasRegExp) {\n            const regExpStr = this.getRegExpStr();\n            this._regExpGlobal = regExpStr ? new RegExp(regExpStr, 'gi') : null;\n            this.hasRegExp = true;\n        }\n        return this._regExpGlobal;\n    }\n    getToken(value) {\n        return this.map.get(value.toLowerCase());\n    }\n    findClosingTokenText(openingBracketIds) {\n        for (const [closingText, info] of this.map) {\n            if (info.kind === 2 /* TokenKind.ClosingBracket */ && info.bracketIds.intersects(openingBracketIds)) {\n                return closingText;\n            }\n        }\n        return undefined;\n    }\n    get isEmpty() {\n        return this.map.size === 0;\n    }\n}\nfunction prepareBracketForRegExp(str) {\n    let escaped = escapeRegExpCharacters(str);\n    // These bracket pair delimiters start or end with letters\n    // see https://github.com/microsoft/vscode/issues/132162 https://github.com/microsoft/vscode/issues/150440\n    if (/^[\\w ]+/.test(str)) {\n        escaped = `\\\\b${escaped}`;\n    }\n    if (/[\\w ]+$/.test(str)) {\n        escaped = `${escaped}\\\\b`;\n    }\n    return escaped;\n}\nexport class LanguageAgnosticBracketTokens {\n    constructor(denseKeyProvider, getLanguageConfiguration) {\n        this.denseKeyProvider = denseKeyProvider;\n        this.getLanguageConfiguration = getLanguageConfiguration;\n        this.languageIdToBracketTokens = new Map();\n    }\n    didLanguageChange(languageId) {\n        // Report a change whenever the language configuration updates.\n        return this.languageIdToBracketTokens.has(languageId);\n    }\n    getSingleLanguageBracketTokens(languageId) {\n        let singleLanguageBracketTokens = this.languageIdToBracketTokens.get(languageId);\n        if (!singleLanguageBracketTokens) {\n            singleLanguageBracketTokens = BracketTokens.createFromLanguage(this.getLanguageConfiguration(languageId), this.denseKeyProvider);\n            this.languageIdToBracketTokens.set(languageId, singleLanguageBracketTokens);\n        }\n        return singleLanguageBracketTokens;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { ArrayQueue } from '../../../../../base/common/arrays.js';\nimport { TextEditInfo } from './beforeEditPositionMapper.js';\nimport { lengthAdd, lengthDiffNonNegative, lengthEquals, lengthIsZero, lengthToObj, lengthZero, sumLengths } from './length.js';\nexport function combineTextEditInfos(textEditInfoFirst, textEditInfoSecond) {\n    if (textEditInfoFirst.length === 0) {\n        return textEditInfoSecond;\n    }\n    if (textEditInfoSecond.length === 0) {\n        return textEditInfoFirst;\n    }\n    // s0: State before any edits\n    const s0ToS1Map = new ArrayQueue(toLengthMapping(textEditInfoFirst));\n    // s1: State after first edit, but before second edit\n    const s1ToS2Map = toLengthMapping(textEditInfoSecond);\n    s1ToS2Map.push({ modified: false, lengthBefore: undefined, lengthAfter: undefined }); // Copy everything from old to new\n    // s2: State after both edits\n    let curItem = s0ToS1Map.dequeue();\n    /**\n     * @param s1Length Use undefined for length \"infinity\"\n     */\n    function nextS0ToS1MapWithS1LengthOf(s1Length) {\n        if (s1Length === undefined) {\n            const arr = s0ToS1Map.takeWhile(v => true) || [];\n            if (curItem) {\n                arr.unshift(curItem);\n            }\n            return arr;\n        }\n        const result = [];\n        while (curItem && !lengthIsZero(s1Length)) {\n            const [item, remainingItem] = curItem.splitAt(s1Length);\n            result.push(item);\n            s1Length = lengthDiffNonNegative(item.lengthAfter, s1Length);\n            curItem = remainingItem ?? s0ToS1Map.dequeue();\n        }\n        if (!lengthIsZero(s1Length)) {\n            result.push(new LengthMapping(false, s1Length, s1Length));\n        }\n        return result;\n    }\n    const result = [];\n    function pushEdit(startOffset, endOffset, newLength) {\n        if (result.length > 0 && lengthEquals(result[result.length - 1].endOffset, startOffset)) {\n            const lastResult = result[result.length - 1];\n            result[result.length - 1] = new TextEditInfo(lastResult.startOffset, endOffset, lengthAdd(lastResult.newLength, newLength));\n        }\n        else {\n            result.push({ startOffset, endOffset, newLength });\n        }\n    }\n    let s0offset = lengthZero;\n    for (const s1ToS2 of s1ToS2Map) {\n        const s0ToS1Map = nextS0ToS1MapWithS1LengthOf(s1ToS2.lengthBefore);\n        if (s1ToS2.modified) {\n            const s0Length = sumLengths(s0ToS1Map, s => s.lengthBefore);\n            const s0EndOffset = lengthAdd(s0offset, s0Length);\n            pushEdit(s0offset, s0EndOffset, s1ToS2.lengthAfter);\n            s0offset = s0EndOffset;\n        }\n        else {\n            for (const s1 of s0ToS1Map) {\n                const s0startOffset = s0offset;\n                s0offset = lengthAdd(s0offset, s1.lengthBefore);\n                if (s1.modified) {\n                    pushEdit(s0startOffset, s0offset, s1.lengthAfter);\n                }\n            }\n        }\n    }\n    return result;\n}\nclass LengthMapping {\n    constructor(\n    /**\n     * If false, length before and length after equal.\n     */\n    modified, lengthBefore, lengthAfter) {\n        this.modified = modified;\n        this.lengthBefore = lengthBefore;\n        this.lengthAfter = lengthAfter;\n    }\n    splitAt(lengthAfter) {\n        const remainingLengthAfter = lengthDiffNonNegative(lengthAfter, this.lengthAfter);\n        if (lengthEquals(remainingLengthAfter, lengthZero)) {\n            return [this, undefined];\n        }\n        else if (this.modified) {\n            return [\n                new LengthMapping(this.modified, this.lengthBefore, lengthAfter),\n                new LengthMapping(this.modified, lengthZero, remainingLengthAfter)\n            ];\n        }\n        else {\n            return [\n                new LengthMapping(this.modified, lengthAfter, lengthAfter),\n                new LengthMapping(this.modified, remainingLengthAfter, remainingLengthAfter)\n            ];\n        }\n    }\n    toString() {\n        return `${this.modified ? 'M' : 'U'}:${lengthToObj(this.lengthBefore)} -> ${lengthToObj(this.lengthAfter)}`;\n    }\n}\nfunction toLengthMapping(textEditInfos) {\n    const result = [];\n    let lastOffset = lengthZero;\n    for (const textEditInfo of textEditInfos) {\n        const spaceLength = lengthDiffNonNegative(lastOffset, textEditInfo.startOffset);\n        if (!lengthIsZero(spaceLength)) {\n            result.push(new LengthMapping(false, spaceLength, spaceLength));\n        }\n        const lengthBefore = lengthDiffNonNegative(textEditInfo.startOffset, textEditInfo.endOffset);\n        result.push(new LengthMapping(true, lengthBefore, textEditInfo.newLength));\n        lastOffset = textEditInfo.endOffset;\n    }\n    return result;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { splitLines } from '../../../../../base/common/strings.js';\nimport { Range } from '../../../core/range.js';\nimport { TextLength } from '../../../core/textLength.js';\n/**\n * The end must be greater than or equal to the start.\n*/\nexport function lengthDiff(startLineCount, startColumnCount, endLineCount, endColumnCount) {\n    return (startLineCount !== endLineCount)\n        ? toLength(endLineCount - startLineCount, endColumnCount)\n        : toLength(0, endColumnCount - startColumnCount);\n}\nexport const lengthZero = 0;\nexport function lengthIsZero(length) {\n    return length === 0;\n}\n/*\n * We have 52 bits available in a JS number.\n * We use the upper 26 bits to store the line and the lower 26 bits to store the column.\n */\n///*\nconst factor = 2 ** 26;\n/*/\nconst factor = 1000000;\n// */\nexport function toLength(lineCount, columnCount) {\n    // llllllllllllllllllllllllllcccccccccccccccccccccccccc (52 bits)\n    //       line count (26 bits)    column count (26 bits)\n    // If there is no overflow (all values/sums below 2^26 = 67108864),\n    // we have `toLength(lns1, cols1) + toLength(lns2, cols2) = toLength(lns1 + lns2, cols1 + cols2)`.\n    return (lineCount * factor + columnCount);\n}\nexport function lengthToObj(length) {\n    const l = length;\n    const lineCount = Math.floor(l / factor);\n    const columnCount = l - lineCount * factor;\n    return new TextLength(lineCount, columnCount);\n}\nexport function lengthGetLineCount(length) {\n    return Math.floor(length / factor);\n}\n/**\n * Returns the amount of columns of the given length, assuming that it does not span any line.\n*/\nexport function lengthGetColumnCountIfZeroLineCount(length) {\n    return length;\n}\nexport function lengthAdd(l1, l2) {\n    let r = l1 + l2;\n    if (l2 >= factor) {\n        r = r - (l1 % factor);\n    }\n    return r;\n}\nexport function sumLengths(items, lengthFn) {\n    return items.reduce((a, b) => lengthAdd(a, lengthFn(b)), lengthZero);\n}\nexport function lengthEquals(length1, length2) {\n    return length1 === length2;\n}\n/**\n * Returns a non negative length `result` such that `lengthAdd(length1, result) = length2`, or zero if such length does not exist.\n */\nexport function lengthDiffNonNegative(length1, length2) {\n    const l1 = length1;\n    const l2 = length2;\n    const diff = l2 - l1;\n    if (diff <= 0) {\n        // line-count of length1 is higher than line-count of length2\n        // or they are equal and column-count of length1 is higher than column-count of length2\n        return lengthZero;\n    }\n    const lineCount1 = Math.floor(l1 / factor);\n    const lineCount2 = Math.floor(l2 / factor);\n    const colCount2 = l2 - lineCount2 * factor;\n    if (lineCount1 === lineCount2) {\n        const colCount1 = l1 - lineCount1 * factor;\n        return toLength(0, colCount2 - colCount1);\n    }\n    else {\n        return toLength(lineCount2 - lineCount1, colCount2);\n    }\n}\nexport function lengthLessThan(length1, length2) {\n    // First, compare line counts, then column counts.\n    return length1 < length2;\n}\nexport function lengthLessThanEqual(length1, length2) {\n    return length1 <= length2;\n}\nexport function lengthGreaterThanEqual(length1, length2) {\n    return length1 >= length2;\n}\nexport function positionToLength(position) {\n    return toLength(position.lineNumber - 1, position.column - 1);\n}\nexport function lengthsToRange(lengthStart, lengthEnd) {\n    const l = lengthStart;\n    const lineCount = Math.floor(l / factor);\n    const colCount = l - lineCount * factor;\n    const l2 = lengthEnd;\n    const lineCount2 = Math.floor(l2 / factor);\n    const colCount2 = l2 - lineCount2 * factor;\n    return new Range(lineCount + 1, colCount + 1, lineCount2 + 1, colCount2 + 1);\n}\nexport function lengthOfString(str) {\n    const lines = splitLines(str);\n    return toLength(lines.length - 1, lines[lines.length - 1].length);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { ListAstNode } from './ast.js';\n/**\n * Concatenates a list of (2,3) AstNode's into a single (2,3) AstNode.\n * This mutates the items of the input array!\n * If all items have the same height, this method has runtime O(items.length).\n * Otherwise, it has runtime O(items.length * max(log(items.length), items.max(i => i.height))).\n*/\nexport function concat23Trees(items) {\n    if (items.length === 0) {\n        return null;\n    }\n    if (items.length === 1) {\n        return items[0];\n    }\n    let i = 0;\n    /**\n     * Reads nodes of same height and concatenates them to a single node.\n    */\n    function readNode() {\n        if (i >= items.length) {\n            return null;\n        }\n        const start = i;\n        const height = items[start].listHeight;\n        i++;\n        while (i < items.length && items[i].listHeight === height) {\n            i++;\n        }\n        if (i - start >= 2) {\n            return concat23TreesOfSameHeight(start === 0 && i === items.length ? items : items.slice(start, i), false);\n        }\n        else {\n            return items[start];\n        }\n    }\n    // The items might not have the same height.\n    // We merge all items by using a binary concat operator.\n    let first = readNode(); // There must be a first item\n    let second = readNode();\n    if (!second) {\n        return first;\n    }\n    for (let item = readNode(); item; item = readNode()) {\n        // Prefer concatenating smaller trees, as the runtime of concat depends on the tree height.\n        if (heightDiff(first, second) <= heightDiff(second, item)) {\n            first = concat(first, second);\n            second = item;\n        }\n        else {\n            second = concat(second, item);\n        }\n    }\n    const result = concat(first, second);\n    return result;\n}\nexport function concat23TreesOfSameHeight(items, createImmutableLists = false) {\n    if (items.length === 0) {\n        return null;\n    }\n    if (items.length === 1) {\n        return items[0];\n    }\n    let length = items.length;\n    // All trees have same height, just create parent nodes.\n    while (length > 3) {\n        const newLength = length >> 1;\n        for (let i = 0; i < newLength; i++) {\n            const j = i << 1;\n            items[i] = ListAstNode.create23(items[j], items[j + 1], j + 3 === length ? items[j + 2] : null, createImmutableLists);\n        }\n        length = newLength;\n    }\n    return ListAstNode.create23(items[0], items[1], length >= 3 ? items[2] : null, createImmutableLists);\n}\nfunction heightDiff(node1, node2) {\n    return Math.abs(node1.listHeight - node2.listHeight);\n}\nfunction concat(node1, node2) {\n    if (node1.listHeight === node2.listHeight) {\n        return ListAstNode.create23(node1, node2, null, false);\n    }\n    else if (node1.listHeight > node2.listHeight) {\n        // node1 is the tree we want to insert into\n        return append(node1, node2);\n    }\n    else {\n        return prepend(node2, node1);\n    }\n}\n/**\n * Appends the given node to the end of this (2,3) tree.\n * Returns the new root.\n*/\nfunction append(list, nodeToAppend) {\n    list = list.toMutable();\n    let curNode = list;\n    const parents = [];\n    let nodeToAppendOfCorrectHeight;\n    while (true) {\n        // assert nodeToInsert.listHeight <= curNode.listHeight\n        if (nodeToAppend.listHeight === curNode.listHeight) {\n            nodeToAppendOfCorrectHeight = nodeToAppend;\n            break;\n        }\n        // assert 0 <= nodeToInsert.listHeight < curNode.listHeight\n        if (curNode.kind !== 4 /* AstNodeKind.List */) {\n            throw new Error('unexpected');\n        }\n        parents.push(curNode);\n        // assert 2 <= curNode.childrenLength <= 3\n        curNode = curNode.makeLastElementMutable();\n    }\n    // assert nodeToAppendOfCorrectHeight!.listHeight === curNode.listHeight\n    for (let i = parents.length - 1; i >= 0; i--) {\n        const parent = parents[i];\n        if (nodeToAppendOfCorrectHeight) {\n            // Can we take the element?\n            if (parent.childrenLength >= 3) {\n                // assert parent.childrenLength === 3 && parent.listHeight === nodeToAppendOfCorrectHeight.listHeight + 1\n                // we need to split to maintain (2,3)-tree property.\n                // Send the third element + the new element to the parent.\n                nodeToAppendOfCorrectHeight = ListAstNode.create23(parent.unappendChild(), nodeToAppendOfCorrectHeight, null, false);\n            }\n            else {\n                parent.appendChildOfSameHeight(nodeToAppendOfCorrectHeight);\n                nodeToAppendOfCorrectHeight = undefined;\n            }\n        }\n        else {\n            parent.handleChildrenChanged();\n        }\n    }\n    if (nodeToAppendOfCorrectHeight) {\n        return ListAstNode.create23(list, nodeToAppendOfCorrectHeight, null, false);\n    }\n    else {\n        return list;\n    }\n}\n/**\n * Prepends the given node to the end of this (2,3) tree.\n * Returns the new root.\n*/\nfunction prepend(list, nodeToAppend) {\n    list = list.toMutable();\n    let curNode = list;\n    const parents = [];\n    // assert nodeToInsert.listHeight <= curNode.listHeight\n    while (nodeToAppend.listHeight !== curNode.listHeight) {\n        // assert 0 <= nodeToInsert.listHeight < curNode.listHeight\n        if (curNode.kind !== 4 /* AstNodeKind.List */) {\n            throw new Error('unexpected');\n        }\n        parents.push(curNode);\n        // assert 2 <= curNode.childrenFast.length <= 3\n        curNode = curNode.makeFirstElementMutable();\n    }\n    let nodeToPrependOfCorrectHeight = nodeToAppend;\n    // assert nodeToAppendOfCorrectHeight!.listHeight === curNode.listHeight\n    for (let i = parents.length - 1; i >= 0; i--) {\n        const parent = parents[i];\n        if (nodeToPrependOfCorrectHeight) {\n            // Can we take the element?\n            if (parent.childrenLength >= 3) {\n                // assert parent.childrenLength === 3 && parent.listHeight === nodeToAppendOfCorrectHeight.listHeight + 1\n                // we need to split to maintain (2,3)-tree property.\n                // Send the third element + the new element to the parent.\n                nodeToPrependOfCorrectHeight = ListAstNode.create23(nodeToPrependOfCorrectHeight, parent.unprependChild(), null, false);\n            }\n            else {\n                parent.prependChildOfSameHeight(nodeToPrependOfCorrectHeight);\n                nodeToPrependOfCorrectHeight = undefined;\n            }\n        }\n        else {\n            parent.handleChildrenChanged();\n        }\n    }\n    if (nodeToPrependOfCorrectHeight) {\n        return ListAstNode.create23(nodeToPrependOfCorrectHeight, list, null, false);\n    }\n    else {\n        return list;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { lengthAdd, lengthZero, lengthLessThan } from './length.js';\n/**\n * Allows to efficiently find a longest child at a given offset in a fixed node.\n * The requested offsets must increase monotonously.\n*/\nexport class NodeReader {\n    constructor(node) {\n        this.lastOffset = lengthZero;\n        this.nextNodes = [node];\n        this.offsets = [lengthZero];\n        this.idxs = [];\n    }\n    /**\n     * Returns the longest node at `offset` that satisfies the predicate.\n     * @param offset must be greater than or equal to the last offset this method has been called with!\n    */\n    readLongestNodeAt(offset, predicate) {\n        if (lengthLessThan(offset, this.lastOffset)) {\n            throw new Error('Invalid offset');\n        }\n        this.lastOffset = offset;\n        // Find the longest node of all those that are closest to the current offset.\n        while (true) {\n            const curNode = lastOrUndefined(this.nextNodes);\n            if (!curNode) {\n                return undefined;\n            }\n            const curNodeOffset = lastOrUndefined(this.offsets);\n            if (lengthLessThan(offset, curNodeOffset)) {\n                // The next best node is not here yet.\n                // The reader must advance before a cached node is hit.\n                return undefined;\n            }\n            if (lengthLessThan(curNodeOffset, offset)) {\n                // The reader is ahead of the current node.\n                if (lengthAdd(curNodeOffset, curNode.length) <= offset) {\n                    // The reader is after the end of the current node.\n                    this.nextNodeAfterCurrent();\n                }\n                else {\n                    // The reader is somewhere in the current node.\n                    const nextChildIdx = getNextChildIdx(curNode);\n                    if (nextChildIdx !== -1) {\n                        // Go to the first child and repeat.\n                        this.nextNodes.push(curNode.getChild(nextChildIdx));\n                        this.offsets.push(curNodeOffset);\n                        this.idxs.push(nextChildIdx);\n                    }\n                    else {\n                        // We don't have children\n                        this.nextNodeAfterCurrent();\n                    }\n                }\n            }\n            else {\n                // readerOffsetBeforeChange === curNodeOffset\n                if (predicate(curNode)) {\n                    this.nextNodeAfterCurrent();\n                    return curNode;\n                }\n                else {\n                    const nextChildIdx = getNextChildIdx(curNode);\n                    // look for shorter node\n                    if (nextChildIdx === -1) {\n                        // There is no shorter node.\n                        this.nextNodeAfterCurrent();\n                        return undefined;\n                    }\n                    else {\n                        // Descend into first child & repeat.\n                        this.nextNodes.push(curNode.getChild(nextChildIdx));\n                        this.offsets.push(curNodeOffset);\n                        this.idxs.push(nextChildIdx);\n                    }\n                }\n            }\n        }\n    }\n    // Navigates to the longest node that continues after the current node.\n    nextNodeAfterCurrent() {\n        while (true) {\n            const currentOffset = lastOrUndefined(this.offsets);\n            const currentNode = lastOrUndefined(this.nextNodes);\n            this.nextNodes.pop();\n            this.offsets.pop();\n            if (this.idxs.length === 0) {\n                // We just popped the root node, there is no next node.\n                break;\n            }\n            // Parent is not undefined, because idxs is not empty\n            const parent = lastOrUndefined(this.nextNodes);\n            const nextChildIdx = getNextChildIdx(parent, this.idxs[this.idxs.length - 1]);\n            if (nextChildIdx !== -1) {\n                this.nextNodes.push(parent.getChild(nextChildIdx));\n                this.offsets.push(lengthAdd(currentOffset, currentNode.length));\n                this.idxs[this.idxs.length - 1] = nextChildIdx;\n                break;\n            }\n            else {\n                this.idxs.pop();\n            }\n            // We fully consumed the parent.\n            // Current node is now parent, so call nextNodeAfterCurrent again\n        }\n    }\n}\nfunction getNextChildIdx(node, curIdx = -1) {\n    while (true) {\n        curIdx++;\n        if (curIdx >= node.childrenLength) {\n            return -1;\n        }\n        if (node.getChild(curIdx)) {\n            return curIdx;\n        }\n    }\n}\nfunction lastOrUndefined(arr) {\n    return arr.length > 0 ? arr[arr.length - 1] : undefined;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { InvalidBracketAstNode, ListAstNode, PairAstNode, TextAstNode } from './ast.js';\nimport { BeforeEditPositionMapper } from './beforeEditPositionMapper.js';\nimport { SmallImmutableSet } from './smallImmutableSet.js';\nimport { lengthIsZero, lengthLessThan } from './length.js';\nimport { concat23Trees, concat23TreesOfSameHeight } from './concat23Trees.js';\nimport { NodeReader } from './nodeReader.js';\n/**\n * Non incrementally built ASTs are immutable.\n*/\nexport function parseDocument(tokenizer, edits, oldNode, createImmutableLists) {\n    const parser = new Parser(tokenizer, edits, oldNode, createImmutableLists);\n    return parser.parseDocument();\n}\n/**\n * Non incrementally built ASTs are immutable.\n*/\nclass Parser {\n    constructor(tokenizer, edits, oldNode, createImmutableLists) {\n        this.tokenizer = tokenizer;\n        this.createImmutableLists = createImmutableLists;\n        this._itemsConstructed = 0;\n        this._itemsFromCache = 0;\n        if (oldNode && createImmutableLists) {\n            throw new Error('Not supported');\n        }\n        this.oldNodeReader = oldNode ? new NodeReader(oldNode) : undefined;\n        this.positionMapper = new BeforeEditPositionMapper(edits);\n    }\n    parseDocument() {\n        this._itemsConstructed = 0;\n        this._itemsFromCache = 0;\n        let result = this.parseList(SmallImmutableSet.getEmpty(), 0);\n        if (!result) {\n            result = ListAstNode.getEmpty();\n        }\n        return result;\n    }\n    parseList(openedBracketIds, level) {\n        const items = [];\n        while (true) {\n            let child = this.tryReadChildFromCache(openedBracketIds);\n            if (!child) {\n                const token = this.tokenizer.peek();\n                if (!token ||\n                    (token.kind === 2 /* TokenKind.ClosingBracket */ &&\n                        token.bracketIds.intersects(openedBracketIds))) {\n                    break;\n                }\n                child = this.parseChild(openedBracketIds, level + 1);\n            }\n            if (child.kind === 4 /* AstNodeKind.List */ && child.childrenLength === 0) {\n                continue;\n            }\n            items.push(child);\n        }\n        // When there is no oldNodeReader, all items are created from scratch and must have the same height.\n        const result = this.oldNodeReader ? concat23Trees(items) : concat23TreesOfSameHeight(items, this.createImmutableLists);\n        return result;\n    }\n    tryReadChildFromCache(openedBracketIds) {\n        if (this.oldNodeReader) {\n            const maxCacheableLength = this.positionMapper.getDistanceToNextChange(this.tokenizer.offset);\n            if (maxCacheableLength === null || !lengthIsZero(maxCacheableLength)) {\n                const cachedNode = this.oldNodeReader.readLongestNodeAt(this.positionMapper.getOffsetBeforeChange(this.tokenizer.offset), curNode => {\n                    // The edit could extend the ending token, thus we cannot re-use nodes that touch the edit.\n                    // If there is no edit anymore, we can re-use the node in any case.\n                    if (maxCacheableLength !== null && !lengthLessThan(curNode.length, maxCacheableLength)) {\n                        // Either the node contains edited text or touches edited text.\n                        // In the latter case, brackets might have been extended (`end` -> `ending`), so even touching nodes cannot be reused.\n                        return false;\n                    }\n                    const canBeReused = curNode.canBeReused(openedBracketIds);\n                    return canBeReused;\n                });\n                if (cachedNode) {\n                    this._itemsFromCache++;\n                    this.tokenizer.skip(cachedNode.length);\n                    return cachedNode;\n                }\n            }\n        }\n        return undefined;\n    }\n    parseChild(openedBracketIds, level) {\n        this._itemsConstructed++;\n        const token = this.tokenizer.read();\n        switch (token.kind) {\n            case 2 /* TokenKind.ClosingBracket */:\n                return new InvalidBracketAstNode(token.bracketIds, token.length);\n            case 0 /* TokenKind.Text */:\n                return token.astNode;\n            case 1 /* TokenKind.OpeningBracket */: {\n                if (level > 300) {\n                    // To prevent stack overflows\n                    return new TextAstNode(token.length);\n                }\n                const set = openedBracketIds.merge(token.bracketIds);\n                const child = this.parseList(set, level + 1);\n                const nextToken = this.tokenizer.peek();\n                if (nextToken &&\n                    nextToken.kind === 2 /* TokenKind.ClosingBracket */ &&\n                    (nextToken.bracketId === token.bracketId || nextToken.bracketIds.intersects(token.bracketIds))) {\n                    this.tokenizer.read();\n                    return PairAstNode.create(token.astNode, child, nextToken.astNode);\n                }\n                else {\n                    return PairAstNode.create(token.astNode, child, null);\n                }\n            }\n            default:\n                throw new Error('unexpected');\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nconst emptyArr = [];\n/**\n * Represents an immutable set that works best for a small number of elements (less than 32).\n * It uses bits to encode element membership efficiently.\n*/\nexport class SmallImmutableSet {\n    static { this.cache = new Array(129); }\n    static create(items, additionalItems) {\n        if (items <= 128 && additionalItems.length === 0) {\n            // We create a cache of 128=2^7 elements to cover all sets with up to 7 (dense) elements.\n            let cached = SmallImmutableSet.cache[items];\n            if (!cached) {\n                cached = new SmallImmutableSet(items, additionalItems);\n                SmallImmutableSet.cache[items] = cached;\n            }\n            return cached;\n        }\n        return new SmallImmutableSet(items, additionalItems);\n    }\n    static { this.empty = SmallImmutableSet.create(0, emptyArr); }\n    static getEmpty() {\n        return this.empty;\n    }\n    constructor(items, additionalItems) {\n        this.items = items;\n        this.additionalItems = additionalItems;\n    }\n    add(value, keyProvider) {\n        const key = keyProvider.getKey(value);\n        let idx = key >> 5; // divided by 32\n        if (idx === 0) {\n            // fast path\n            const newItem = (1 << key) | this.items;\n            if (newItem === this.items) {\n                return this;\n            }\n            return SmallImmutableSet.create(newItem, this.additionalItems);\n        }\n        idx--;\n        const newItems = this.additionalItems.slice(0);\n        while (newItems.length < idx) {\n            newItems.push(0);\n        }\n        newItems[idx] |= 1 << (key & 31);\n        return SmallImmutableSet.create(this.items, newItems);\n    }\n    merge(other) {\n        const merged = this.items | other.items;\n        if (this.additionalItems === emptyArr && other.additionalItems === emptyArr) {\n            // fast path\n            if (merged === this.items) {\n                return this;\n            }\n            if (merged === other.items) {\n                return other;\n            }\n            return SmallImmutableSet.create(merged, emptyArr);\n        }\n        // This can be optimized, but it's not a common case\n        const newItems = [];\n        for (let i = 0; i < Math.max(this.additionalItems.length, other.additionalItems.length); i++) {\n            const item1 = this.additionalItems[i] || 0;\n            const item2 = other.additionalItems[i] || 0;\n            newItems.push(item1 | item2);\n        }\n        return SmallImmutableSet.create(merged, newItems);\n    }\n    intersects(other) {\n        if ((this.items & other.items) !== 0) {\n            return true;\n        }\n        for (let i = 0; i < Math.min(this.additionalItems.length, other.additionalItems.length); i++) {\n            if ((this.additionalItems[i] & other.additionalItems[i]) !== 0) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\nexport const identityKeyProvider = {\n    getKey(value) {\n        return value;\n    }\n};\n/**\n * Assigns values a unique incrementing key.\n*/\nexport class DenseKeyProvider {\n    constructor() {\n        this.items = new Map();\n    }\n    getKey(value) {\n        let existing = this.items.get(value);\n        if (existing === undefined) {\n            existing = this.items.size;\n            this.items.set(value, existing);\n        }\n        return existing;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { NotSupportedError } from '../../../../../base/common/errors.js';\nimport { TokenMetadata } from '../../../encodedTokenAttributes.js';\nimport { TextAstNode } from './ast.js';\nimport { lengthAdd, lengthDiff, lengthGetColumnCountIfZeroLineCount, lengthToObj, lengthZero, toLength } from './length.js';\nimport { SmallImmutableSet } from './smallImmutableSet.js';\nexport class Token {\n    constructor(length, kind, \n    /**\n     * If this token is an opening bracket, this is the id of the opening bracket.\n     * If this token is a closing bracket, this is the id of the first opening bracket that is closed by this bracket.\n     * Otherwise, it is -1.\n     */\n    bracketId, \n    /**\n     * If this token is an opening bracket, this just contains `bracketId`.\n     * If this token is a closing bracket, this lists all opening bracket ids, that it closes.\n     * Otherwise, it is empty.\n     */\n    bracketIds, astNode) {\n        this.length = length;\n        this.kind = kind;\n        this.bracketId = bracketId;\n        this.bracketIds = bracketIds;\n        this.astNode = astNode;\n    }\n}\nexport class TextBufferTokenizer {\n    constructor(textModel, bracketTokens) {\n        this.textModel = textModel;\n        this.bracketTokens = bracketTokens;\n        this.reader = new NonPeekableTextBufferTokenizer(this.textModel, this.bracketTokens);\n        this._offset = lengthZero;\n        this.didPeek = false;\n        this.peeked = null;\n        this.textBufferLineCount = textModel.getLineCount();\n        this.textBufferLastLineLength = textModel.getLineLength(this.textBufferLineCount);\n    }\n    get offset() {\n        return this._offset;\n    }\n    get length() {\n        return toLength(this.textBufferLineCount - 1, this.textBufferLastLineLength);\n    }\n    skip(length) {\n        this.didPeek = false;\n        this._offset = lengthAdd(this._offset, length);\n        const obj = lengthToObj(this._offset);\n        this.reader.setPosition(obj.lineCount, obj.columnCount);\n    }\n    read() {\n        let token;\n        if (this.peeked) {\n            this.didPeek = false;\n            token = this.peeked;\n        }\n        else {\n            token = this.reader.read();\n        }\n        if (token) {\n            this._offset = lengthAdd(this._offset, token.length);\n        }\n        return token;\n    }\n    peek() {\n        if (!this.didPeek) {\n            this.peeked = this.reader.read();\n            this.didPeek = true;\n        }\n        return this.peeked;\n    }\n}\n/**\n * Does not support peek.\n*/\nclass NonPeekableTextBufferTokenizer {\n    constructor(textModel, bracketTokens) {\n        this.textModel = textModel;\n        this.bracketTokens = bracketTokens;\n        this.lineIdx = 0;\n        this.line = null;\n        this.lineCharOffset = 0;\n        this.lineTokens = null;\n        this.lineTokenOffset = 0;\n        /** Must be a zero line token. The end of the document cannot be peeked. */\n        this.peekedToken = null;\n        this.textBufferLineCount = textModel.getLineCount();\n        this.textBufferLastLineLength = textModel.getLineLength(this.textBufferLineCount);\n    }\n    setPosition(lineIdx, column) {\n        // We must not jump into a token!\n        if (lineIdx === this.lineIdx) {\n            this.lineCharOffset = column;\n            if (this.line !== null) {\n                this.lineTokenOffset = this.lineCharOffset === 0 ? 0 : this.lineTokens.findTokenIndexAtOffset(this.lineCharOffset);\n            }\n        }\n        else {\n            this.lineIdx = lineIdx;\n            this.lineCharOffset = column;\n            this.line = null;\n        }\n        this.peekedToken = null;\n    }\n    read() {\n        if (this.peekedToken) {\n            const token = this.peekedToken;\n            this.peekedToken = null;\n            this.lineCharOffset += lengthGetColumnCountIfZeroLineCount(token.length);\n            return token;\n        }\n        if (this.lineIdx > this.textBufferLineCount - 1 || (this.lineIdx === this.textBufferLineCount - 1 && this.lineCharOffset >= this.textBufferLastLineLength)) {\n            // We are after the end\n            return null;\n        }\n        if (this.line === null) {\n            this.lineTokens = this.textModel.tokenization.getLineTokens(this.lineIdx + 1);\n            this.line = this.lineTokens.getLineContent();\n            this.lineTokenOffset = this.lineCharOffset === 0 ? 0 : this.lineTokens.findTokenIndexAtOffset(this.lineCharOffset);\n        }\n        const startLineIdx = this.lineIdx;\n        const startLineCharOffset = this.lineCharOffset;\n        // limits the length of text tokens.\n        // If text tokens get too long, incremental updates will be slow\n        let lengthHeuristic = 0;\n        while (true) {\n            const lineTokens = this.lineTokens;\n            const tokenCount = lineTokens.getCount();\n            let peekedBracketToken = null;\n            if (this.lineTokenOffset < tokenCount) {\n                const tokenMetadata = lineTokens.getMetadata(this.lineTokenOffset);\n                while (this.lineTokenOffset + 1 < tokenCount && tokenMetadata === lineTokens.getMetadata(this.lineTokenOffset + 1)) {\n                    // Skip tokens that are identical.\n                    // Sometimes, (bracket) identifiers are split up into multiple tokens.\n                    this.lineTokenOffset++;\n                }\n                const isOther = TokenMetadata.getTokenType(tokenMetadata) === 0 /* StandardTokenType.Other */;\n                const containsBracketType = TokenMetadata.containsBalancedBrackets(tokenMetadata);\n                const endOffset = lineTokens.getEndOffset(this.lineTokenOffset);\n                // Is there a bracket token next? Only consume text.\n                if (containsBracketType && isOther && this.lineCharOffset < endOffset) {\n                    const languageId = lineTokens.getLanguageId(this.lineTokenOffset);\n                    const text = this.line.substring(this.lineCharOffset, endOffset);\n                    const brackets = this.bracketTokens.getSingleLanguageBracketTokens(languageId);\n                    const regexp = brackets.regExpGlobal;\n                    if (regexp) {\n                        regexp.lastIndex = 0;\n                        const match = regexp.exec(text);\n                        if (match) {\n                            peekedBracketToken = brackets.getToken(match[0]);\n                            if (peekedBracketToken) {\n                                // Consume leading text of the token\n                                this.lineCharOffset += match.index;\n                            }\n                        }\n                    }\n                }\n                lengthHeuristic += endOffset - this.lineCharOffset;\n                if (peekedBracketToken) {\n                    // Don't skip the entire token, as a single token could contain multiple brackets.\n                    if (startLineIdx !== this.lineIdx || startLineCharOffset !== this.lineCharOffset) {\n                        // There is text before the bracket\n                        this.peekedToken = peekedBracketToken;\n                        break;\n                    }\n                    else {\n                        // Consume the peeked token\n                        this.lineCharOffset += lengthGetColumnCountIfZeroLineCount(peekedBracketToken.length);\n                        return peekedBracketToken;\n                    }\n                }\n                else {\n                    // Skip the entire token, as the token contains no brackets at all.\n                    this.lineTokenOffset++;\n                    this.lineCharOffset = endOffset;\n                }\n            }\n            else {\n                if (this.lineIdx === this.textBufferLineCount - 1) {\n                    break;\n                }\n                this.lineIdx++;\n                this.lineTokens = this.textModel.tokenization.getLineTokens(this.lineIdx + 1);\n                this.lineTokenOffset = 0;\n                this.line = this.lineTokens.getLineContent();\n                this.lineCharOffset = 0;\n                lengthHeuristic += 33; // max 1000/33 = 30 lines\n                // This limits the amount of work to recompute min-indentation\n                if (lengthHeuristic > 1000) {\n                    // only break (automatically) at the end of line.\n                    break;\n                }\n            }\n            if (lengthHeuristic > 1500) {\n                // Eventually break regardless of the line length so that\n                // very long lines do not cause bad performance.\n                // This effective limits max indentation to 500, as\n                // indentation is not computed across multiple text nodes.\n                break;\n            }\n        }\n        // If a token contains some proper indentation, it also contains \\n{INDENTATION+}(?!{INDENTATION}),\n        // unless the line is too long.\n        // Thus, the min indentation of the document is the minimum min indentation of every text node.\n        const length = lengthDiff(startLineIdx, startLineCharOffset, this.lineIdx, this.lineCharOffset);\n        return new Token(length, 0 /* TokenKind.Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(length));\n    }\n}\nexport class FastTokenizer {\n    constructor(text, brackets) {\n        this.text = text;\n        this._offset = lengthZero;\n        this.idx = 0;\n        const regExpStr = brackets.getRegExpStr();\n        const regexp = regExpStr ? new RegExp(regExpStr + '|\\n', 'gi') : null;\n        const tokens = [];\n        let match;\n        let curLineCount = 0;\n        let lastLineBreakOffset = 0;\n        let lastTokenEndOffset = 0;\n        let lastTokenEndLine = 0;\n        const smallTextTokens0Line = [];\n        for (let i = 0; i < 60; i++) {\n            smallTextTokens0Line.push(new Token(toLength(0, i), 0 /* TokenKind.Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(toLength(0, i))));\n        }\n        const smallTextTokens1Line = [];\n        for (let i = 0; i < 60; i++) {\n            smallTextTokens1Line.push(new Token(toLength(1, i), 0 /* TokenKind.Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(toLength(1, i))));\n        }\n        if (regexp) {\n            regexp.lastIndex = 0;\n            // If a token contains indentation, it also contains \\n{INDENTATION+}(?!{INDENTATION})\n            while ((match = regexp.exec(text)) !== null) {\n                const curOffset = match.index;\n                const value = match[0];\n                if (value === '\\n') {\n                    curLineCount++;\n                    lastLineBreakOffset = curOffset + 1;\n                }\n                else {\n                    if (lastTokenEndOffset !== curOffset) {\n                        let token;\n                        if (lastTokenEndLine === curLineCount) {\n                            const colCount = curOffset - lastTokenEndOffset;\n                            if (colCount < smallTextTokens0Line.length) {\n                                token = smallTextTokens0Line[colCount];\n                            }\n                            else {\n                                const length = toLength(0, colCount);\n                                token = new Token(length, 0 /* TokenKind.Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(length));\n                            }\n                        }\n                        else {\n                            const lineCount = curLineCount - lastTokenEndLine;\n                            const colCount = curOffset - lastLineBreakOffset;\n                            if (lineCount === 1 && colCount < smallTextTokens1Line.length) {\n                                token = smallTextTokens1Line[colCount];\n                            }\n                            else {\n                                const length = toLength(lineCount, colCount);\n                                token = new Token(length, 0 /* TokenKind.Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(length));\n                            }\n                        }\n                        tokens.push(token);\n                    }\n                    // value is matched by regexp, so the token must exist\n                    tokens.push(brackets.getToken(value));\n                    lastTokenEndOffset = curOffset + value.length;\n                    lastTokenEndLine = curLineCount;\n                }\n            }\n        }\n        const offset = text.length;\n        if (lastTokenEndOffset !== offset) {\n            const length = (lastTokenEndLine === curLineCount)\n                ? toLength(0, offset - lastTokenEndOffset)\n                : toLength(curLineCount - lastTokenEndLine, offset - lastLineBreakOffset);\n            tokens.push(new Token(length, 0 /* TokenKind.Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(length)));\n        }\n        this.length = toLength(curLineCount, offset - lastLineBreakOffset);\n        this.tokens = tokens;\n    }\n    get offset() {\n        return this._offset;\n    }\n    read() {\n        return this.tokens[this.idx++] || null;\n    }\n    peek() {\n        return this.tokens[this.idx] || null;\n    }\n    skip(length) {\n        throw new NotSupportedError();\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as nls from '../../../nls.js';\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport { Selection } from '../core/selection.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { TextChange, compressConsecutiveTextChanges } from '../core/textChange.js';\nimport * as buffer from '../../../base/common/buffer.js';\nimport { basename } from '../../../base/common/resources.js';\nfunction uriGetComparisonKey(resource) {\n    return resource.toString();\n}\nexport class SingleModelEditStackData {\n    static create(model, beforeCursorState) {\n        const alternativeVersionId = model.getAlternativeVersionId();\n        const eol = getModelEOL(model);\n        return new SingleModelEditStackData(alternativeVersionId, alternativeVersionId, eol, eol, beforeCursorState, beforeCursorState, []);\n    }\n    constructor(beforeVersionId, afterVersionId, beforeEOL, afterEOL, beforeCursorState, afterCursorState, changes) {\n        this.beforeVersionId = beforeVersionId;\n        this.afterVersionId = afterVersionId;\n        this.beforeEOL = beforeEOL;\n        this.afterEOL = afterEOL;\n        this.beforeCursorState = beforeCursorState;\n        this.afterCursorState = afterCursorState;\n        this.changes = changes;\n    }\n    append(model, textChanges, afterEOL, afterVersionId, afterCursorState) {\n        if (textChanges.length > 0) {\n            this.changes = compressConsecutiveTextChanges(this.changes, textChanges);\n        }\n        this.afterEOL = afterEOL;\n        this.afterVersionId = afterVersionId;\n        this.afterCursorState = afterCursorState;\n    }\n    static _writeSelectionsSize(selections) {\n        return 4 + 4 * 4 * (selections ? selections.length : 0);\n    }\n    static _writeSelections(b, selections, offset) {\n        buffer.writeUInt32BE(b, (selections ? selections.length : 0), offset);\n        offset += 4;\n        if (selections) {\n            for (const selection of selections) {\n                buffer.writeUInt32BE(b, selection.selectionStartLineNumber, offset);\n                offset += 4;\n                buffer.writeUInt32BE(b, selection.selectionStartColumn, offset);\n                offset += 4;\n                buffer.writeUInt32BE(b, selection.positionLineNumber, offset);\n                offset += 4;\n                buffer.writeUInt32BE(b, selection.positionColumn, offset);\n                offset += 4;\n            }\n        }\n        return offset;\n    }\n    static _readSelections(b, offset, dest) {\n        const count = buffer.readUInt32BE(b, offset);\n        offset += 4;\n        for (let i = 0; i < count; i++) {\n            const selectionStartLineNumber = buffer.readUInt32BE(b, offset);\n            offset += 4;\n            const selectionStartColumn = buffer.readUInt32BE(b, offset);\n            offset += 4;\n            const positionLineNumber = buffer.readUInt32BE(b, offset);\n            offset += 4;\n            const positionColumn = buffer.readUInt32BE(b, offset);\n            offset += 4;\n            dest.push(new Selection(selectionStartLineNumber, selectionStartColumn, positionLineNumber, positionColumn));\n        }\n        return offset;\n    }\n    serialize() {\n        let necessarySize = (+4 // beforeVersionId\n            + 4 // afterVersionId\n            + 1 // beforeEOL\n            + 1 // afterEOL\n            + SingleModelEditStackData._writeSelectionsSize(this.beforeCursorState)\n            + SingleModelEditStackData._writeSelectionsSize(this.afterCursorState)\n            + 4 // change count\n        );\n        for (const change of this.changes) {\n            necessarySize += change.writeSize();\n        }\n        const b = new Uint8Array(necessarySize);\n        let offset = 0;\n        buffer.writeUInt32BE(b, this.beforeVersionId, offset);\n        offset += 4;\n        buffer.writeUInt32BE(b, this.afterVersionId, offset);\n        offset += 4;\n        buffer.writeUInt8(b, this.beforeEOL, offset);\n        offset += 1;\n        buffer.writeUInt8(b, this.afterEOL, offset);\n        offset += 1;\n        offset = SingleModelEditStackData._writeSelections(b, this.beforeCursorState, offset);\n        offset = SingleModelEditStackData._writeSelections(b, this.afterCursorState, offset);\n        buffer.writeUInt32BE(b, this.changes.length, offset);\n        offset += 4;\n        for (const change of this.changes) {\n            offset = change.write(b, offset);\n        }\n        return b.buffer;\n    }\n    static deserialize(source) {\n        const b = new Uint8Array(source);\n        let offset = 0;\n        const beforeVersionId = buffer.readUInt32BE(b, offset);\n        offset += 4;\n        const afterVersionId = buffer.readUInt32BE(b, offset);\n        offset += 4;\n        const beforeEOL = buffer.readUInt8(b, offset);\n        offset += 1;\n        const afterEOL = buffer.readUInt8(b, offset);\n        offset += 1;\n        const beforeCursorState = [];\n        offset = SingleModelEditStackData._readSelections(b, offset, beforeCursorState);\n        const afterCursorState = [];\n        offset = SingleModelEditStackData._readSelections(b, offset, afterCursorState);\n        const changeCount = buffer.readUInt32BE(b, offset);\n        offset += 4;\n        const changes = [];\n        for (let i = 0; i < changeCount; i++) {\n            offset = TextChange.read(b, offset, changes);\n        }\n        return new SingleModelEditStackData(beforeVersionId, afterVersionId, beforeEOL, afterEOL, beforeCursorState, afterCursorState, changes);\n    }\n}\nexport class SingleModelEditStackElement {\n    get type() {\n        return 0 /* UndoRedoElementType.Resource */;\n    }\n    get resource() {\n        if (URI.isUri(this.model)) {\n            return this.model;\n        }\n        return this.model.uri;\n    }\n    constructor(label, code, model, beforeCursorState) {\n        this.label = label;\n        this.code = code;\n        this.model = model;\n        this._data = SingleModelEditStackData.create(model, beforeCursorState);\n    }\n    toString() {\n        const data = (this._data instanceof SingleModelEditStackData ? this._data : SingleModelEditStackData.deserialize(this._data));\n        return data.changes.map(change => change.toString()).join(', ');\n    }\n    matchesResource(resource) {\n        const uri = (URI.isUri(this.model) ? this.model : this.model.uri);\n        return (uri.toString() === resource.toString());\n    }\n    setModel(model) {\n        this.model = model;\n    }\n    canAppend(model) {\n        return (this.model === model && this._data instanceof SingleModelEditStackData);\n    }\n    append(model, textChanges, afterEOL, afterVersionId, afterCursorState) {\n        if (this._data instanceof SingleModelEditStackData) {\n            this._data.append(model, textChanges, afterEOL, afterVersionId, afterCursorState);\n        }\n    }\n    close() {\n        if (this._data instanceof SingleModelEditStackData) {\n            this._data = this._data.serialize();\n        }\n    }\n    open() {\n        if (!(this._data instanceof SingleModelEditStackData)) {\n            this._data = SingleModelEditStackData.deserialize(this._data);\n        }\n    }\n    undo() {\n        if (URI.isUri(this.model)) {\n            // don't have a model\n            throw new Error(`Invalid SingleModelEditStackElement`);\n        }\n        if (this._data instanceof SingleModelEditStackData) {\n            this._data = this._data.serialize();\n        }\n        const data = SingleModelEditStackData.deserialize(this._data);\n        this.model._applyUndo(data.changes, data.beforeEOL, data.beforeVersionId, data.beforeCursorState);\n    }\n    redo() {\n        if (URI.isUri(this.model)) {\n            // don't have a model\n            throw new Error(`Invalid SingleModelEditStackElement`);\n        }\n        if (this._data instanceof SingleModelEditStackData) {\n            this._data = this._data.serialize();\n        }\n        const data = SingleModelEditStackData.deserialize(this._data);\n        this.model._applyRedo(data.changes, data.afterEOL, data.afterVersionId, data.afterCursorState);\n    }\n    heapSize() {\n        if (this._data instanceof SingleModelEditStackData) {\n            this._data = this._data.serialize();\n        }\n        return this._data.byteLength + 168 /*heap overhead*/;\n    }\n}\nexport class MultiModelEditStackElement {\n    get resources() {\n        return this._editStackElementsArr.map(editStackElement => editStackElement.resource);\n    }\n    constructor(label, code, editStackElements) {\n        this.label = label;\n        this.code = code;\n        this.type = 1 /* UndoRedoElementType.Workspace */;\n        this._isOpen = true;\n        this._editStackElementsArr = editStackElements.slice(0);\n        this._editStackElementsMap = new Map();\n        for (const editStackElement of this._editStackElementsArr) {\n            const key = uriGetComparisonKey(editStackElement.resource);\n            this._editStackElementsMap.set(key, editStackElement);\n        }\n        this._delegate = null;\n    }\n    prepareUndoRedo() {\n        if (this._delegate) {\n            return this._delegate.prepareUndoRedo(this);\n        }\n    }\n    matchesResource(resource) {\n        const key = uriGetComparisonKey(resource);\n        return (this._editStackElementsMap.has(key));\n    }\n    setModel(model) {\n        const key = uriGetComparisonKey(URI.isUri(model) ? model : model.uri);\n        if (this._editStackElementsMap.has(key)) {\n            this._editStackElementsMap.get(key).setModel(model);\n        }\n    }\n    canAppend(model) {\n        if (!this._isOpen) {\n            return false;\n        }\n        const key = uriGetComparisonKey(model.uri);\n        if (this._editStackElementsMap.has(key)) {\n            const editStackElement = this._editStackElementsMap.get(key);\n            return editStackElement.canAppend(model);\n        }\n        return false;\n    }\n    append(model, textChanges, afterEOL, afterVersionId, afterCursorState) {\n        const key = uriGetComparisonKey(model.uri);\n        const editStackElement = this._editStackElementsMap.get(key);\n        editStackElement.append(model, textChanges, afterEOL, afterVersionId, afterCursorState);\n    }\n    close() {\n        this._isOpen = false;\n    }\n    open() {\n        // cannot reopen\n    }\n    undo() {\n        this._isOpen = false;\n        for (const editStackElement of this._editStackElementsArr) {\n            editStackElement.undo();\n        }\n    }\n    redo() {\n        for (const editStackElement of this._editStackElementsArr) {\n            editStackElement.redo();\n        }\n    }\n    heapSize(resource) {\n        const key = uriGetComparisonKey(resource);\n        if (this._editStackElementsMap.has(key)) {\n            const editStackElement = this._editStackElementsMap.get(key);\n            return editStackElement.heapSize();\n        }\n        return 0;\n    }\n    split() {\n        return this._editStackElementsArr;\n    }\n    toString() {\n        const result = [];\n        for (const editStackElement of this._editStackElementsArr) {\n            result.push(`${basename(editStackElement.resource)}: ${editStackElement}`);\n        }\n        return `{${result.join(', ')}}`;\n    }\n}\nfunction getModelEOL(model) {\n    const eol = model.getEOL();\n    if (eol === '\\n') {\n        return 0 /* EndOfLineSequence.LF */;\n    }\n    else {\n        return 1 /* EndOfLineSequence.CRLF */;\n    }\n}\nexport function isEditStackElement(element) {\n    if (!element) {\n        return false;\n    }\n    return ((element instanceof SingleModelEditStackElement) || (element instanceof MultiModelEditStackElement));\n}\nexport class EditStack {\n    constructor(model, undoRedoService) {\n        this._model = model;\n        this._undoRedoService = undoRedoService;\n    }\n    pushStackElement() {\n        const lastElement = this._undoRedoService.getLastElement(this._model.uri);\n        if (isEditStackElement(lastElement)) {\n            lastElement.close();\n        }\n    }\n    popStackElement() {\n        const lastElement = this._undoRedoService.getLastElement(this._model.uri);\n        if (isEditStackElement(lastElement)) {\n            lastElement.open();\n        }\n    }\n    clear() {\n        this._undoRedoService.removeElements(this._model.uri);\n    }\n    _getOrCreateEditStackElement(beforeCursorState, group) {\n        const lastElement = this._undoRedoService.getLastElement(this._model.uri);\n        if (isEditStackElement(lastElement) && lastElement.canAppend(this._model)) {\n            return lastElement;\n        }\n        const newElement = new SingleModelEditStackElement(nls.localize('edit', \"Typing\"), 'undoredo.textBufferEdit', this._model, beforeCursorState);\n        this._undoRedoService.pushElement(newElement, group);\n        return newElement;\n    }\n    pushEOL(eol) {\n        const editStackElement = this._getOrCreateEditStackElement(null, undefined);\n        this._model.setEOL(eol);\n        editStackElement.append(this._model, [], getModelEOL(this._model), this._model.getAlternativeVersionId(), null);\n    }\n    pushEditOperation(beforeCursorState, editOperations, cursorStateComputer, group) {\n        const editStackElement = this._getOrCreateEditStackElement(beforeCursorState, group);\n        const inverseEditOperations = this._model.applyEdits(editOperations, true);\n        const afterCursorState = EditStack._computeCursorState(cursorStateComputer, inverseEditOperations);\n        const textChanges = inverseEditOperations.map((op, index) => ({ index: index, textChange: op.textChange }));\n        textChanges.sort((a, b) => {\n            if (a.textChange.oldPosition === b.textChange.oldPosition) {\n                return a.index - b.index;\n            }\n            return a.textChange.oldPosition - b.textChange.oldPosition;\n        });\n        editStackElement.append(this._model, textChanges.map(op => op.textChange), getModelEOL(this._model), this._model.getAlternativeVersionId(), afterCursorState);\n        return afterCursorState;\n    }\n    static _computeCursorState(cursorStateComputer, inverseEditOperations) {\n        try {\n            return cursorStateComputer ? cursorStateComputer(inverseEditOperations) : null;\n        }\n        catch (e) {\n            onUnexpectedError(e);\n            return null;\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { findLast } from '../../../base/common/arraysFind.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { CursorColumns } from '../core/cursorColumns.js';\nimport { Range } from '../core/range.js';\nimport { TextModelPart } from './textModelPart.js';\nimport { computeIndentLevel } from './utils.js';\nimport { HorizontalGuidesState, IndentGuide, IndentGuideHorizontalLine } from '../textModelGuides.js';\nimport { BugIndicatingError } from '../../../base/common/errors.js';\nexport class GuidesTextModelPart extends TextModelPart {\n    constructor(textModel, languageConfigurationService) {\n        super();\n        this.textModel = textModel;\n        this.languageConfigurationService = languageConfigurationService;\n    }\n    getLanguageConfiguration(languageId) {\n        return this.languageConfigurationService.getLanguageConfiguration(languageId);\n    }\n    _computeIndentLevel(lineIndex) {\n        return computeIndentLevel(this.textModel.getLineContent(lineIndex + 1), this.textModel.getOptions().tabSize);\n    }\n    getActiveIndentGuide(lineNumber, minLineNumber, maxLineNumber) {\n        this.assertNotDisposed();\n        const lineCount = this.textModel.getLineCount();\n        if (lineNumber < 1 || lineNumber > lineCount) {\n            throw new BugIndicatingError('Illegal value for lineNumber');\n        }\n        const foldingRules = this.getLanguageConfiguration(this.textModel.getLanguageId()).foldingRules;\n        const offSide = Boolean(foldingRules && foldingRules.offSide);\n        let up_aboveContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        let up_aboveContentLineIndent = -1;\n        let up_belowContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        let up_belowContentLineIndent = -1;\n        const up_resolveIndents = (lineNumber) => {\n            if (up_aboveContentLineIndex !== -1 &&\n                (up_aboveContentLineIndex === -2 ||\n                    up_aboveContentLineIndex > lineNumber - 1)) {\n                up_aboveContentLineIndex = -1;\n                up_aboveContentLineIndent = -1;\n                // must find previous line with content\n                for (let lineIndex = lineNumber - 2; lineIndex >= 0; lineIndex--) {\n                    const indent = this._computeIndentLevel(lineIndex);\n                    if (indent >= 0) {\n                        up_aboveContentLineIndex = lineIndex;\n                        up_aboveContentLineIndent = indent;\n                        break;\n                    }\n                }\n            }\n            if (up_belowContentLineIndex === -2) {\n                up_belowContentLineIndex = -1;\n                up_belowContentLineIndent = -1;\n                // must find next line with content\n                for (let lineIndex = lineNumber; lineIndex < lineCount; lineIndex++) {\n                    const indent = this._computeIndentLevel(lineIndex);\n                    if (indent >= 0) {\n                        up_belowContentLineIndex = lineIndex;\n                        up_belowContentLineIndent = indent;\n                        break;\n                    }\n                }\n            }\n        };\n        let down_aboveContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        let down_aboveContentLineIndent = -1;\n        let down_belowContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        let down_belowContentLineIndent = -1;\n        const down_resolveIndents = (lineNumber) => {\n            if (down_aboveContentLineIndex === -2) {\n                down_aboveContentLineIndex = -1;\n                down_aboveContentLineIndent = -1;\n                // must find previous line with content\n                for (let lineIndex = lineNumber - 2; lineIndex >= 0; lineIndex--) {\n                    const indent = this._computeIndentLevel(lineIndex);\n                    if (indent >= 0) {\n                        down_aboveContentLineIndex = lineIndex;\n                        down_aboveContentLineIndent = indent;\n                        break;\n                    }\n                }\n            }\n            if (down_belowContentLineIndex !== -1 &&\n                (down_belowContentLineIndex === -2 ||\n                    down_belowContentLineIndex < lineNumber - 1)) {\n                down_belowContentLineIndex = -1;\n                down_belowContentLineIndent = -1;\n                // must find next line with content\n                for (let lineIndex = lineNumber; lineIndex < lineCount; lineIndex++) {\n                    const indent = this._computeIndentLevel(lineIndex);\n                    if (indent >= 0) {\n                        down_belowContentLineIndex = lineIndex;\n                        down_belowContentLineIndent = indent;\n                        break;\n                    }\n                }\n            }\n        };\n        let startLineNumber = 0;\n        let goUp = true;\n        let endLineNumber = 0;\n        let goDown = true;\n        let indent = 0;\n        let initialIndent = 0;\n        for (let distance = 0; goUp || goDown; distance++) {\n            const upLineNumber = lineNumber - distance;\n            const downLineNumber = lineNumber + distance;\n            if (distance > 1 && (upLineNumber < 1 || upLineNumber < minLineNumber)) {\n                goUp = false;\n            }\n            if (distance > 1 &&\n                (downLineNumber > lineCount || downLineNumber > maxLineNumber)) {\n                goDown = false;\n            }\n            if (distance > 50000) {\n                // stop processing\n                goUp = false;\n                goDown = false;\n            }\n            let upLineIndentLevel = -1;\n            if (goUp && upLineNumber >= 1) {\n                // compute indent level going up\n                const currentIndent = this._computeIndentLevel(upLineNumber - 1);\n                if (currentIndent >= 0) {\n                    // This line has content (besides whitespace)\n                    // Use the line's indent\n                    up_belowContentLineIndex = upLineNumber - 1;\n                    up_belowContentLineIndent = currentIndent;\n                    upLineIndentLevel = Math.ceil(currentIndent / this.textModel.getOptions().indentSize);\n                }\n                else {\n                    up_resolveIndents(upLineNumber);\n                    upLineIndentLevel = this._getIndentLevelForWhitespaceLine(offSide, up_aboveContentLineIndent, up_belowContentLineIndent);\n                }\n            }\n            let downLineIndentLevel = -1;\n            if (goDown && downLineNumber <= lineCount) {\n                // compute indent level going down\n                const currentIndent = this._computeIndentLevel(downLineNumber - 1);\n                if (currentIndent >= 0) {\n                    // This line has content (besides whitespace)\n                    // Use the line's indent\n                    down_aboveContentLineIndex = downLineNumber - 1;\n                    down_aboveContentLineIndent = currentIndent;\n                    downLineIndentLevel = Math.ceil(currentIndent / this.textModel.getOptions().indentSize);\n                }\n                else {\n                    down_resolveIndents(downLineNumber);\n                    downLineIndentLevel = this._getIndentLevelForWhitespaceLine(offSide, down_aboveContentLineIndent, down_belowContentLineIndent);\n                }\n            }\n            if (distance === 0) {\n                initialIndent = upLineIndentLevel;\n                continue;\n            }\n            if (distance === 1) {\n                if (downLineNumber <= lineCount &&\n                    downLineIndentLevel >= 0 &&\n                    initialIndent + 1 === downLineIndentLevel) {\n                    // This is the beginning of a scope, we have special handling here, since we want the\n                    // child scope indent to be active, not the parent scope\n                    goUp = false;\n                    startLineNumber = downLineNumber;\n                    endLineNumber = downLineNumber;\n                    indent = downLineIndentLevel;\n                    continue;\n                }\n                if (upLineNumber >= 1 &&\n                    upLineIndentLevel >= 0 &&\n                    upLineIndentLevel - 1 === initialIndent) {\n                    // This is the end of a scope, just like above\n                    goDown = false;\n                    startLineNumber = upLineNumber;\n                    endLineNumber = upLineNumber;\n                    indent = upLineIndentLevel;\n                    continue;\n                }\n                startLineNumber = lineNumber;\n                endLineNumber = lineNumber;\n                indent = initialIndent;\n                if (indent === 0) {\n                    // No need to continue\n                    return { startLineNumber, endLineNumber, indent };\n                }\n            }\n            if (goUp) {\n                if (upLineIndentLevel >= indent) {\n                    startLineNumber = upLineNumber;\n                }\n                else {\n                    goUp = false;\n                }\n            }\n            if (goDown) {\n                if (downLineIndentLevel >= indent) {\n                    endLineNumber = downLineNumber;\n                }\n                else {\n                    goDown = false;\n                }\n            }\n        }\n        return { startLineNumber, endLineNumber, indent };\n    }\n    getLinesBracketGuides(startLineNumber, endLineNumber, activePosition, options) {\n        const result = [];\n        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n            result.push([]);\n        }\n        // If requested, this could be made configurable.\n        const includeSingleLinePairs = true;\n        const bracketPairs = this.textModel.bracketPairs.getBracketPairsInRangeWithMinIndentation(new Range(startLineNumber, 1, endLineNumber, this.textModel.getLineMaxColumn(endLineNumber))).toArray();\n        let activeBracketPairRange = undefined;\n        if (activePosition && bracketPairs.length > 0) {\n            const bracketsContainingActivePosition = (startLineNumber <= activePosition.lineNumber &&\n                activePosition.lineNumber <= endLineNumber\n                // We don't need to query the brackets again if the cursor is in the viewport\n                ? bracketPairs\n                : this.textModel.bracketPairs.getBracketPairsInRange(Range.fromPositions(activePosition)).toArray()).filter((bp) => Range.strictContainsPosition(bp.range, activePosition));\n            activeBracketPairRange = findLast(bracketsContainingActivePosition, (i) => includeSingleLinePairs || i.range.startLineNumber !== i.range.endLineNumber)?.range;\n        }\n        const independentColorPoolPerBracketType = this.textModel.getOptions().bracketPairColorizationOptions.independentColorPoolPerBracketType;\n        const colorProvider = new BracketPairGuidesClassNames();\n        for (const pair of bracketPairs) {\n            /*\n\n\n                    {\n                    |\n                    }\n\n                    {\n                    |\n                    ----}\n\n                ____{\n                |test\n                ----}\n\n                renderHorizontalEndLineAtTheBottom:\n                    {\n                    |\n                    |x}\n                    --\n                renderHorizontalEndLineAtTheBottom:\n                ____{\n                |test\n                | x }\n                ----\n            */\n            if (!pair.closingBracketRange) {\n                continue;\n            }\n            const isActive = activeBracketPairRange && pair.range.equalsRange(activeBracketPairRange);\n            if (!isActive && !options.includeInactive) {\n                continue;\n            }\n            const className = colorProvider.getInlineClassName(pair.nestingLevel, pair.nestingLevelOfEqualBracketType, independentColorPoolPerBracketType) +\n                (options.highlightActive && isActive\n                    ? ' ' + colorProvider.activeClassName\n                    : '');\n            const start = pair.openingBracketRange.getStartPosition();\n            const end = pair.closingBracketRange.getStartPosition();\n            const horizontalGuides = options.horizontalGuides === HorizontalGuidesState.Enabled || (options.horizontalGuides === HorizontalGuidesState.EnabledForActive && isActive);\n            if (pair.range.startLineNumber === pair.range.endLineNumber) {\n                if (includeSingleLinePairs && horizontalGuides) {\n                    result[pair.range.startLineNumber - startLineNumber].push(new IndentGuide(-1, pair.openingBracketRange.getEndPosition().column, className, new IndentGuideHorizontalLine(false, end.column), -1, -1));\n                }\n                continue;\n            }\n            const endVisibleColumn = this.getVisibleColumnFromPosition(end);\n            const startVisibleColumn = this.getVisibleColumnFromPosition(pair.openingBracketRange.getStartPosition());\n            const guideVisibleColumn = Math.min(startVisibleColumn, endVisibleColumn, pair.minVisibleColumnIndentation + 1);\n            let renderHorizontalEndLineAtTheBottom = false;\n            const firstNonWsIndex = strings.firstNonWhitespaceIndex(this.textModel.getLineContent(pair.closingBracketRange.startLineNumber));\n            const hasTextBeforeClosingBracket = firstNonWsIndex < pair.closingBracketRange.startColumn - 1;\n            if (hasTextBeforeClosingBracket) {\n                renderHorizontalEndLineAtTheBottom = true;\n            }\n            const visibleGuideStartLineNumber = Math.max(start.lineNumber, startLineNumber);\n            const visibleGuideEndLineNumber = Math.min(end.lineNumber, endLineNumber);\n            const offset = renderHorizontalEndLineAtTheBottom ? 1 : 0;\n            for (let l = visibleGuideStartLineNumber; l < visibleGuideEndLineNumber + offset; l++) {\n                result[l - startLineNumber].push(new IndentGuide(guideVisibleColumn, -1, className, null, l === start.lineNumber ? start.column : -1, l === end.lineNumber ? end.column : -1));\n            }\n            if (horizontalGuides) {\n                if (start.lineNumber >= startLineNumber && startVisibleColumn > guideVisibleColumn) {\n                    result[start.lineNumber - startLineNumber].push(new IndentGuide(guideVisibleColumn, -1, className, new IndentGuideHorizontalLine(false, start.column), -1, -1));\n                }\n                if (end.lineNumber <= endLineNumber && endVisibleColumn > guideVisibleColumn) {\n                    result[end.lineNumber - startLineNumber].push(new IndentGuide(guideVisibleColumn, -1, className, new IndentGuideHorizontalLine(!renderHorizontalEndLineAtTheBottom, end.column), -1, -1));\n                }\n            }\n        }\n        for (const guides of result) {\n            guides.sort((a, b) => a.visibleColumn - b.visibleColumn);\n        }\n        return result;\n    }\n    getVisibleColumnFromPosition(position) {\n        return (CursorColumns.visibleColumnFromColumn(this.textModel.getLineContent(position.lineNumber), position.column, this.textModel.getOptions().tabSize) + 1);\n    }\n    getLinesIndentGuides(startLineNumber, endLineNumber) {\n        this.assertNotDisposed();\n        const lineCount = this.textModel.getLineCount();\n        if (startLineNumber < 1 || startLineNumber > lineCount) {\n            throw new Error('Illegal value for startLineNumber');\n        }\n        if (endLineNumber < 1 || endLineNumber > lineCount) {\n            throw new Error('Illegal value for endLineNumber');\n        }\n        const options = this.textModel.getOptions();\n        const foldingRules = this.getLanguageConfiguration(this.textModel.getLanguageId()).foldingRules;\n        const offSide = Boolean(foldingRules && foldingRules.offSide);\n        const result = new Array(endLineNumber - startLineNumber + 1);\n        let aboveContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        let aboveContentLineIndent = -1;\n        let belowContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        let belowContentLineIndent = -1;\n        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n            const resultIndex = lineNumber - startLineNumber;\n            const currentIndent = this._computeIndentLevel(lineNumber - 1);\n            if (currentIndent >= 0) {\n                // This line has content (besides whitespace)\n                // Use the line's indent\n                aboveContentLineIndex = lineNumber - 1;\n                aboveContentLineIndent = currentIndent;\n                result[resultIndex] = Math.ceil(currentIndent / options.indentSize);\n                continue;\n            }\n            if (aboveContentLineIndex === -2) {\n                aboveContentLineIndex = -1;\n                aboveContentLineIndent = -1;\n                // must find previous line with content\n                for (let lineIndex = lineNumber - 2; lineIndex >= 0; lineIndex--) {\n                    const indent = this._computeIndentLevel(lineIndex);\n                    if (indent >= 0) {\n                        aboveContentLineIndex = lineIndex;\n                        aboveContentLineIndent = indent;\n                        break;\n                    }\n                }\n            }\n            if (belowContentLineIndex !== -1 &&\n                (belowContentLineIndex === -2 || belowContentLineIndex < lineNumber - 1)) {\n                belowContentLineIndex = -1;\n                belowContentLineIndent = -1;\n                // must find next line with content\n                for (let lineIndex = lineNumber; lineIndex < lineCount; lineIndex++) {\n                    const indent = this._computeIndentLevel(lineIndex);\n                    if (indent >= 0) {\n                        belowContentLineIndex = lineIndex;\n                        belowContentLineIndent = indent;\n                        break;\n                    }\n                }\n            }\n            result[resultIndex] = this._getIndentLevelForWhitespaceLine(offSide, aboveContentLineIndent, belowContentLineIndent);\n        }\n        return result;\n    }\n    _getIndentLevelForWhitespaceLine(offSide, aboveContentLineIndent, belowContentLineIndent) {\n        const options = this.textModel.getOptions();\n        if (aboveContentLineIndent === -1 || belowContentLineIndent === -1) {\n            // At the top or bottom of the file\n            return 0;\n        }\n        else if (aboveContentLineIndent < belowContentLineIndent) {\n            // we are inside the region above\n            return 1 + Math.floor(aboveContentLineIndent / options.indentSize);\n        }\n        else if (aboveContentLineIndent === belowContentLineIndent) {\n            // we are in between two regions\n            return Math.ceil(belowContentLineIndent / options.indentSize);\n        }\n        else {\n            if (offSide) {\n                // same level as region below\n                return Math.ceil(belowContentLineIndent / options.indentSize);\n            }\n            else {\n                // we are inside the region that ends below\n                return 1 + Math.floor(belowContentLineIndent / options.indentSize);\n            }\n        }\n    }\n}\nexport class BracketPairGuidesClassNames {\n    constructor() {\n        this.activeClassName = 'indent-active';\n    }\n    getInlineClassName(nestingLevel, nestingLevelOfEqualBracketType, independentColorPoolPerBracketType) {\n        return this.getInlineClassNameOfLevel(independentColorPoolPerBracketType ? nestingLevelOfEqualBracketType : nestingLevel);\n    }\n    getInlineClassNameOfLevel(level) {\n        // To support a dynamic amount of colors up to 6 colors,\n        // we use a number that is a lcm of all numbers from 1 to 6.\n        return `bracket-indent-guide lvl-${level % 30}`;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class BracketInfo {\n    constructor(range, \n    /** 0-based level */\n    nestingLevel, nestingLevelOfEqualBracketType, isInvalid) {\n        this.range = range;\n        this.nestingLevel = nestingLevel;\n        this.nestingLevelOfEqualBracketType = nestingLevelOfEqualBracketType;\n        this.isInvalid = isInvalid;\n    }\n}\nexport class BracketPairInfo {\n    constructor(range, openingBracketRange, closingBracketRange, \n    /** 0-based */\n    nestingLevel, nestingLevelOfEqualBracketType, bracketPairNode) {\n        this.range = range;\n        this.openingBracketRange = openingBracketRange;\n        this.closingBracketRange = closingBracketRange;\n        this.nestingLevel = nestingLevel;\n        this.nestingLevelOfEqualBracketType = nestingLevelOfEqualBracketType;\n        this.bracketPairNode = bracketPairNode;\n    }\n    get openingBracketInfo() {\n        return this.bracketPairNode.openingBracket.bracketInfo;\n    }\n}\nexport class BracketPairWithMinIndentationInfo extends BracketPairInfo {\n    constructor(range, openingBracketRange, closingBracketRange, \n    /**\n     * 0-based\n    */\n    nestingLevel, nestingLevelOfEqualBracketType, bracketPairNode, \n    /**\n     * -1 if not requested, otherwise the size of the minimum indentation in the bracket pair in terms of visible columns.\n    */\n    minVisibleColumnIndentation) {\n        super(range, openingBracketRange, closingBracketRange, nestingLevel, nestingLevelOfEqualBracketType, bracketPairNode);\n        this.minVisibleColumnIndentation = minVisibleColumnIndentation;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../../../../base/common/event.js';\nimport { Disposable } from '../../../../../base/common/lifecycle.js';\nimport { BracketInfo, BracketPairWithMinIndentationInfo } from '../../../textModelBracketPairs.js';\nimport { TextEditInfo } from './beforeEditPositionMapper.js';\nimport { LanguageAgnosticBracketTokens } from './brackets.js';\nimport { lengthAdd, lengthGreaterThanEqual, lengthLessThan, lengthLessThanEqual, lengthsToRange, lengthZero, positionToLength, toLength } from './length.js';\nimport { parseDocument } from './parser.js';\nimport { DenseKeyProvider } from './smallImmutableSet.js';\nimport { FastTokenizer, TextBufferTokenizer } from './tokenizer.js';\nimport { CallbackIterable } from '../../../../../base/common/arrays.js';\nimport { combineTextEditInfos } from './combineTextEditInfos.js';\nexport class BracketPairsTree extends Disposable {\n    didLanguageChange(languageId) {\n        return this.brackets.didLanguageChange(languageId);\n    }\n    constructor(textModel, getLanguageConfiguration) {\n        super();\n        this.textModel = textModel;\n        this.getLanguageConfiguration = getLanguageConfiguration;\n        this.didChangeEmitter = new Emitter();\n        this.denseKeyProvider = new DenseKeyProvider();\n        this.brackets = new LanguageAgnosticBracketTokens(this.denseKeyProvider, this.getLanguageConfiguration);\n        this.onDidChange = this.didChangeEmitter.event;\n        this.queuedTextEditsForInitialAstWithoutTokens = [];\n        this.queuedTextEdits = [];\n        if (!textModel.tokenization.hasTokens) {\n            const brackets = this.brackets.getSingleLanguageBracketTokens(this.textModel.getLanguageId());\n            const tokenizer = new FastTokenizer(this.textModel.getValue(), brackets);\n            this.initialAstWithoutTokens = parseDocument(tokenizer, [], undefined, true);\n            this.astWithTokens = this.initialAstWithoutTokens;\n        }\n        else if (textModel.tokenization.backgroundTokenizationState === 2 /* BackgroundTokenizationState.Completed */) {\n            // Skip the initial ast, as there is no flickering.\n            // Directly create the tree with token information.\n            this.initialAstWithoutTokens = undefined;\n            this.astWithTokens = this.parseDocumentFromTextBuffer([], undefined, false);\n        }\n        else {\n            // We missed some token changes already, so we cannot use the fast tokenizer + delta increments\n            this.initialAstWithoutTokens = this.parseDocumentFromTextBuffer([], undefined, true);\n            this.astWithTokens = this.initialAstWithoutTokens;\n        }\n    }\n    //#region TextModel events\n    handleDidChangeBackgroundTokenizationState() {\n        if (this.textModel.tokenization.backgroundTokenizationState === 2 /* BackgroundTokenizationState.Completed */) {\n            const wasUndefined = this.initialAstWithoutTokens === undefined;\n            // Clear the initial tree as we can use the tree with token information now.\n            this.initialAstWithoutTokens = undefined;\n            if (!wasUndefined) {\n                this.didChangeEmitter.fire();\n            }\n        }\n    }\n    handleDidChangeTokens({ ranges }) {\n        const edits = ranges.map(r => new TextEditInfo(toLength(r.fromLineNumber - 1, 0), toLength(r.toLineNumber, 0), toLength(r.toLineNumber - r.fromLineNumber + 1, 0)));\n        this.handleEdits(edits, true);\n        if (!this.initialAstWithoutTokens) {\n            this.didChangeEmitter.fire();\n        }\n    }\n    handleContentChanged(change) {\n        const edits = TextEditInfo.fromModelContentChanges(change.changes);\n        this.handleEdits(edits, false);\n    }\n    handleEdits(edits, tokenChange) {\n        // Lazily queue the edits and only apply them when the tree is accessed.\n        const result = combineTextEditInfos(this.queuedTextEdits, edits);\n        this.queuedTextEdits = result;\n        if (this.initialAstWithoutTokens && !tokenChange) {\n            this.queuedTextEditsForInitialAstWithoutTokens = combineTextEditInfos(this.queuedTextEditsForInitialAstWithoutTokens, edits);\n        }\n    }\n    //#endregion\n    flushQueue() {\n        if (this.queuedTextEdits.length > 0) {\n            this.astWithTokens = this.parseDocumentFromTextBuffer(this.queuedTextEdits, this.astWithTokens, false);\n            this.queuedTextEdits = [];\n        }\n        if (this.queuedTextEditsForInitialAstWithoutTokens.length > 0) {\n            if (this.initialAstWithoutTokens) {\n                this.initialAstWithoutTokens = this.parseDocumentFromTextBuffer(this.queuedTextEditsForInitialAstWithoutTokens, this.initialAstWithoutTokens, false);\n            }\n            this.queuedTextEditsForInitialAstWithoutTokens = [];\n        }\n    }\n    /**\n     * @pure (only if isPure = true)\n    */\n    parseDocumentFromTextBuffer(edits, previousAst, immutable) {\n        // Is much faster if `isPure = false`.\n        const isPure = false;\n        const previousAstClone = isPure ? previousAst?.deepClone() : previousAst;\n        const tokenizer = new TextBufferTokenizer(this.textModel, this.brackets);\n        const result = parseDocument(tokenizer, edits, previousAstClone, immutable);\n        return result;\n    }\n    getBracketsInRange(range, onlyColorizedBrackets) {\n        this.flushQueue();\n        const startOffset = toLength(range.startLineNumber - 1, range.startColumn - 1);\n        const endOffset = toLength(range.endLineNumber - 1, range.endColumn - 1);\n        return new CallbackIterable(cb => {\n            const node = this.initialAstWithoutTokens || this.astWithTokens;\n            collectBrackets(node, lengthZero, node.length, startOffset, endOffset, cb, 0, 0, new Map(), onlyColorizedBrackets);\n        });\n    }\n    getBracketPairsInRange(range, includeMinIndentation) {\n        this.flushQueue();\n        const startLength = positionToLength(range.getStartPosition());\n        const endLength = positionToLength(range.getEndPosition());\n        return new CallbackIterable(cb => {\n            const node = this.initialAstWithoutTokens || this.astWithTokens;\n            const context = new CollectBracketPairsContext(cb, includeMinIndentation, this.textModel);\n            collectBracketPairs(node, lengthZero, node.length, startLength, endLength, context, 0, new Map());\n        });\n    }\n    getFirstBracketAfter(position) {\n        this.flushQueue();\n        const node = this.initialAstWithoutTokens || this.astWithTokens;\n        return getFirstBracketAfter(node, lengthZero, node.length, positionToLength(position));\n    }\n    getFirstBracketBefore(position) {\n        this.flushQueue();\n        const node = this.initialAstWithoutTokens || this.astWithTokens;\n        return getFirstBracketBefore(node, lengthZero, node.length, positionToLength(position));\n    }\n}\nfunction getFirstBracketBefore(node, nodeOffsetStart, nodeOffsetEnd, position) {\n    if (node.kind === 4 /* AstNodeKind.List */ || node.kind === 2 /* AstNodeKind.Pair */) {\n        const lengths = [];\n        for (const child of node.children) {\n            nodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n            lengths.push({ nodeOffsetStart, nodeOffsetEnd });\n            nodeOffsetStart = nodeOffsetEnd;\n        }\n        for (let i = lengths.length - 1; i >= 0; i--) {\n            const { nodeOffsetStart, nodeOffsetEnd } = lengths[i];\n            if (lengthLessThan(nodeOffsetStart, position)) {\n                const result = getFirstBracketBefore(node.children[i], nodeOffsetStart, nodeOffsetEnd, position);\n                if (result) {\n                    return result;\n                }\n            }\n        }\n        return null;\n    }\n    else if (node.kind === 3 /* AstNodeKind.UnexpectedClosingBracket */) {\n        return null;\n    }\n    else if (node.kind === 1 /* AstNodeKind.Bracket */) {\n        const range = lengthsToRange(nodeOffsetStart, nodeOffsetEnd);\n        return {\n            bracketInfo: node.bracketInfo,\n            range\n        };\n    }\n    return null;\n}\nfunction getFirstBracketAfter(node, nodeOffsetStart, nodeOffsetEnd, position) {\n    if (node.kind === 4 /* AstNodeKind.List */ || node.kind === 2 /* AstNodeKind.Pair */) {\n        for (const child of node.children) {\n            nodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n            if (lengthLessThan(position, nodeOffsetEnd)) {\n                const result = getFirstBracketAfter(child, nodeOffsetStart, nodeOffsetEnd, position);\n                if (result) {\n                    return result;\n                }\n            }\n            nodeOffsetStart = nodeOffsetEnd;\n        }\n        return null;\n    }\n    else if (node.kind === 3 /* AstNodeKind.UnexpectedClosingBracket */) {\n        return null;\n    }\n    else if (node.kind === 1 /* AstNodeKind.Bracket */) {\n        const range = lengthsToRange(nodeOffsetStart, nodeOffsetEnd);\n        return {\n            bracketInfo: node.bracketInfo,\n            range\n        };\n    }\n    return null;\n}\nfunction collectBrackets(node, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, push, level, nestingLevelOfEqualBracketType, levelPerBracketType, onlyColorizedBrackets, parentPairIsIncomplete = false) {\n    if (level > 200) {\n        return true;\n    }\n    whileLoop: while (true) {\n        switch (node.kind) {\n            case 4 /* AstNodeKind.List */: {\n                const childCount = node.childrenLength;\n                for (let i = 0; i < childCount; i++) {\n                    const child = node.getChild(i);\n                    if (!child) {\n                        continue;\n                    }\n                    nodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n                    if (lengthLessThanEqual(nodeOffsetStart, endOffset) &&\n                        lengthGreaterThanEqual(nodeOffsetEnd, startOffset)) {\n                        const childEndsAfterEnd = lengthGreaterThanEqual(nodeOffsetEnd, endOffset);\n                        if (childEndsAfterEnd) {\n                            // No child after this child in the requested window, don't recurse\n                            node = child;\n                            continue whileLoop;\n                        }\n                        const shouldContinue = collectBrackets(child, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, push, level, 0, levelPerBracketType, onlyColorizedBrackets);\n                        if (!shouldContinue) {\n                            return false;\n                        }\n                    }\n                    nodeOffsetStart = nodeOffsetEnd;\n                }\n                return true;\n            }\n            case 2 /* AstNodeKind.Pair */: {\n                const colorize = !onlyColorizedBrackets || !node.closingBracket || node.closingBracket.bracketInfo.closesColorized(node.openingBracket.bracketInfo);\n                let levelPerBracket = 0;\n                if (levelPerBracketType) {\n                    let existing = levelPerBracketType.get(node.openingBracket.text);\n                    if (existing === undefined) {\n                        existing = 0;\n                    }\n                    levelPerBracket = existing;\n                    if (colorize) {\n                        existing++;\n                        levelPerBracketType.set(node.openingBracket.text, existing);\n                    }\n                }\n                const childCount = node.childrenLength;\n                for (let i = 0; i < childCount; i++) {\n                    const child = node.getChild(i);\n                    if (!child) {\n                        continue;\n                    }\n                    nodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n                    if (lengthLessThanEqual(nodeOffsetStart, endOffset) &&\n                        lengthGreaterThanEqual(nodeOffsetEnd, startOffset)) {\n                        const childEndsAfterEnd = lengthGreaterThanEqual(nodeOffsetEnd, endOffset);\n                        if (childEndsAfterEnd && child.kind !== 1 /* AstNodeKind.Bracket */) {\n                            // No child after this child in the requested window, don't recurse\n                            // Don't do this for brackets because of unclosed/unopened brackets\n                            node = child;\n                            if (colorize) {\n                                level++;\n                                nestingLevelOfEqualBracketType = levelPerBracket + 1;\n                            }\n                            else {\n                                nestingLevelOfEqualBracketType = levelPerBracket;\n                            }\n                            continue whileLoop;\n                        }\n                        if (colorize || child.kind !== 1 /* AstNodeKind.Bracket */ || !node.closingBracket) {\n                            const shouldContinue = collectBrackets(child, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, push, colorize ? level + 1 : level, colorize ? levelPerBracket + 1 : levelPerBracket, levelPerBracketType, onlyColorizedBrackets, !node.closingBracket);\n                            if (!shouldContinue) {\n                                return false;\n                            }\n                        }\n                    }\n                    nodeOffsetStart = nodeOffsetEnd;\n                }\n                levelPerBracketType?.set(node.openingBracket.text, levelPerBracket);\n                return true;\n            }\n            case 3 /* AstNodeKind.UnexpectedClosingBracket */: {\n                const range = lengthsToRange(nodeOffsetStart, nodeOffsetEnd);\n                return push(new BracketInfo(range, level - 1, 0, true));\n            }\n            case 1 /* AstNodeKind.Bracket */: {\n                const range = lengthsToRange(nodeOffsetStart, nodeOffsetEnd);\n                return push(new BracketInfo(range, level - 1, nestingLevelOfEqualBracketType - 1, parentPairIsIncomplete));\n            }\n            case 0 /* AstNodeKind.Text */:\n                return true;\n        }\n    }\n}\nclass CollectBracketPairsContext {\n    constructor(push, includeMinIndentation, textModel) {\n        this.push = push;\n        this.includeMinIndentation = includeMinIndentation;\n        this.textModel = textModel;\n    }\n}\nfunction collectBracketPairs(node, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, context, level, levelPerBracketType) {\n    if (level > 200) {\n        return true;\n    }\n    let shouldContinue = true;\n    if (node.kind === 2 /* AstNodeKind.Pair */) {\n        let levelPerBracket = 0;\n        if (levelPerBracketType) {\n            let existing = levelPerBracketType.get(node.openingBracket.text);\n            if (existing === undefined) {\n                existing = 0;\n            }\n            levelPerBracket = existing;\n            existing++;\n            levelPerBracketType.set(node.openingBracket.text, existing);\n        }\n        const openingBracketEnd = lengthAdd(nodeOffsetStart, node.openingBracket.length);\n        let minIndentation = -1;\n        if (context.includeMinIndentation) {\n            minIndentation = node.computeMinIndentation(nodeOffsetStart, context.textModel);\n        }\n        shouldContinue = context.push(new BracketPairWithMinIndentationInfo(lengthsToRange(nodeOffsetStart, nodeOffsetEnd), lengthsToRange(nodeOffsetStart, openingBracketEnd), node.closingBracket\n            ? lengthsToRange(lengthAdd(openingBracketEnd, node.child?.length || lengthZero), nodeOffsetEnd)\n            : undefined, level, levelPerBracket, node, minIndentation));\n        nodeOffsetStart = openingBracketEnd;\n        if (shouldContinue && node.child) {\n            const child = node.child;\n            nodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n            if (lengthLessThanEqual(nodeOffsetStart, endOffset) &&\n                lengthGreaterThanEqual(nodeOffsetEnd, startOffset)) {\n                shouldContinue = collectBracketPairs(child, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, context, level + 1, levelPerBracketType);\n                if (!shouldContinue) {\n                    return false;\n                }\n            }\n        }\n        levelPerBracketType?.set(node.openingBracket.text, levelPerBracket);\n    }\n    else {\n        let curOffset = nodeOffsetStart;\n        for (const child of node.children) {\n            const childOffset = curOffset;\n            curOffset = lengthAdd(curOffset, child.length);\n            if (lengthLessThanEqual(childOffset, endOffset) &&\n                lengthLessThanEqual(startOffset, curOffset)) {\n                shouldContinue = collectBracketPairs(child, childOffset, curOffset, startOffset, endOffset, context, level, levelPerBracketType);\n                if (!shouldContinue) {\n                    return false;\n                }\n            }\n        }\n    }\n    return shouldContinue;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { CallbackIterable, compareBy } from '../../../../base/common/arrays.js';\nimport { Emitter } from '../../../../base/common/event.js';\nimport { Disposable, DisposableStore, MutableDisposable } from '../../../../base/common/lifecycle.js';\nimport { Range } from '../../core/range.js';\nimport { ignoreBracketsInToken } from '../../languages/supports.js';\nimport { BracketsUtils } from '../../languages/supports/richEditBrackets.js';\nimport { BracketPairsTree } from './bracketPairsTree/bracketPairsTree.js';\nexport class BracketPairsTextModelPart extends Disposable {\n    get canBuildAST() {\n        const maxSupportedDocumentLength = /* max lines */ 50_000 * /* average column count */ 100;\n        return this.textModel.getValueLength() <= maxSupportedDocumentLength;\n    }\n    constructor(textModel, languageConfigurationService) {\n        super();\n        this.textModel = textModel;\n        this.languageConfigurationService = languageConfigurationService;\n        this.bracketPairsTree = this._register(new MutableDisposable());\n        this.onDidChangeEmitter = new Emitter();\n        this.onDidChange = this.onDidChangeEmitter.event;\n        this.bracketsRequested = false;\n    }\n    //#region TextModel events\n    handleLanguageConfigurationServiceChange(e) {\n        if (!e.languageId || this.bracketPairsTree.value?.object.didLanguageChange(e.languageId)) {\n            this.bracketPairsTree.clear();\n            this.updateBracketPairsTree();\n        }\n    }\n    handleDidChangeOptions(e) {\n        this.bracketPairsTree.clear();\n        this.updateBracketPairsTree();\n    }\n    handleDidChangeLanguage(e) {\n        this.bracketPairsTree.clear();\n        this.updateBracketPairsTree();\n    }\n    handleDidChangeContent(change) {\n        this.bracketPairsTree.value?.object.handleContentChanged(change);\n    }\n    handleDidChangeBackgroundTokenizationState() {\n        this.bracketPairsTree.value?.object.handleDidChangeBackgroundTokenizationState();\n    }\n    handleDidChangeTokens(e) {\n        this.bracketPairsTree.value?.object.handleDidChangeTokens(e);\n    }\n    //#endregion\n    updateBracketPairsTree() {\n        if (this.bracketsRequested && this.canBuildAST) {\n            if (!this.bracketPairsTree.value) {\n                const store = new DisposableStore();\n                this.bracketPairsTree.value = createDisposableRef(store.add(new BracketPairsTree(this.textModel, (languageId) => {\n                    return this.languageConfigurationService.getLanguageConfiguration(languageId);\n                })), store);\n                store.add(this.bracketPairsTree.value.object.onDidChange(e => this.onDidChangeEmitter.fire(e)));\n                this.onDidChangeEmitter.fire();\n            }\n        }\n        else {\n            if (this.bracketPairsTree.value) {\n                this.bracketPairsTree.clear();\n                // Important: Don't call fire if there was no change!\n                this.onDidChangeEmitter.fire();\n            }\n        }\n    }\n    /**\n     * Returns all bracket pairs that intersect the given range.\n     * The result is sorted by the start position.\n    */\n    getBracketPairsInRange(range) {\n        this.bracketsRequested = true;\n        this.updateBracketPairsTree();\n        return this.bracketPairsTree.value?.object.getBracketPairsInRange(range, false) || CallbackIterable.empty;\n    }\n    getBracketPairsInRangeWithMinIndentation(range) {\n        this.bracketsRequested = true;\n        this.updateBracketPairsTree();\n        return this.bracketPairsTree.value?.object.getBracketPairsInRange(range, true) || CallbackIterable.empty;\n    }\n    getBracketsInRange(range, onlyColorizedBrackets = false) {\n        this.bracketsRequested = true;\n        this.updateBracketPairsTree();\n        return this.bracketPairsTree.value?.object.getBracketsInRange(range, onlyColorizedBrackets) || CallbackIterable.empty;\n    }\n    findMatchingBracketUp(_bracket, _position, maxDuration) {\n        const position = this.textModel.validatePosition(_position);\n        const languageId = this.textModel.getLanguageIdAtPosition(position.lineNumber, position.column);\n        if (this.canBuildAST) {\n            const closingBracketInfo = this.languageConfigurationService\n                .getLanguageConfiguration(languageId)\n                .bracketsNew.getClosingBracketInfo(_bracket);\n            if (!closingBracketInfo) {\n                return null;\n            }\n            const bracketPair = this.getBracketPairsInRange(Range.fromPositions(_position, _position)).findLast((b) => closingBracketInfo.closes(b.openingBracketInfo));\n            if (bracketPair) {\n                return bracketPair.openingBracketRange;\n            }\n            return null;\n        }\n        else {\n            // Fallback to old bracket matching code:\n            const bracket = _bracket.toLowerCase();\n            const bracketsSupport = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n            if (!bracketsSupport) {\n                return null;\n            }\n            const data = bracketsSupport.textIsBracket[bracket];\n            if (!data) {\n                return null;\n            }\n            return stripBracketSearchCanceled(this._findMatchingBracketUp(data, position, createTimeBasedContinueBracketSearchPredicate(maxDuration)));\n        }\n    }\n    matchBracket(position, maxDuration) {\n        if (this.canBuildAST) {\n            const bracketPair = this.getBracketPairsInRange(Range.fromPositions(position, position)).filter((item) => item.closingBracketRange !== undefined &&\n                (item.openingBracketRange.containsPosition(position) ||\n                    item.closingBracketRange.containsPosition(position))).findLastMaxBy(compareBy((item) => item.openingBracketRange.containsPosition(position)\n                ? item.openingBracketRange\n                : item.closingBracketRange, Range.compareRangesUsingStarts));\n            if (bracketPair) {\n                return [bracketPair.openingBracketRange, bracketPair.closingBracketRange];\n            }\n            return null;\n        }\n        else {\n            // Fallback to old bracket matching code:\n            const continueSearchPredicate = createTimeBasedContinueBracketSearchPredicate(maxDuration);\n            return this._matchBracket(this.textModel.validatePosition(position), continueSearchPredicate);\n        }\n    }\n    _establishBracketSearchOffsets(position, lineTokens, modeBrackets, tokenIndex) {\n        const tokenCount = lineTokens.getCount();\n        const currentLanguageId = lineTokens.getLanguageId(tokenIndex);\n        // limit search to not go before `maxBracketLength`\n        let searchStartOffset = Math.max(0, position.column - 1 - modeBrackets.maxBracketLength);\n        for (let i = tokenIndex - 1; i >= 0; i--) {\n            const tokenEndOffset = lineTokens.getEndOffset(i);\n            if (tokenEndOffset <= searchStartOffset) {\n                break;\n            }\n            if (ignoreBracketsInToken(lineTokens.getStandardTokenType(i)) || lineTokens.getLanguageId(i) !== currentLanguageId) {\n                searchStartOffset = tokenEndOffset;\n                break;\n            }\n        }\n        // limit search to not go after `maxBracketLength`\n        let searchEndOffset = Math.min(lineTokens.getLineContent().length, position.column - 1 + modeBrackets.maxBracketLength);\n        for (let i = tokenIndex + 1; i < tokenCount; i++) {\n            const tokenStartOffset = lineTokens.getStartOffset(i);\n            if (tokenStartOffset >= searchEndOffset) {\n                break;\n            }\n            if (ignoreBracketsInToken(lineTokens.getStandardTokenType(i)) || lineTokens.getLanguageId(i) !== currentLanguageId) {\n                searchEndOffset = tokenStartOffset;\n                break;\n            }\n        }\n        return { searchStartOffset, searchEndOffset };\n    }\n    _matchBracket(position, continueSearchPredicate) {\n        const lineNumber = position.lineNumber;\n        const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n        const lineText = this.textModel.getLineContent(lineNumber);\n        const tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n        if (tokenIndex < 0) {\n            return null;\n        }\n        const currentModeBrackets = this.languageConfigurationService.getLanguageConfiguration(lineTokens.getLanguageId(tokenIndex)).brackets;\n        // check that the token is not to be ignored\n        if (currentModeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex))) {\n            let { searchStartOffset, searchEndOffset } = this._establishBracketSearchOffsets(position, lineTokens, currentModeBrackets, tokenIndex);\n            // it might be the case that [currentTokenStart -> currentTokenEnd] contains multiple brackets\n            // `bestResult` will contain the most right-side result\n            let bestResult = null;\n            while (true) {\n                const foundBracket = BracketsUtils.findNextBracketInRange(currentModeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (!foundBracket) {\n                    // there are no more brackets in this text\n                    break;\n                }\n                // check that we didn't hit a bracket too far away from position\n                if (foundBracket.startColumn <= position.column && position.column <= foundBracket.endColumn) {\n                    const foundBracketText = lineText.substring(foundBracket.startColumn - 1, foundBracket.endColumn - 1).toLowerCase();\n                    const r = this._matchFoundBracket(foundBracket, currentModeBrackets.textIsBracket[foundBracketText], currentModeBrackets.textIsOpenBracket[foundBracketText], continueSearchPredicate);\n                    if (r) {\n                        if (r instanceof BracketSearchCanceled) {\n                            return null;\n                        }\n                        bestResult = r;\n                    }\n                }\n                searchStartOffset = foundBracket.endColumn - 1;\n            }\n            if (bestResult) {\n                return bestResult;\n            }\n        }\n        // If position is in between two tokens, try also looking in the previous token\n        if (tokenIndex > 0 && lineTokens.getStartOffset(tokenIndex) === position.column - 1) {\n            const prevTokenIndex = tokenIndex - 1;\n            const prevModeBrackets = this.languageConfigurationService.getLanguageConfiguration(lineTokens.getLanguageId(prevTokenIndex)).brackets;\n            // check that previous token is not to be ignored\n            if (prevModeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(prevTokenIndex))) {\n                const { searchStartOffset, searchEndOffset } = this._establishBracketSearchOffsets(position, lineTokens, prevModeBrackets, prevTokenIndex);\n                const foundBracket = BracketsUtils.findPrevBracketInRange(prevModeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                // check that we didn't hit a bracket too far away from position\n                if (foundBracket && foundBracket.startColumn <= position.column && position.column <= foundBracket.endColumn) {\n                    const foundBracketText = lineText.substring(foundBracket.startColumn - 1, foundBracket.endColumn - 1).toLowerCase();\n                    const r = this._matchFoundBracket(foundBracket, prevModeBrackets.textIsBracket[foundBracketText], prevModeBrackets.textIsOpenBracket[foundBracketText], continueSearchPredicate);\n                    if (r) {\n                        if (r instanceof BracketSearchCanceled) {\n                            return null;\n                        }\n                        return r;\n                    }\n                }\n            }\n        }\n        return null;\n    }\n    _matchFoundBracket(foundBracket, data, isOpen, continueSearchPredicate) {\n        if (!data) {\n            return null;\n        }\n        const matched = (isOpen\n            ? this._findMatchingBracketDown(data, foundBracket.getEndPosition(), continueSearchPredicate)\n            : this._findMatchingBracketUp(data, foundBracket.getStartPosition(), continueSearchPredicate));\n        if (!matched) {\n            return null;\n        }\n        if (matched instanceof BracketSearchCanceled) {\n            return matched;\n        }\n        return [foundBracket, matched];\n    }\n    _findMatchingBracketUp(bracket, position, continueSearchPredicate) {\n        // console.log('_findMatchingBracketUp: ', 'bracket: ', JSON.stringify(bracket), 'startPosition: ', String(position));\n        const languageId = bracket.languageId;\n        const reversedBracketRegex = bracket.reversedRegex;\n        let count = -1;\n        let totalCallCount = 0;\n        const searchPrevMatchingBracketInRange = (lineNumber, lineText, searchStartOffset, searchEndOffset) => {\n            while (true) {\n                if (continueSearchPredicate && (++totalCallCount) % 100 === 0 && !continueSearchPredicate()) {\n                    return BracketSearchCanceled.INSTANCE;\n                }\n                const r = BracketsUtils.findPrevBracketInRange(reversedBracketRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (!r) {\n                    break;\n                }\n                const hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();\n                if (bracket.isOpen(hitText)) {\n                    count++;\n                }\n                else if (bracket.isClose(hitText)) {\n                    count--;\n                }\n                if (count === 0) {\n                    return r;\n                }\n                searchEndOffset = r.startColumn - 1;\n            }\n            return null;\n        };\n        for (let lineNumber = position.lineNumber; lineNumber >= 1; lineNumber--) {\n            const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n            const tokenCount = lineTokens.getCount();\n            const lineText = this.textModel.getLineContent(lineNumber);\n            let tokenIndex = tokenCount - 1;\n            let searchStartOffset = lineText.length;\n            let searchEndOffset = lineText.length;\n            if (lineNumber === position.lineNumber) {\n                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n                searchStartOffset = position.column - 1;\n                searchEndOffset = position.column - 1;\n            }\n            let prevSearchInToken = true;\n            for (; tokenIndex >= 0; tokenIndex--) {\n                const searchInToken = (lineTokens.getLanguageId(tokenIndex) === languageId && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\n                if (searchInToken) {\n                    // this token should be searched\n                    if (prevSearchInToken) {\n                        // the previous token should be searched, simply extend searchStartOffset\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                    }\n                    else {\n                        // the previous token should not be searched\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                }\n                else {\n                    // this token should not be searched\n                    if (prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = searchPrevMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return r;\n                        }\n                    }\n                }\n                prevSearchInToken = searchInToken;\n            }\n            if (prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                const r = searchPrevMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (r) {\n                    return r;\n                }\n            }\n        }\n        return null;\n    }\n    _findMatchingBracketDown(bracket, position, continueSearchPredicate) {\n        // console.log('_findMatchingBracketDown: ', 'bracket: ', JSON.stringify(bracket), 'startPosition: ', String(position));\n        const languageId = bracket.languageId;\n        const bracketRegex = bracket.forwardRegex;\n        let count = 1;\n        let totalCallCount = 0;\n        const searchNextMatchingBracketInRange = (lineNumber, lineText, searchStartOffset, searchEndOffset) => {\n            while (true) {\n                if (continueSearchPredicate && (++totalCallCount) % 100 === 0 && !continueSearchPredicate()) {\n                    return BracketSearchCanceled.INSTANCE;\n                }\n                const r = BracketsUtils.findNextBracketInRange(bracketRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (!r) {\n                    break;\n                }\n                const hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();\n                if (bracket.isOpen(hitText)) {\n                    count++;\n                }\n                else if (bracket.isClose(hitText)) {\n                    count--;\n                }\n                if (count === 0) {\n                    return r;\n                }\n                searchStartOffset = r.endColumn - 1;\n            }\n            return null;\n        };\n        const lineCount = this.textModel.getLineCount();\n        for (let lineNumber = position.lineNumber; lineNumber <= lineCount; lineNumber++) {\n            const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n            const tokenCount = lineTokens.getCount();\n            const lineText = this.textModel.getLineContent(lineNumber);\n            let tokenIndex = 0;\n            let searchStartOffset = 0;\n            let searchEndOffset = 0;\n            if (lineNumber === position.lineNumber) {\n                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n                searchStartOffset = position.column - 1;\n                searchEndOffset = position.column - 1;\n            }\n            let prevSearchInToken = true;\n            for (; tokenIndex < tokenCount; tokenIndex++) {\n                const searchInToken = (lineTokens.getLanguageId(tokenIndex) === languageId && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\n                if (searchInToken) {\n                    // this token should be searched\n                    if (prevSearchInToken) {\n                        // the previous token should be searched, simply extend searchEndOffset\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                    else {\n                        // the previous token should not be searched\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                }\n                else {\n                    // this token should not be searched\n                    if (prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = searchNextMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return r;\n                        }\n                    }\n                }\n                prevSearchInToken = searchInToken;\n            }\n            if (prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                const r = searchNextMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (r) {\n                    return r;\n                }\n            }\n        }\n        return null;\n    }\n    findPrevBracket(_position) {\n        const position = this.textModel.validatePosition(_position);\n        if (this.canBuildAST) {\n            this.bracketsRequested = true;\n            this.updateBracketPairsTree();\n            return this.bracketPairsTree.value?.object.getFirstBracketBefore(position) || null;\n        }\n        let languageId = null;\n        let modeBrackets = null;\n        let bracketConfig = null;\n        for (let lineNumber = position.lineNumber; lineNumber >= 1; lineNumber--) {\n            const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n            const tokenCount = lineTokens.getCount();\n            const lineText = this.textModel.getLineContent(lineNumber);\n            let tokenIndex = tokenCount - 1;\n            let searchStartOffset = lineText.length;\n            let searchEndOffset = lineText.length;\n            if (lineNumber === position.lineNumber) {\n                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n                searchStartOffset = position.column - 1;\n                searchEndOffset = position.column - 1;\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    languageId = tokenLanguageId;\n                    modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n                    bracketConfig = this.languageConfigurationService.getLanguageConfiguration(languageId).bracketsNew;\n                }\n            }\n            let prevSearchInToken = true;\n            for (; tokenIndex >= 0; tokenIndex--) {\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    // language id change!\n                    if (modeBrackets && bracketConfig && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = BracketsUtils.findPrevBracketInRange(modeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return this._toFoundBracket(bracketConfig, r);\n                        }\n                        prevSearchInToken = false;\n                    }\n                    languageId = tokenLanguageId;\n                    modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n                    bracketConfig = this.languageConfigurationService.getLanguageConfiguration(languageId).bracketsNew;\n                }\n                const searchInToken = (!!modeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\n                if (searchInToken) {\n                    // this token should be searched\n                    if (prevSearchInToken) {\n                        // the previous token should be searched, simply extend searchStartOffset\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                    }\n                    else {\n                        // the previous token should not be searched\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                }\n                else {\n                    // this token should not be searched\n                    if (bracketConfig && modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = BracketsUtils.findPrevBracketInRange(modeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return this._toFoundBracket(bracketConfig, r);\n                        }\n                    }\n                }\n                prevSearchInToken = searchInToken;\n            }\n            if (bracketConfig && modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                const r = BracketsUtils.findPrevBracketInRange(modeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (r) {\n                    return this._toFoundBracket(bracketConfig, r);\n                }\n            }\n        }\n        return null;\n    }\n    findNextBracket(_position) {\n        const position = this.textModel.validatePosition(_position);\n        if (this.canBuildAST) {\n            this.bracketsRequested = true;\n            this.updateBracketPairsTree();\n            return this.bracketPairsTree.value?.object.getFirstBracketAfter(position) || null;\n        }\n        const lineCount = this.textModel.getLineCount();\n        let languageId = null;\n        let modeBrackets = null;\n        let bracketConfig = null;\n        for (let lineNumber = position.lineNumber; lineNumber <= lineCount; lineNumber++) {\n            const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n            const tokenCount = lineTokens.getCount();\n            const lineText = this.textModel.getLineContent(lineNumber);\n            let tokenIndex = 0;\n            let searchStartOffset = 0;\n            let searchEndOffset = 0;\n            if (lineNumber === position.lineNumber) {\n                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n                searchStartOffset = position.column - 1;\n                searchEndOffset = position.column - 1;\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    languageId = tokenLanguageId;\n                    modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n                    bracketConfig = this.languageConfigurationService.getLanguageConfiguration(languageId).bracketsNew;\n                }\n            }\n            let prevSearchInToken = true;\n            for (; tokenIndex < tokenCount; tokenIndex++) {\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    // language id change!\n                    if (bracketConfig && modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return this._toFoundBracket(bracketConfig, r);\n                        }\n                        prevSearchInToken = false;\n                    }\n                    languageId = tokenLanguageId;\n                    modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n                    bracketConfig = this.languageConfigurationService.getLanguageConfiguration(languageId).bracketsNew;\n                }\n                const searchInToken = (!!modeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\n                if (searchInToken) {\n                    // this token should be searched\n                    if (prevSearchInToken) {\n                        // the previous token should be searched, simply extend searchEndOffset\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                    else {\n                        // the previous token should not be searched\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                }\n                else {\n                    // this token should not be searched\n                    if (bracketConfig && modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return this._toFoundBracket(bracketConfig, r);\n                        }\n                    }\n                }\n                prevSearchInToken = searchInToken;\n            }\n            if (bracketConfig && modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                const r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (r) {\n                    return this._toFoundBracket(bracketConfig, r);\n                }\n            }\n        }\n        return null;\n    }\n    findEnclosingBrackets(_position, maxDuration) {\n        const position = this.textModel.validatePosition(_position);\n        if (this.canBuildAST) {\n            const range = Range.fromPositions(position);\n            const bracketPair = this.getBracketPairsInRange(Range.fromPositions(position, position)).findLast((item) => item.closingBracketRange !== undefined && item.range.strictContainsRange(range));\n            if (bracketPair) {\n                return [bracketPair.openingBracketRange, bracketPair.closingBracketRange];\n            }\n            return null;\n        }\n        const continueSearchPredicate = createTimeBasedContinueBracketSearchPredicate(maxDuration);\n        const lineCount = this.textModel.getLineCount();\n        const savedCounts = new Map();\n        let counts = [];\n        const resetCounts = (languageId, modeBrackets) => {\n            if (!savedCounts.has(languageId)) {\n                const tmp = [];\n                for (let i = 0, len = modeBrackets ? modeBrackets.brackets.length : 0; i < len; i++) {\n                    tmp[i] = 0;\n                }\n                savedCounts.set(languageId, tmp);\n            }\n            counts = savedCounts.get(languageId);\n        };\n        let totalCallCount = 0;\n        const searchInRange = (modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset) => {\n            while (true) {\n                if (continueSearchPredicate && (++totalCallCount) % 100 === 0 && !continueSearchPredicate()) {\n                    return BracketSearchCanceled.INSTANCE;\n                }\n                const r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (!r) {\n                    break;\n                }\n                const hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();\n                const bracket = modeBrackets.textIsBracket[hitText];\n                if (bracket) {\n                    if (bracket.isOpen(hitText)) {\n                        counts[bracket.index]++;\n                    }\n                    else if (bracket.isClose(hitText)) {\n                        counts[bracket.index]--;\n                    }\n                    if (counts[bracket.index] === -1) {\n                        return this._matchFoundBracket(r, bracket, false, continueSearchPredicate);\n                    }\n                }\n                searchStartOffset = r.endColumn - 1;\n            }\n            return null;\n        };\n        let languageId = null;\n        let modeBrackets = null;\n        for (let lineNumber = position.lineNumber; lineNumber <= lineCount; lineNumber++) {\n            const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n            const tokenCount = lineTokens.getCount();\n            const lineText = this.textModel.getLineContent(lineNumber);\n            let tokenIndex = 0;\n            let searchStartOffset = 0;\n            let searchEndOffset = 0;\n            if (lineNumber === position.lineNumber) {\n                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n                searchStartOffset = position.column - 1;\n                searchEndOffset = position.column - 1;\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    languageId = tokenLanguageId;\n                    modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n                    resetCounts(languageId, modeBrackets);\n                }\n            }\n            let prevSearchInToken = true;\n            for (; tokenIndex < tokenCount; tokenIndex++) {\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    // language id change!\n                    if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = searchInRange(modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return stripBracketSearchCanceled(r);\n                        }\n                        prevSearchInToken = false;\n                    }\n                    languageId = tokenLanguageId;\n                    modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n                    resetCounts(languageId, modeBrackets);\n                }\n                const searchInToken = (!!modeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\n                if (searchInToken) {\n                    // this token should be searched\n                    if (prevSearchInToken) {\n                        // the previous token should be searched, simply extend searchEndOffset\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                    else {\n                        // the previous token should not be searched\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                }\n                else {\n                    // this token should not be searched\n                    if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = searchInRange(modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return stripBracketSearchCanceled(r);\n                        }\n                    }\n                }\n                prevSearchInToken = searchInToken;\n            }\n            if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                const r = searchInRange(modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (r) {\n                    return stripBracketSearchCanceled(r);\n                }\n            }\n        }\n        return null;\n    }\n    _toFoundBracket(bracketConfig, r) {\n        if (!r) {\n            return null;\n        }\n        let text = this.textModel.getValueInRange(r);\n        text = text.toLowerCase();\n        const bracketInfo = bracketConfig.getBracketInfo(text);\n        if (!bracketInfo) {\n            return null;\n        }\n        return {\n            range: r,\n            bracketInfo\n        };\n    }\n}\nfunction createDisposableRef(object, disposable) {\n    return {\n        object,\n        dispose: () => disposable?.dispose(),\n    };\n}\nfunction createTimeBasedContinueBracketSearchPredicate(maxDuration) {\n    if (typeof maxDuration === 'undefined') {\n        return () => true;\n    }\n    else {\n        const startTime = Date.now();\n        return () => {\n            return (Date.now() - startTime <= maxDuration);\n        };\n    }\n}\nclass BracketSearchCanceled {\n    static { this.INSTANCE = new BracketSearchCanceled(); }\n    constructor() {\n        this._searchCanceledBrand = undefined;\n    }\n}\nfunction stripBracketSearchCanceled(result) {\n    if (result instanceof BracketSearchCanceled) {\n        return null;\n    }\n    return result;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../../../base/common/event.js';\nimport { Disposable } from '../../../../base/common/lifecycle.js';\nimport { Range } from '../../core/range.js';\nimport { editorBracketHighlightingForeground1, editorBracketHighlightingForeground2, editorBracketHighlightingForeground3, editorBracketHighlightingForeground4, editorBracketHighlightingForeground5, editorBracketHighlightingForeground6, editorBracketHighlightingUnexpectedBracketForeground } from '../../core/editorColorRegistry.js';\nimport { registerThemingParticipant } from '../../../../platform/theme/common/themeService.js';\nexport class ColorizedBracketPairsDecorationProvider extends Disposable {\n    constructor(textModel) {\n        super();\n        this.textModel = textModel;\n        this.colorProvider = new ColorProvider();\n        this.onDidChangeEmitter = new Emitter();\n        this.onDidChange = this.onDidChangeEmitter.event;\n        this.colorizationOptions = textModel.getOptions().bracketPairColorizationOptions;\n        this._register(textModel.bracketPairs.onDidChange(e => {\n            this.onDidChangeEmitter.fire();\n        }));\n    }\n    //#region TextModel events\n    handleDidChangeOptions(e) {\n        this.colorizationOptions = this.textModel.getOptions().bracketPairColorizationOptions;\n    }\n    //#endregion\n    getDecorationsInRange(range, ownerId, filterOutValidation, onlyMinimapDecorations) {\n        if (onlyMinimapDecorations) {\n            // Bracket pair colorization decorations are not rendered in the minimap\n            return [];\n        }\n        if (ownerId === undefined) {\n            return [];\n        }\n        if (!this.colorizationOptions.enabled) {\n            return [];\n        }\n        const result = this.textModel.bracketPairs.getBracketsInRange(range, true).map(bracket => ({\n            id: `bracket${bracket.range.toString()}-${bracket.nestingLevel}`,\n            options: {\n                description: 'BracketPairColorization',\n                inlineClassName: this.colorProvider.getInlineClassName(bracket, this.colorizationOptions.independentColorPoolPerBracketType),\n            },\n            ownerId: 0,\n            range: bracket.range,\n        })).toArray();\n        return result;\n    }\n    getAllDecorations(ownerId, filterOutValidation) {\n        if (ownerId === undefined) {\n            return [];\n        }\n        if (!this.colorizationOptions.enabled) {\n            return [];\n        }\n        return this.getDecorationsInRange(new Range(1, 1, this.textModel.getLineCount(), 1), ownerId, filterOutValidation);\n    }\n}\nclass ColorProvider {\n    constructor() {\n        this.unexpectedClosingBracketClassName = 'unexpected-closing-bracket';\n    }\n    getInlineClassName(bracket, independentColorPoolPerBracketType) {\n        if (bracket.isInvalid) {\n            return this.unexpectedClosingBracketClassName;\n        }\n        return this.getInlineClassNameOfLevel(independentColorPoolPerBracketType ? bracket.nestingLevelOfEqualBracketType : bracket.nestingLevel);\n    }\n    getInlineClassNameOfLevel(level) {\n        // To support a dynamic amount of colors up to 6 colors,\n        // we use a number that is a lcm of all numbers from 1 to 6.\n        return `bracket-highlighting-${level % 30}`;\n    }\n}\nregisterThemingParticipant((theme, collector) => {\n    const colors = [\n        editorBracketHighlightingForeground1,\n        editorBracketHighlightingForeground2,\n        editorBracketHighlightingForeground3,\n        editorBracketHighlightingForeground4,\n        editorBracketHighlightingForeground5,\n        editorBracketHighlightingForeground6\n    ];\n    const colorProvider = new ColorProvider();\n    collector.addRule(`.monaco-editor .${colorProvider.unexpectedClosingBracketClassName} { color: ${theme.getColor(editorBracketHighlightingUnexpectedBracketForeground)}; }`);\n    const colorValues = colors\n        .map(c => theme.getColor(c))\n        .filter((c) => !!c)\n        .filter(c => !c.isTransparent());\n    for (let level = 0; level < 30; level++) {\n        const color = colorValues[level % colorValues.length];\n        collector.addRule(`.monaco-editor .${colorProvider.getInlineClassNameOfLevel(level)} { color: ${color}; }`);\n    }\n});\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nclass SpacesDiffResult {\n    constructor() {\n        this.spacesDiff = 0;\n        this.looksLikeAlignment = false;\n    }\n}\n/**\n * Compute the diff in spaces between two line's indentation.\n */\nfunction spacesDiff(a, aLength, b, bLength, result) {\n    result.spacesDiff = 0;\n    result.looksLikeAlignment = false;\n    // This can go both ways (e.g.):\n    //  - a: \"\\t\"\n    //  - b: \"\\t    \"\n    //  => This should count 1 tab and 4 spaces\n    let i;\n    for (i = 0; i < aLength && i < bLength; i++) {\n        const aCharCode = a.charCodeAt(i);\n        const bCharCode = b.charCodeAt(i);\n        if (aCharCode !== bCharCode) {\n            break;\n        }\n    }\n    let aSpacesCnt = 0, aTabsCount = 0;\n    for (let j = i; j < aLength; j++) {\n        const aCharCode = a.charCodeAt(j);\n        if (aCharCode === 32 /* CharCode.Space */) {\n            aSpacesCnt++;\n        }\n        else {\n            aTabsCount++;\n        }\n    }\n    let bSpacesCnt = 0, bTabsCount = 0;\n    for (let j = i; j < bLength; j++) {\n        const bCharCode = b.charCodeAt(j);\n        if (bCharCode === 32 /* CharCode.Space */) {\n            bSpacesCnt++;\n        }\n        else {\n            bTabsCount++;\n        }\n    }\n    if (aSpacesCnt > 0 && aTabsCount > 0) {\n        return;\n    }\n    if (bSpacesCnt > 0 && bTabsCount > 0) {\n        return;\n    }\n    const tabsDiff = Math.abs(aTabsCount - bTabsCount);\n    const spacesDiff = Math.abs(aSpacesCnt - bSpacesCnt);\n    if (tabsDiff === 0) {\n        // check if the indentation difference might be caused by alignment reasons\n        // sometime folks like to align their code, but this should not be used as a hint\n        result.spacesDiff = spacesDiff;\n        if (spacesDiff > 0 && 0 <= bSpacesCnt - 1 && bSpacesCnt - 1 < a.length && bSpacesCnt < b.length) {\n            if (b.charCodeAt(bSpacesCnt) !== 32 /* CharCode.Space */ && a.charCodeAt(bSpacesCnt - 1) === 32 /* CharCode.Space */) {\n                if (a.charCodeAt(a.length - 1) === 44 /* CharCode.Comma */) {\n                    // This looks like an alignment desire: e.g.\n                    // const a = b + c,\n                    //       d = b - c;\n                    result.looksLikeAlignment = true;\n                }\n            }\n        }\n        return;\n    }\n    if (spacesDiff % tabsDiff === 0) {\n        result.spacesDiff = spacesDiff / tabsDiff;\n        return;\n    }\n}\nexport function guessIndentation(source, defaultTabSize, defaultInsertSpaces) {\n    // Look at most at the first 10k lines\n    const linesCount = Math.min(source.getLineCount(), 10000);\n    let linesIndentedWithTabsCount = 0; // number of lines that contain at least one tab in indentation\n    let linesIndentedWithSpacesCount = 0; // number of lines that contain only spaces in indentation\n    let previousLineText = ''; // content of latest line that contained non-whitespace chars\n    let previousLineIndentation = 0; // index at which latest line contained the first non-whitespace char\n    const ALLOWED_TAB_SIZE_GUESSES = [2, 4, 6, 8, 3, 5, 7]; // prefer even guesses for `tabSize`, limit to [2, 8].\n    const MAX_ALLOWED_TAB_SIZE_GUESS = 8; // max(ALLOWED_TAB_SIZE_GUESSES) = 8\n    const spacesDiffCount = [0, 0, 0, 0, 0, 0, 0, 0, 0]; // `tabSize` scores\n    const tmp = new SpacesDiffResult();\n    for (let lineNumber = 1; lineNumber <= linesCount; lineNumber++) {\n        const currentLineLength = source.getLineLength(lineNumber);\n        const currentLineText = source.getLineContent(lineNumber);\n        // if the text buffer is chunk based, so long lines are cons-string, v8 will flattern the string when we check charCode.\n        // checking charCode on chunks directly is cheaper.\n        const useCurrentLineText = (currentLineLength <= 65536);\n        let currentLineHasContent = false; // does `currentLineText` contain non-whitespace chars\n        let currentLineIndentation = 0; // index at which `currentLineText` contains the first non-whitespace char\n        let currentLineSpacesCount = 0; // count of spaces found in `currentLineText` indentation\n        let currentLineTabsCount = 0; // count of tabs found in `currentLineText` indentation\n        for (let j = 0, lenJ = currentLineLength; j < lenJ; j++) {\n            const charCode = (useCurrentLineText ? currentLineText.charCodeAt(j) : source.getLineCharCode(lineNumber, j));\n            if (charCode === 9 /* CharCode.Tab */) {\n                currentLineTabsCount++;\n            }\n            else if (charCode === 32 /* CharCode.Space */) {\n                currentLineSpacesCount++;\n            }\n            else {\n                // Hit non whitespace character on this line\n                currentLineHasContent = true;\n                currentLineIndentation = j;\n                break;\n            }\n        }\n        // Ignore empty or only whitespace lines\n        if (!currentLineHasContent) {\n            continue;\n        }\n        if (currentLineTabsCount > 0) {\n            linesIndentedWithTabsCount++;\n        }\n        else if (currentLineSpacesCount > 1) {\n            linesIndentedWithSpacesCount++;\n        }\n        spacesDiff(previousLineText, previousLineIndentation, currentLineText, currentLineIndentation, tmp);\n        if (tmp.looksLikeAlignment) {\n            // if defaultInsertSpaces === true && the spaces count == tabSize, we may want to count it as valid indentation\n            //\n            // - item1\n            //   - item2\n            //\n            // otherwise skip this line entirely\n            //\n            // const a = 1,\n            //       b = 2;\n            if (!(defaultInsertSpaces && defaultTabSize === tmp.spacesDiff)) {\n                continue;\n            }\n        }\n        const currentSpacesDiff = tmp.spacesDiff;\n        if (currentSpacesDiff <= MAX_ALLOWED_TAB_SIZE_GUESS) {\n            spacesDiffCount[currentSpacesDiff]++;\n        }\n        previousLineText = currentLineText;\n        previousLineIndentation = currentLineIndentation;\n    }\n    let insertSpaces = defaultInsertSpaces;\n    if (linesIndentedWithTabsCount !== linesIndentedWithSpacesCount) {\n        insertSpaces = (linesIndentedWithTabsCount < linesIndentedWithSpacesCount);\n    }\n    let tabSize = defaultTabSize;\n    // Guess tabSize only if inserting spaces...\n    if (insertSpaces) {\n        let tabSizeScore = (insertSpaces ? 0 : 0.1 * linesCount);\n        // console.log(\"score threshold: \" + tabSizeScore);\n        ALLOWED_TAB_SIZE_GUESSES.forEach((possibleTabSize) => {\n            const possibleTabSizeScore = spacesDiffCount[possibleTabSize];\n            if (possibleTabSizeScore > tabSizeScore) {\n                tabSizeScore = possibleTabSizeScore;\n                tabSize = possibleTabSize;\n            }\n        });\n        // Let a tabSize of 2 win even if it is not the maximum\n        // (only in case 4 was guessed)\n        if (tabSize === 4 && spacesDiffCount[4] > 0 && spacesDiffCount[2] > 0 && spacesDiffCount[2] >= spacesDiffCount[4] / 2) {\n            tabSize = 2;\n        }\n    }\n    // console.log('--------------------------');\n    // console.log('linesIndentedWithTabsCount: ' + linesIndentedWithTabsCount + ', linesIndentedWithSpacesCount: ' + linesIndentedWithSpacesCount);\n    // console.log('spacesDiffCount: ' + spacesDiffCount);\n    // console.log('tabSize: ' + tabSize + ', tabSizeScore: ' + tabSizeScore);\n    return {\n        insertSpaces: insertSpaces,\n        tabSize: tabSize\n    };\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport function getNodeColor(node) {\n    return ((node.metadata & 1 /* Constants.ColorMask */) >>> 0 /* Constants.ColorOffset */);\n}\nfunction setNodeColor(node, color) {\n    node.metadata = ((node.metadata & 254 /* Constants.ColorMaskInverse */) | (color << 0 /* Constants.ColorOffset */));\n}\nfunction getNodeIsVisited(node) {\n    return ((node.metadata & 2 /* Constants.IsVisitedMask */) >>> 1 /* Constants.IsVisitedOffset */) === 1;\n}\nfunction setNodeIsVisited(node, value) {\n    node.metadata = ((node.metadata & 253 /* Constants.IsVisitedMaskInverse */) | ((value ? 1 : 0) << 1 /* Constants.IsVisitedOffset */));\n}\nfunction getNodeIsForValidation(node) {\n    return ((node.metadata & 4 /* Constants.IsForValidationMask */) >>> 2 /* Constants.IsForValidationOffset */) === 1;\n}\nfunction setNodeIsForValidation(node, value) {\n    node.metadata = ((node.metadata & 251 /* Constants.IsForValidationMaskInverse */) | ((value ? 1 : 0) << 2 /* Constants.IsForValidationOffset */));\n}\nfunction getNodeIsInGlyphMargin(node) {\n    return ((node.metadata & 64 /* Constants.IsMarginMask */) >>> 6 /* Constants.IsMarginOffset */) === 1;\n}\nfunction setNodeIsInGlyphMargin(node, value) {\n    node.metadata = ((node.metadata & 191 /* Constants.IsMarginMaskInverse */) | ((value ? 1 : 0) << 6 /* Constants.IsMarginOffset */));\n}\nfunction getNodeStickiness(node) {\n    return ((node.metadata & 24 /* Constants.StickinessMask */) >>> 3 /* Constants.StickinessOffset */);\n}\nfunction _setNodeStickiness(node, stickiness) {\n    node.metadata = ((node.metadata & 231 /* Constants.StickinessMaskInverse */) | (stickiness << 3 /* Constants.StickinessOffset */));\n}\nfunction getCollapseOnReplaceEdit(node) {\n    return ((node.metadata & 32 /* Constants.CollapseOnReplaceEditMask */) >>> 5 /* Constants.CollapseOnReplaceEditOffset */) === 1;\n}\nfunction setCollapseOnReplaceEdit(node, value) {\n    node.metadata = ((node.metadata & 223 /* Constants.CollapseOnReplaceEditMaskInverse */) | ((value ? 1 : 0) << 5 /* Constants.CollapseOnReplaceEditOffset */));\n}\nexport class IntervalNode {\n    constructor(id, start, end) {\n        this.metadata = 0;\n        this.parent = this;\n        this.left = this;\n        this.right = this;\n        setNodeColor(this, 1 /* NodeColor.Red */);\n        this.start = start;\n        this.end = end;\n        // FORCE_OVERFLOWING_TEST: this.delta = start;\n        this.delta = 0;\n        this.maxEnd = end;\n        this.id = id;\n        this.ownerId = 0;\n        this.options = null;\n        setNodeIsForValidation(this, false);\n        setNodeIsInGlyphMargin(this, false);\n        _setNodeStickiness(this, 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */);\n        setCollapseOnReplaceEdit(this, false);\n        this.cachedVersionId = 0;\n        this.cachedAbsoluteStart = start;\n        this.cachedAbsoluteEnd = end;\n        this.range = null;\n        setNodeIsVisited(this, false);\n    }\n    reset(versionId, start, end, range) {\n        this.start = start;\n        this.end = end;\n        this.maxEnd = end;\n        this.cachedVersionId = versionId;\n        this.cachedAbsoluteStart = start;\n        this.cachedAbsoluteEnd = end;\n        this.range = range;\n    }\n    setOptions(options) {\n        this.options = options;\n        const className = this.options.className;\n        setNodeIsForValidation(this, (className === \"squiggly-error\" /* ClassName.EditorErrorDecoration */\n            || className === \"squiggly-warning\" /* ClassName.EditorWarningDecoration */\n            || className === \"squiggly-info\" /* ClassName.EditorInfoDecoration */));\n        setNodeIsInGlyphMargin(this, this.options.glyphMarginClassName !== null);\n        _setNodeStickiness(this, this.options.stickiness);\n        setCollapseOnReplaceEdit(this, this.options.collapseOnReplaceEdit);\n    }\n    setCachedOffsets(absoluteStart, absoluteEnd, cachedVersionId) {\n        if (this.cachedVersionId !== cachedVersionId) {\n            this.range = null;\n        }\n        this.cachedVersionId = cachedVersionId;\n        this.cachedAbsoluteStart = absoluteStart;\n        this.cachedAbsoluteEnd = absoluteEnd;\n    }\n    detach() {\n        this.parent = null;\n        this.left = null;\n        this.right = null;\n    }\n}\nexport const SENTINEL = new IntervalNode(null, 0, 0);\nSENTINEL.parent = SENTINEL;\nSENTINEL.left = SENTINEL;\nSENTINEL.right = SENTINEL;\nsetNodeColor(SENTINEL, 0 /* NodeColor.Black */);\nexport class IntervalTree {\n    constructor() {\n        this.root = SENTINEL;\n        this.requestNormalizeDelta = false;\n    }\n    intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations) {\n        if (this.root === SENTINEL) {\n            return [];\n        }\n        return intervalSearch(this, start, end, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n    }\n    search(filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations) {\n        if (this.root === SENTINEL) {\n            return [];\n        }\n        return search(this, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n    }\n    /**\n     * Will not set `cachedAbsoluteStart` nor `cachedAbsoluteEnd` on the returned nodes!\n     */\n    collectNodesFromOwner(ownerId) {\n        return collectNodesFromOwner(this, ownerId);\n    }\n    /**\n     * Will not set `cachedAbsoluteStart` nor `cachedAbsoluteEnd` on the returned nodes!\n     */\n    collectNodesPostOrder() {\n        return collectNodesPostOrder(this);\n    }\n    insert(node) {\n        rbTreeInsert(this, node);\n        this._normalizeDeltaIfNecessary();\n    }\n    delete(node) {\n        rbTreeDelete(this, node);\n        this._normalizeDeltaIfNecessary();\n    }\n    resolveNode(node, cachedVersionId) {\n        const initialNode = node;\n        let delta = 0;\n        while (node !== this.root) {\n            if (node === node.parent.right) {\n                delta += node.parent.delta;\n            }\n            node = node.parent;\n        }\n        const nodeStart = initialNode.start + delta;\n        const nodeEnd = initialNode.end + delta;\n        initialNode.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);\n    }\n    acceptReplace(offset, length, textLength, forceMoveMarkers) {\n        // Our strategy is to remove all directly impacted nodes, and then add them back to the tree.\n        // (1) collect all nodes that are intersecting this edit as nodes of interest\n        const nodesOfInterest = searchForEditing(this, offset, offset + length);\n        // (2) remove all nodes that are intersecting this edit\n        for (let i = 0, len = nodesOfInterest.length; i < len; i++) {\n            const node = nodesOfInterest[i];\n            rbTreeDelete(this, node);\n        }\n        this._normalizeDeltaIfNecessary();\n        // (3) edit all tree nodes except the nodes of interest\n        noOverlapReplace(this, offset, offset + length, textLength);\n        this._normalizeDeltaIfNecessary();\n        // (4) edit the nodes of interest and insert them back in the tree\n        for (let i = 0, len = nodesOfInterest.length; i < len; i++) {\n            const node = nodesOfInterest[i];\n            node.start = node.cachedAbsoluteStart;\n            node.end = node.cachedAbsoluteEnd;\n            nodeAcceptEdit(node, offset, (offset + length), textLength, forceMoveMarkers);\n            node.maxEnd = node.end;\n            rbTreeInsert(this, node);\n        }\n        this._normalizeDeltaIfNecessary();\n    }\n    _normalizeDeltaIfNecessary() {\n        if (!this.requestNormalizeDelta) {\n            return;\n        }\n        this.requestNormalizeDelta = false;\n        normalizeDelta(this);\n    }\n}\n//#region Delta Normalization\nfunction normalizeDelta(T) {\n    let node = T.root;\n    let delta = 0;\n    while (node !== SENTINEL) {\n        if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n            // go left\n            node = node.left;\n            continue;\n        }\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            delta += node.delta;\n            node = node.right;\n            continue;\n        }\n        // handle current node\n        node.start = delta + node.start;\n        node.end = delta + node.end;\n        node.delta = 0;\n        recomputeMaxEnd(node);\n        setNodeIsVisited(node, true);\n        // going up from this node\n        setNodeIsVisited(node.left, false);\n        setNodeIsVisited(node.right, false);\n        if (node === node.parent.right) {\n            delta -= node.parent.delta;\n        }\n        node = node.parent;\n    }\n    setNodeIsVisited(T.root, false);\n}\nfunction adjustMarkerBeforeColumn(markerOffset, markerStickToPreviousCharacter, checkOffset, moveSemantics) {\n    if (markerOffset < checkOffset) {\n        return true;\n    }\n    if (markerOffset > checkOffset) {\n        return false;\n    }\n    if (moveSemantics === 1 /* MarkerMoveSemantics.ForceMove */) {\n        return false;\n    }\n    if (moveSemantics === 2 /* MarkerMoveSemantics.ForceStay */) {\n        return true;\n    }\n    return markerStickToPreviousCharacter;\n}\n/**\n * This is a lot more complicated than strictly necessary to maintain the same behaviour\n * as when decorations were implemented using two markers.\n */\nexport function nodeAcceptEdit(node, start, end, textLength, forceMoveMarkers) {\n    const nodeStickiness = getNodeStickiness(node);\n    const startStickToPreviousCharacter = (nodeStickiness === 0 /* TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */\n        || nodeStickiness === 2 /* TrackedRangeStickiness.GrowsOnlyWhenTypingBefore */);\n    const endStickToPreviousCharacter = (nodeStickiness === 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */\n        || nodeStickiness === 2 /* TrackedRangeStickiness.GrowsOnlyWhenTypingBefore */);\n    const deletingCnt = (end - start);\n    const insertingCnt = textLength;\n    const commonLength = Math.min(deletingCnt, insertingCnt);\n    const nodeStart = node.start;\n    let startDone = false;\n    const nodeEnd = node.end;\n    let endDone = false;\n    if (start <= nodeStart && nodeEnd <= end && getCollapseOnReplaceEdit(node)) {\n        // This edit encompasses the entire decoration range\n        // and the decoration has asked to become collapsed\n        node.start = start;\n        startDone = true;\n        node.end = start;\n        endDone = true;\n    }\n    {\n        const moveSemantics = forceMoveMarkers ? 1 /* MarkerMoveSemantics.ForceMove */ : (deletingCnt > 0 ? 2 /* MarkerMoveSemantics.ForceStay */ : 0 /* MarkerMoveSemantics.MarkerDefined */);\n        if (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, start, moveSemantics)) {\n            startDone = true;\n        }\n        if (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, start, moveSemantics)) {\n            endDone = true;\n        }\n    }\n    if (commonLength > 0 && !forceMoveMarkers) {\n        const moveSemantics = (deletingCnt > insertingCnt ? 2 /* MarkerMoveSemantics.ForceStay */ : 0 /* MarkerMoveSemantics.MarkerDefined */);\n        if (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, start + commonLength, moveSemantics)) {\n            startDone = true;\n        }\n        if (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, start + commonLength, moveSemantics)) {\n            endDone = true;\n        }\n    }\n    {\n        const moveSemantics = forceMoveMarkers ? 1 /* MarkerMoveSemantics.ForceMove */ : 0 /* MarkerMoveSemantics.MarkerDefined */;\n        if (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, end, moveSemantics)) {\n            node.start = start + insertingCnt;\n            startDone = true;\n        }\n        if (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, end, moveSemantics)) {\n            node.end = start + insertingCnt;\n            endDone = true;\n        }\n    }\n    // Finish\n    const deltaColumn = (insertingCnt - deletingCnt);\n    if (!startDone) {\n        node.start = Math.max(0, nodeStart + deltaColumn);\n    }\n    if (!endDone) {\n        node.end = Math.max(0, nodeEnd + deltaColumn);\n    }\n    if (node.start > node.end) {\n        node.end = node.start;\n    }\n}\nfunction searchForEditing(T, start, end) {\n    // https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree\n    // Now, it is known that two intervals A and B overlap only when both\n    // A.low <= B.high and A.high >= B.low. When searching the trees for\n    // nodes overlapping with a given interval, you can immediately skip:\n    //  a) all nodes to the right of nodes whose low value is past the end of the given interval.\n    //  b) all nodes that have their maximum 'high' value below the start of the given interval.\n    let node = T.root;\n    let delta = 0;\n    let nodeMaxEnd = 0;\n    let nodeStart = 0;\n    let nodeEnd = 0;\n    const result = [];\n    let resultLen = 0;\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            if (node === node.parent.right) {\n                delta -= node.parent.delta;\n            }\n            node = node.parent;\n            continue;\n        }\n        if (!getNodeIsVisited(node.left)) {\n            // first time seeing this node\n            nodeMaxEnd = delta + node.maxEnd;\n            if (nodeMaxEnd < start) {\n                // cover case b) from above\n                // there is no need to search this node or its children\n                setNodeIsVisited(node, true);\n                continue;\n            }\n            if (node.left !== SENTINEL) {\n                // go left\n                node = node.left;\n                continue;\n            }\n        }\n        // handle current node\n        nodeStart = delta + node.start;\n        if (nodeStart > end) {\n            // cover case a) from above\n            // there is no need to search this node or its right subtree\n            setNodeIsVisited(node, true);\n            continue;\n        }\n        nodeEnd = delta + node.end;\n        if (nodeEnd >= start) {\n            node.setCachedOffsets(nodeStart, nodeEnd, 0);\n            result[resultLen++] = node;\n        }\n        setNodeIsVisited(node, true);\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            delta += node.delta;\n            node = node.right;\n            continue;\n        }\n    }\n    setNodeIsVisited(T.root, false);\n    return result;\n}\nfunction noOverlapReplace(T, start, end, textLength) {\n    // https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree\n    // Now, it is known that two intervals A and B overlap only when both\n    // A.low <= B.high and A.high >= B.low. When searching the trees for\n    // nodes overlapping with a given interval, you can immediately skip:\n    //  a) all nodes to the right of nodes whose low value is past the end of the given interval.\n    //  b) all nodes that have their maximum 'high' value below the start of the given interval.\n    let node = T.root;\n    let delta = 0;\n    let nodeMaxEnd = 0;\n    let nodeStart = 0;\n    const editDelta = (textLength - (end - start));\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            if (node === node.parent.right) {\n                delta -= node.parent.delta;\n            }\n            recomputeMaxEnd(node);\n            node = node.parent;\n            continue;\n        }\n        if (!getNodeIsVisited(node.left)) {\n            // first time seeing this node\n            nodeMaxEnd = delta + node.maxEnd;\n            if (nodeMaxEnd < start) {\n                // cover case b) from above\n                // there is no need to search this node or its children\n                setNodeIsVisited(node, true);\n                continue;\n            }\n            if (node.left !== SENTINEL) {\n                // go left\n                node = node.left;\n                continue;\n            }\n        }\n        // handle current node\n        nodeStart = delta + node.start;\n        if (nodeStart > end) {\n            node.start += editDelta;\n            node.end += editDelta;\n            node.delta += editDelta;\n            if (node.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || node.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n                T.requestNormalizeDelta = true;\n            }\n            // cover case a) from above\n            // there is no need to search this node or its right subtree\n            setNodeIsVisited(node, true);\n            continue;\n        }\n        setNodeIsVisited(node, true);\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            delta += node.delta;\n            node = node.right;\n            continue;\n        }\n    }\n    setNodeIsVisited(T.root, false);\n}\n//#endregion\n//#region Searching\nfunction collectNodesFromOwner(T, ownerId) {\n    let node = T.root;\n    const result = [];\n    let resultLen = 0;\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            node = node.parent;\n            continue;\n        }\n        if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n            // go left\n            node = node.left;\n            continue;\n        }\n        // handle current node\n        if (node.ownerId === ownerId) {\n            result[resultLen++] = node;\n        }\n        setNodeIsVisited(node, true);\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            node = node.right;\n            continue;\n        }\n    }\n    setNodeIsVisited(T.root, false);\n    return result;\n}\nfunction collectNodesPostOrder(T) {\n    let node = T.root;\n    const result = [];\n    let resultLen = 0;\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            node = node.parent;\n            continue;\n        }\n        if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n            // go left\n            node = node.left;\n            continue;\n        }\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            node = node.right;\n            continue;\n        }\n        // handle current node\n        result[resultLen++] = node;\n        setNodeIsVisited(node, true);\n    }\n    setNodeIsVisited(T.root, false);\n    return result;\n}\nfunction search(T, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations) {\n    let node = T.root;\n    let delta = 0;\n    let nodeStart = 0;\n    let nodeEnd = 0;\n    const result = [];\n    let resultLen = 0;\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            if (node === node.parent.right) {\n                delta -= node.parent.delta;\n            }\n            node = node.parent;\n            continue;\n        }\n        if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n            // go left\n            node = node.left;\n            continue;\n        }\n        // handle current node\n        nodeStart = delta + node.start;\n        nodeEnd = delta + node.end;\n        node.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);\n        let include = true;\n        if (filterOwnerId && node.ownerId && node.ownerId !== filterOwnerId) {\n            include = false;\n        }\n        if (filterOutValidation && getNodeIsForValidation(node)) {\n            include = false;\n        }\n        if (onlyMarginDecorations && !getNodeIsInGlyphMargin(node)) {\n            include = false;\n        }\n        if (include) {\n            result[resultLen++] = node;\n        }\n        setNodeIsVisited(node, true);\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            delta += node.delta;\n            node = node.right;\n            continue;\n        }\n    }\n    setNodeIsVisited(T.root, false);\n    return result;\n}\nfunction intervalSearch(T, intervalStart, intervalEnd, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations) {\n    // https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree\n    // Now, it is known that two intervals A and B overlap only when both\n    // A.low <= B.high and A.high >= B.low. When searching the trees for\n    // nodes overlapping with a given interval, you can immediately skip:\n    //  a) all nodes to the right of nodes whose low value is past the end of the given interval.\n    //  b) all nodes that have their maximum 'high' value below the start of the given interval.\n    let node = T.root;\n    let delta = 0;\n    let nodeMaxEnd = 0;\n    let nodeStart = 0;\n    let nodeEnd = 0;\n    const result = [];\n    let resultLen = 0;\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            if (node === node.parent.right) {\n                delta -= node.parent.delta;\n            }\n            node = node.parent;\n            continue;\n        }\n        if (!getNodeIsVisited(node.left)) {\n            // first time seeing this node\n            nodeMaxEnd = delta + node.maxEnd;\n            if (nodeMaxEnd < intervalStart) {\n                // cover case b) from above\n                // there is no need to search this node or its children\n                setNodeIsVisited(node, true);\n                continue;\n            }\n            if (node.left !== SENTINEL) {\n                // go left\n                node = node.left;\n                continue;\n            }\n        }\n        // handle current node\n        nodeStart = delta + node.start;\n        if (nodeStart > intervalEnd) {\n            // cover case a) from above\n            // there is no need to search this node or its right subtree\n            setNodeIsVisited(node, true);\n            continue;\n        }\n        nodeEnd = delta + node.end;\n        if (nodeEnd >= intervalStart) {\n            // There is overlap\n            node.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);\n            let include = true;\n            if (filterOwnerId && node.ownerId && node.ownerId !== filterOwnerId) {\n                include = false;\n            }\n            if (filterOutValidation && getNodeIsForValidation(node)) {\n                include = false;\n            }\n            if (onlyMarginDecorations && !getNodeIsInGlyphMargin(node)) {\n                include = false;\n            }\n            if (include) {\n                result[resultLen++] = node;\n            }\n        }\n        setNodeIsVisited(node, true);\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            delta += node.delta;\n            node = node.right;\n            continue;\n        }\n    }\n    setNodeIsVisited(T.root, false);\n    return result;\n}\n//#endregion\n//#region Insertion\nfunction rbTreeInsert(T, newNode) {\n    if (T.root === SENTINEL) {\n        newNode.parent = SENTINEL;\n        newNode.left = SENTINEL;\n        newNode.right = SENTINEL;\n        setNodeColor(newNode, 0 /* NodeColor.Black */);\n        T.root = newNode;\n        return T.root;\n    }\n    treeInsert(T, newNode);\n    recomputeMaxEndWalkToRoot(newNode.parent);\n    // repair tree\n    let x = newNode;\n    while (x !== T.root && getNodeColor(x.parent) === 1 /* NodeColor.Red */) {\n        if (x.parent === x.parent.parent.left) {\n            const y = x.parent.parent.right;\n            if (getNodeColor(y) === 1 /* NodeColor.Red */) {\n                setNodeColor(x.parent, 0 /* NodeColor.Black */);\n                setNodeColor(y, 0 /* NodeColor.Black */);\n                setNodeColor(x.parent.parent, 1 /* NodeColor.Red */);\n                x = x.parent.parent;\n            }\n            else {\n                if (x === x.parent.right) {\n                    x = x.parent;\n                    leftRotate(T, x);\n                }\n                setNodeColor(x.parent, 0 /* NodeColor.Black */);\n                setNodeColor(x.parent.parent, 1 /* NodeColor.Red */);\n                rightRotate(T, x.parent.parent);\n            }\n        }\n        else {\n            const y = x.parent.parent.left;\n            if (getNodeColor(y) === 1 /* NodeColor.Red */) {\n                setNodeColor(x.parent, 0 /* NodeColor.Black */);\n                setNodeColor(y, 0 /* NodeColor.Black */);\n                setNodeColor(x.parent.parent, 1 /* NodeColor.Red */);\n                x = x.parent.parent;\n            }\n            else {\n                if (x === x.parent.left) {\n                    x = x.parent;\n                    rightRotate(T, x);\n                }\n                setNodeColor(x.parent, 0 /* NodeColor.Black */);\n                setNodeColor(x.parent.parent, 1 /* NodeColor.Red */);\n                leftRotate(T, x.parent.parent);\n            }\n        }\n    }\n    setNodeColor(T.root, 0 /* NodeColor.Black */);\n    return newNode;\n}\nfunction treeInsert(T, z) {\n    let delta = 0;\n    let x = T.root;\n    const zAbsoluteStart = z.start;\n    const zAbsoluteEnd = z.end;\n    while (true) {\n        const cmp = intervalCompare(zAbsoluteStart, zAbsoluteEnd, x.start + delta, x.end + delta);\n        if (cmp < 0) {\n            // this node should be inserted to the left\n            // => it is not affected by the node's delta\n            if (x.left === SENTINEL) {\n                z.start -= delta;\n                z.end -= delta;\n                z.maxEnd -= delta;\n                x.left = z;\n                break;\n            }\n            else {\n                x = x.left;\n            }\n        }\n        else {\n            // this node should be inserted to the right\n            // => it is not affected by the node's delta\n            if (x.right === SENTINEL) {\n                z.start -= (delta + x.delta);\n                z.end -= (delta + x.delta);\n                z.maxEnd -= (delta + x.delta);\n                x.right = z;\n                break;\n            }\n            else {\n                delta += x.delta;\n                x = x.right;\n            }\n        }\n    }\n    z.parent = x;\n    z.left = SENTINEL;\n    z.right = SENTINEL;\n    setNodeColor(z, 1 /* NodeColor.Red */);\n}\n//#endregion\n//#region Deletion\nfunction rbTreeDelete(T, z) {\n    let x;\n    let y;\n    // RB-DELETE except we don't swap z and y in case c)\n    // i.e. we always delete what's pointed at by z.\n    if (z.left === SENTINEL) {\n        x = z.right;\n        y = z;\n        // x's delta is no longer influenced by z's delta\n        x.delta += z.delta;\n        if (x.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || x.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n            T.requestNormalizeDelta = true;\n        }\n        x.start += z.delta;\n        x.end += z.delta;\n    }\n    else if (z.right === SENTINEL) {\n        x = z.left;\n        y = z;\n    }\n    else {\n        y = leftest(z.right);\n        x = y.right;\n        // y's delta is no longer influenced by z's delta,\n        // but we don't want to walk the entire right-hand-side subtree of x.\n        // we therefore maintain z's delta in y, and adjust only x\n        x.start += y.delta;\n        x.end += y.delta;\n        x.delta += y.delta;\n        if (x.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || x.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n            T.requestNormalizeDelta = true;\n        }\n        y.start += z.delta;\n        y.end += z.delta;\n        y.delta = z.delta;\n        if (y.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || y.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n            T.requestNormalizeDelta = true;\n        }\n    }\n    if (y === T.root) {\n        T.root = x;\n        setNodeColor(x, 0 /* NodeColor.Black */);\n        z.detach();\n        resetSentinel();\n        recomputeMaxEnd(x);\n        T.root.parent = SENTINEL;\n        return;\n    }\n    const yWasRed = (getNodeColor(y) === 1 /* NodeColor.Red */);\n    if (y === y.parent.left) {\n        y.parent.left = x;\n    }\n    else {\n        y.parent.right = x;\n    }\n    if (y === z) {\n        x.parent = y.parent;\n    }\n    else {\n        if (y.parent === z) {\n            x.parent = y;\n        }\n        else {\n            x.parent = y.parent;\n        }\n        y.left = z.left;\n        y.right = z.right;\n        y.parent = z.parent;\n        setNodeColor(y, getNodeColor(z));\n        if (z === T.root) {\n            T.root = y;\n        }\n        else {\n            if (z === z.parent.left) {\n                z.parent.left = y;\n            }\n            else {\n                z.parent.right = y;\n            }\n        }\n        if (y.left !== SENTINEL) {\n            y.left.parent = y;\n        }\n        if (y.right !== SENTINEL) {\n            y.right.parent = y;\n        }\n    }\n    z.detach();\n    if (yWasRed) {\n        recomputeMaxEndWalkToRoot(x.parent);\n        if (y !== z) {\n            recomputeMaxEndWalkToRoot(y);\n            recomputeMaxEndWalkToRoot(y.parent);\n        }\n        resetSentinel();\n        return;\n    }\n    recomputeMaxEndWalkToRoot(x);\n    recomputeMaxEndWalkToRoot(x.parent);\n    if (y !== z) {\n        recomputeMaxEndWalkToRoot(y);\n        recomputeMaxEndWalkToRoot(y.parent);\n    }\n    // RB-DELETE-FIXUP\n    let w;\n    while (x !== T.root && getNodeColor(x) === 0 /* NodeColor.Black */) {\n        if (x === x.parent.left) {\n            w = x.parent.right;\n            if (getNodeColor(w) === 1 /* NodeColor.Red */) {\n                setNodeColor(w, 0 /* NodeColor.Black */);\n                setNodeColor(x.parent, 1 /* NodeColor.Red */);\n                leftRotate(T, x.parent);\n                w = x.parent.right;\n            }\n            if (getNodeColor(w.left) === 0 /* NodeColor.Black */ && getNodeColor(w.right) === 0 /* NodeColor.Black */) {\n                setNodeColor(w, 1 /* NodeColor.Red */);\n                x = x.parent;\n            }\n            else {\n                if (getNodeColor(w.right) === 0 /* NodeColor.Black */) {\n                    setNodeColor(w.left, 0 /* NodeColor.Black */);\n                    setNodeColor(w, 1 /* NodeColor.Red */);\n                    rightRotate(T, w);\n                    w = x.parent.right;\n                }\n                setNodeColor(w, getNodeColor(x.parent));\n                setNodeColor(x.parent, 0 /* NodeColor.Black */);\n                setNodeColor(w.right, 0 /* NodeColor.Black */);\n                leftRotate(T, x.parent);\n                x = T.root;\n            }\n        }\n        else {\n            w = x.parent.left;\n            if (getNodeColor(w) === 1 /* NodeColor.Red */) {\n                setNodeColor(w, 0 /* NodeColor.Black */);\n                setNodeColor(x.parent, 1 /* NodeColor.Red */);\n                rightRotate(T, x.parent);\n                w = x.parent.left;\n            }\n            if (getNodeColor(w.left) === 0 /* NodeColor.Black */ && getNodeColor(w.right) === 0 /* NodeColor.Black */) {\n                setNodeColor(w, 1 /* NodeColor.Red */);\n                x = x.parent;\n            }\n            else {\n                if (getNodeColor(w.left) === 0 /* NodeColor.Black */) {\n                    setNodeColor(w.right, 0 /* NodeColor.Black */);\n                    setNodeColor(w, 1 /* NodeColor.Red */);\n                    leftRotate(T, w);\n                    w = x.parent.left;\n                }\n                setNodeColor(w, getNodeColor(x.parent));\n                setNodeColor(x.parent, 0 /* NodeColor.Black */);\n                setNodeColor(w.left, 0 /* NodeColor.Black */);\n                rightRotate(T, x.parent);\n                x = T.root;\n            }\n        }\n    }\n    setNodeColor(x, 0 /* NodeColor.Black */);\n    resetSentinel();\n}\nfunction leftest(node) {\n    while (node.left !== SENTINEL) {\n        node = node.left;\n    }\n    return node;\n}\nfunction resetSentinel() {\n    SENTINEL.parent = SENTINEL;\n    SENTINEL.delta = 0; // optional\n    SENTINEL.start = 0; // optional\n    SENTINEL.end = 0; // optional\n}\n//#endregion\n//#region Rotations\nfunction leftRotate(T, x) {\n    const y = x.right; // set y.\n    y.delta += x.delta; // y's delta is no longer influenced by x's delta\n    if (y.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || y.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n        T.requestNormalizeDelta = true;\n    }\n    y.start += x.delta;\n    y.end += x.delta;\n    x.right = y.left; // turn y's left subtree into x's right subtree.\n    if (y.left !== SENTINEL) {\n        y.left.parent = x;\n    }\n    y.parent = x.parent; // link x's parent to y.\n    if (x.parent === SENTINEL) {\n        T.root = y;\n    }\n    else if (x === x.parent.left) {\n        x.parent.left = y;\n    }\n    else {\n        x.parent.right = y;\n    }\n    y.left = x; // put x on y's left.\n    x.parent = y;\n    recomputeMaxEnd(x);\n    recomputeMaxEnd(y);\n}\nfunction rightRotate(T, y) {\n    const x = y.left;\n    y.delta -= x.delta;\n    if (y.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || y.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n        T.requestNormalizeDelta = true;\n    }\n    y.start -= x.delta;\n    y.end -= x.delta;\n    y.left = x.right;\n    if (x.right !== SENTINEL) {\n        x.right.parent = y;\n    }\n    x.parent = y.parent;\n    if (y.parent === SENTINEL) {\n        T.root = x;\n    }\n    else if (y === y.parent.right) {\n        y.parent.right = x;\n    }\n    else {\n        y.parent.left = x;\n    }\n    x.right = y;\n    y.parent = x;\n    recomputeMaxEnd(y);\n    recomputeMaxEnd(x);\n}\n//#endregion\n//#region max end computation\nfunction computeMaxEnd(node) {\n    let maxEnd = node.end;\n    if (node.left !== SENTINEL) {\n        const leftMaxEnd = node.left.maxEnd;\n        if (leftMaxEnd > maxEnd) {\n            maxEnd = leftMaxEnd;\n        }\n    }\n    if (node.right !== SENTINEL) {\n        const rightMaxEnd = node.right.maxEnd + node.delta;\n        if (rightMaxEnd > maxEnd) {\n            maxEnd = rightMaxEnd;\n        }\n    }\n    return maxEnd;\n}\nexport function recomputeMaxEnd(node) {\n    node.maxEnd = computeMaxEnd(node);\n}\nfunction recomputeMaxEndWalkToRoot(node) {\n    while (node !== SENTINEL) {\n        const maxEnd = computeMaxEnd(node);\n        if (node.maxEnd === maxEnd) {\n            // no need to go further\n            return;\n        }\n        node.maxEnd = maxEnd;\n        node = node.parent;\n    }\n}\n//#endregion\n//#region utils\nexport function intervalCompare(aStart, aEnd, bStart, bEnd) {\n    if (aStart === bStart) {\n        return aEnd - bEnd;\n    }\n    return aStart - bStart;\n}\n//#endregion\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class TreeNode {\n    constructor(piece, color) {\n        this.piece = piece;\n        this.color = color;\n        this.size_left = 0;\n        this.lf_left = 0;\n        this.parent = this;\n        this.left = this;\n        this.right = this;\n    }\n    next() {\n        if (this.right !== SENTINEL) {\n            return leftest(this.right);\n        }\n        let node = this;\n        while (node.parent !== SENTINEL) {\n            if (node.parent.left === node) {\n                break;\n            }\n            node = node.parent;\n        }\n        if (node.parent === SENTINEL) {\n            return SENTINEL;\n        }\n        else {\n            return node.parent;\n        }\n    }\n    prev() {\n        if (this.left !== SENTINEL) {\n            return righttest(this.left);\n        }\n        let node = this;\n        while (node.parent !== SENTINEL) {\n            if (node.parent.right === node) {\n                break;\n            }\n            node = node.parent;\n        }\n        if (node.parent === SENTINEL) {\n            return SENTINEL;\n        }\n        else {\n            return node.parent;\n        }\n    }\n    detach() {\n        this.parent = null;\n        this.left = null;\n        this.right = null;\n    }\n}\nexport const SENTINEL = new TreeNode(null, 0 /* NodeColor.Black */);\nSENTINEL.parent = SENTINEL;\nSENTINEL.left = SENTINEL;\nSENTINEL.right = SENTINEL;\nSENTINEL.color = 0 /* NodeColor.Black */;\nexport function leftest(node) {\n    while (node.left !== SENTINEL) {\n        node = node.left;\n    }\n    return node;\n}\nexport function righttest(node) {\n    while (node.right !== SENTINEL) {\n        node = node.right;\n    }\n    return node;\n}\nfunction calculateSize(node) {\n    if (node === SENTINEL) {\n        return 0;\n    }\n    return node.size_left + node.piece.length + calculateSize(node.right);\n}\nfunction calculateLF(node) {\n    if (node === SENTINEL) {\n        return 0;\n    }\n    return node.lf_left + node.piece.lineFeedCnt + calculateLF(node.right);\n}\nfunction resetSentinel() {\n    SENTINEL.parent = SENTINEL;\n}\nexport function leftRotate(tree, x) {\n    const y = x.right;\n    // fix size_left\n    y.size_left += x.size_left + (x.piece ? x.piece.length : 0);\n    y.lf_left += x.lf_left + (x.piece ? x.piece.lineFeedCnt : 0);\n    x.right = y.left;\n    if (y.left !== SENTINEL) {\n        y.left.parent = x;\n    }\n    y.parent = x.parent;\n    if (x.parent === SENTINEL) {\n        tree.root = y;\n    }\n    else if (x.parent.left === x) {\n        x.parent.left = y;\n    }\n    else {\n        x.parent.right = y;\n    }\n    y.left = x;\n    x.parent = y;\n}\nexport function rightRotate(tree, y) {\n    const x = y.left;\n    y.left = x.right;\n    if (x.right !== SENTINEL) {\n        x.right.parent = y;\n    }\n    x.parent = y.parent;\n    // fix size_left\n    y.size_left -= x.size_left + (x.piece ? x.piece.length : 0);\n    y.lf_left -= x.lf_left + (x.piece ? x.piece.lineFeedCnt : 0);\n    if (y.parent === SENTINEL) {\n        tree.root = x;\n    }\n    else if (y === y.parent.right) {\n        y.parent.right = x;\n    }\n    else {\n        y.parent.left = x;\n    }\n    x.right = y;\n    y.parent = x;\n}\nexport function rbDelete(tree, z) {\n    let x;\n    let y;\n    if (z.left === SENTINEL) {\n        y = z;\n        x = y.right;\n    }\n    else if (z.right === SENTINEL) {\n        y = z;\n        x = y.left;\n    }\n    else {\n        y = leftest(z.right);\n        x = y.right;\n    }\n    if (y === tree.root) {\n        tree.root = x;\n        // if x is null, we are removing the only node\n        x.color = 0 /* NodeColor.Black */;\n        z.detach();\n        resetSentinel();\n        tree.root.parent = SENTINEL;\n        return;\n    }\n    const yWasRed = (y.color === 1 /* NodeColor.Red */);\n    if (y === y.parent.left) {\n        y.parent.left = x;\n    }\n    else {\n        y.parent.right = x;\n    }\n    if (y === z) {\n        x.parent = y.parent;\n        recomputeTreeMetadata(tree, x);\n    }\n    else {\n        if (y.parent === z) {\n            x.parent = y;\n        }\n        else {\n            x.parent = y.parent;\n        }\n        // as we make changes to x's hierarchy, update size_left of subtree first\n        recomputeTreeMetadata(tree, x);\n        y.left = z.left;\n        y.right = z.right;\n        y.parent = z.parent;\n        y.color = z.color;\n        if (z === tree.root) {\n            tree.root = y;\n        }\n        else {\n            if (z === z.parent.left) {\n                z.parent.left = y;\n            }\n            else {\n                z.parent.right = y;\n            }\n        }\n        if (y.left !== SENTINEL) {\n            y.left.parent = y;\n        }\n        if (y.right !== SENTINEL) {\n            y.right.parent = y;\n        }\n        // update metadata\n        // we replace z with y, so in this sub tree, the length change is z.item.length\n        y.size_left = z.size_left;\n        y.lf_left = z.lf_left;\n        recomputeTreeMetadata(tree, y);\n    }\n    z.detach();\n    if (x.parent.left === x) {\n        const newSizeLeft = calculateSize(x);\n        const newLFLeft = calculateLF(x);\n        if (newSizeLeft !== x.parent.size_left || newLFLeft !== x.parent.lf_left) {\n            const delta = newSizeLeft - x.parent.size_left;\n            const lf_delta = newLFLeft - x.parent.lf_left;\n            x.parent.size_left = newSizeLeft;\n            x.parent.lf_left = newLFLeft;\n            updateTreeMetadata(tree, x.parent, delta, lf_delta);\n        }\n    }\n    recomputeTreeMetadata(tree, x.parent);\n    if (yWasRed) {\n        resetSentinel();\n        return;\n    }\n    // RB-DELETE-FIXUP\n    let w;\n    while (x !== tree.root && x.color === 0 /* NodeColor.Black */) {\n        if (x === x.parent.left) {\n            w = x.parent.right;\n            if (w.color === 1 /* NodeColor.Red */) {\n                w.color = 0 /* NodeColor.Black */;\n                x.parent.color = 1 /* NodeColor.Red */;\n                leftRotate(tree, x.parent);\n                w = x.parent.right;\n            }\n            if (w.left.color === 0 /* NodeColor.Black */ && w.right.color === 0 /* NodeColor.Black */) {\n                w.color = 1 /* NodeColor.Red */;\n                x = x.parent;\n            }\n            else {\n                if (w.right.color === 0 /* NodeColor.Black */) {\n                    w.left.color = 0 /* NodeColor.Black */;\n                    w.color = 1 /* NodeColor.Red */;\n                    rightRotate(tree, w);\n                    w = x.parent.right;\n                }\n                w.color = x.parent.color;\n                x.parent.color = 0 /* NodeColor.Black */;\n                w.right.color = 0 /* NodeColor.Black */;\n                leftRotate(tree, x.parent);\n                x = tree.root;\n            }\n        }\n        else {\n            w = x.parent.left;\n            if (w.color === 1 /* NodeColor.Red */) {\n                w.color = 0 /* NodeColor.Black */;\n                x.parent.color = 1 /* NodeColor.Red */;\n                rightRotate(tree, x.parent);\n                w = x.parent.left;\n            }\n            if (w.left.color === 0 /* NodeColor.Black */ && w.right.color === 0 /* NodeColor.Black */) {\n                w.color = 1 /* NodeColor.Red */;\n                x = x.parent;\n            }\n            else {\n                if (w.left.color === 0 /* NodeColor.Black */) {\n                    w.right.color = 0 /* NodeColor.Black */;\n                    w.color = 1 /* NodeColor.Red */;\n                    leftRotate(tree, w);\n                    w = x.parent.left;\n                }\n                w.color = x.parent.color;\n                x.parent.color = 0 /* NodeColor.Black */;\n                w.left.color = 0 /* NodeColor.Black */;\n                rightRotate(tree, x.parent);\n                x = tree.root;\n            }\n        }\n    }\n    x.color = 0 /* NodeColor.Black */;\n    resetSentinel();\n}\nexport function fixInsert(tree, x) {\n    recomputeTreeMetadata(tree, x);\n    while (x !== tree.root && x.parent.color === 1 /* NodeColor.Red */) {\n        if (x.parent === x.parent.parent.left) {\n            const y = x.parent.parent.right;\n            if (y.color === 1 /* NodeColor.Red */) {\n                x.parent.color = 0 /* NodeColor.Black */;\n                y.color = 0 /* NodeColor.Black */;\n                x.parent.parent.color = 1 /* NodeColor.Red */;\n                x = x.parent.parent;\n            }\n            else {\n                if (x === x.parent.right) {\n                    x = x.parent;\n                    leftRotate(tree, x);\n                }\n                x.parent.color = 0 /* NodeColor.Black */;\n                x.parent.parent.color = 1 /* NodeColor.Red */;\n                rightRotate(tree, x.parent.parent);\n            }\n        }\n        else {\n            const y = x.parent.parent.left;\n            if (y.color === 1 /* NodeColor.Red */) {\n                x.parent.color = 0 /* NodeColor.Black */;\n                y.color = 0 /* NodeColor.Black */;\n                x.parent.parent.color = 1 /* NodeColor.Red */;\n                x = x.parent.parent;\n            }\n            else {\n                if (x === x.parent.left) {\n                    x = x.parent;\n                    rightRotate(tree, x);\n                }\n                x.parent.color = 0 /* NodeColor.Black */;\n                x.parent.parent.color = 1 /* NodeColor.Red */;\n                leftRotate(tree, x.parent.parent);\n            }\n        }\n    }\n    tree.root.color = 0 /* NodeColor.Black */;\n}\nexport function updateTreeMetadata(tree, x, delta, lineFeedCntDelta) {\n    // node length change or line feed count change\n    while (x !== tree.root && x !== SENTINEL) {\n        if (x.parent.left === x) {\n            x.parent.size_left += delta;\n            x.parent.lf_left += lineFeedCntDelta;\n        }\n        x = x.parent;\n    }\n}\nexport function recomputeTreeMetadata(tree, x) {\n    let delta = 0;\n    let lf_delta = 0;\n    if (x === tree.root) {\n        return;\n    }\n    // go upwards till the node whose left subtree is changed.\n    while (x !== tree.root && x === x.parent.right) {\n        x = x.parent;\n    }\n    if (x === tree.root) {\n        // well, it means we add a node to the end (inorder)\n        return;\n    }\n    // x is the node whose right subtree is changed.\n    x = x.parent;\n    delta = calculateSize(x.left) - x.size_left;\n    lf_delta = calculateLF(x.left) - x.lf_left;\n    x.size_left += delta;\n    x.lf_left += lf_delta;\n    // go upwards till root. O(logN)\n    while (x !== tree.root && (delta !== 0 || lf_delta !== 0)) {\n        if (x.parent.left === x) {\n            x.parent.size_left += delta;\n            x.parent.lf_left += lf_delta;\n        }\n        x = x.parent;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Position } from '../../core/position.js';\nimport { Range } from '../../core/range.js';\nimport { FindMatch } from '../../model.js';\nimport { SENTINEL, TreeNode, fixInsert, leftest, rbDelete, righttest, updateTreeMetadata } from './rbTreeBase.js';\nimport { Searcher, createFindMatch, isValidMatch } from '../textModelSearch.js';\n// const lfRegex = new RegExp(/\\r\\n|\\r|\\n/g);\nconst AverageBufferSize = 65535;\nfunction createUintArray(arr) {\n    let r;\n    if (arr[arr.length - 1] < 65536) {\n        r = new Uint16Array(arr.length);\n    }\n    else {\n        r = new Uint32Array(arr.length);\n    }\n    r.set(arr, 0);\n    return r;\n}\nclass LineStarts {\n    constructor(lineStarts, cr, lf, crlf, isBasicASCII) {\n        this.lineStarts = lineStarts;\n        this.cr = cr;\n        this.lf = lf;\n        this.crlf = crlf;\n        this.isBasicASCII = isBasicASCII;\n    }\n}\nexport function createLineStartsFast(str, readonly = true) {\n    const r = [0];\n    let rLength = 1;\n    for (let i = 0, len = str.length; i < len; i++) {\n        const chr = str.charCodeAt(i);\n        if (chr === 13 /* CharCode.CarriageReturn */) {\n            if (i + 1 < len && str.charCodeAt(i + 1) === 10 /* CharCode.LineFeed */) {\n                // \\r\\n... case\n                r[rLength++] = i + 2;\n                i++; // skip \\n\n            }\n            else {\n                // \\r... case\n                r[rLength++] = i + 1;\n            }\n        }\n        else if (chr === 10 /* CharCode.LineFeed */) {\n            r[rLength++] = i + 1;\n        }\n    }\n    if (readonly) {\n        return createUintArray(r);\n    }\n    else {\n        return r;\n    }\n}\nexport function createLineStarts(r, str) {\n    r.length = 0;\n    r[0] = 0;\n    let rLength = 1;\n    let cr = 0, lf = 0, crlf = 0;\n    let isBasicASCII = true;\n    for (let i = 0, len = str.length; i < len; i++) {\n        const chr = str.charCodeAt(i);\n        if (chr === 13 /* CharCode.CarriageReturn */) {\n            if (i + 1 < len && str.charCodeAt(i + 1) === 10 /* CharCode.LineFeed */) {\n                // \\r\\n... case\n                crlf++;\n                r[rLength++] = i + 2;\n                i++; // skip \\n\n            }\n            else {\n                cr++;\n                // \\r... case\n                r[rLength++] = i + 1;\n            }\n        }\n        else if (chr === 10 /* CharCode.LineFeed */) {\n            lf++;\n            r[rLength++] = i + 1;\n        }\n        else {\n            if (isBasicASCII) {\n                if (chr !== 9 /* CharCode.Tab */ && (chr < 32 || chr > 126)) {\n                    isBasicASCII = false;\n                }\n            }\n        }\n    }\n    const result = new LineStarts(createUintArray(r), cr, lf, crlf, isBasicASCII);\n    r.length = 0;\n    return result;\n}\nexport class Piece {\n    constructor(bufferIndex, start, end, lineFeedCnt, length) {\n        this.bufferIndex = bufferIndex;\n        this.start = start;\n        this.end = end;\n        this.lineFeedCnt = lineFeedCnt;\n        this.length = length;\n    }\n}\nexport class StringBuffer {\n    constructor(buffer, lineStarts) {\n        this.buffer = buffer;\n        this.lineStarts = lineStarts;\n    }\n}\n/**\n * Readonly snapshot for piece tree.\n * In a real multiple thread environment, to make snapshot reading always work correctly, we need to\n * 1. Make TreeNode.piece immutable, then reading and writing can run in parallel.\n * 2. TreeNode/Buffers normalization should not happen during snapshot reading.\n */\nclass PieceTreeSnapshot {\n    constructor(tree, BOM) {\n        this._pieces = [];\n        this._tree = tree;\n        this._BOM = BOM;\n        this._index = 0;\n        if (tree.root !== SENTINEL) {\n            tree.iterate(tree.root, node => {\n                if (node !== SENTINEL) {\n                    this._pieces.push(node.piece);\n                }\n                return true;\n            });\n        }\n    }\n    read() {\n        if (this._pieces.length === 0) {\n            if (this._index === 0) {\n                this._index++;\n                return this._BOM;\n            }\n            else {\n                return null;\n            }\n        }\n        if (this._index > this._pieces.length - 1) {\n            return null;\n        }\n        if (this._index === 0) {\n            return this._BOM + this._tree.getPieceContent(this._pieces[this._index++]);\n        }\n        return this._tree.getPieceContent(this._pieces[this._index++]);\n    }\n}\nclass PieceTreeSearchCache {\n    constructor(limit) {\n        this._limit = limit;\n        this._cache = [];\n    }\n    get(offset) {\n        for (let i = this._cache.length - 1; i >= 0; i--) {\n            const nodePos = this._cache[i];\n            if (nodePos.nodeStartOffset <= offset && nodePos.nodeStartOffset + nodePos.node.piece.length >= offset) {\n                return nodePos;\n            }\n        }\n        return null;\n    }\n    get2(lineNumber) {\n        for (let i = this._cache.length - 1; i >= 0; i--) {\n            const nodePos = this._cache[i];\n            if (nodePos.nodeStartLineNumber && nodePos.nodeStartLineNumber < lineNumber && nodePos.nodeStartLineNumber + nodePos.node.piece.lineFeedCnt >= lineNumber) {\n                return nodePos;\n            }\n        }\n        return null;\n    }\n    set(nodePosition) {\n        if (this._cache.length >= this._limit) {\n            this._cache.shift();\n        }\n        this._cache.push(nodePosition);\n    }\n    validate(offset) {\n        let hasInvalidVal = false;\n        const tmp = this._cache;\n        for (let i = 0; i < tmp.length; i++) {\n            const nodePos = tmp[i];\n            if (nodePos.node.parent === null || nodePos.nodeStartOffset >= offset) {\n                tmp[i] = null;\n                hasInvalidVal = true;\n                continue;\n            }\n        }\n        if (hasInvalidVal) {\n            const newArr = [];\n            for (const entry of tmp) {\n                if (entry !== null) {\n                    newArr.push(entry);\n                }\n            }\n            this._cache = newArr;\n        }\n    }\n}\nexport class PieceTreeBase {\n    constructor(chunks, eol, eolNormalized) {\n        this.create(chunks, eol, eolNormalized);\n    }\n    create(chunks, eol, eolNormalized) {\n        this._buffers = [\n            new StringBuffer('', [0])\n        ];\n        this._lastChangeBufferPos = { line: 0, column: 0 };\n        this.root = SENTINEL;\n        this._lineCnt = 1;\n        this._length = 0;\n        this._EOL = eol;\n        this._EOLLength = eol.length;\n        this._EOLNormalized = eolNormalized;\n        let lastNode = null;\n        for (let i = 0, len = chunks.length; i < len; i++) {\n            if (chunks[i].buffer.length > 0) {\n                if (!chunks[i].lineStarts) {\n                    chunks[i].lineStarts = createLineStartsFast(chunks[i].buffer);\n                }\n                const piece = new Piece(i + 1, { line: 0, column: 0 }, { line: chunks[i].lineStarts.length - 1, column: chunks[i].buffer.length - chunks[i].lineStarts[chunks[i].lineStarts.length - 1] }, chunks[i].lineStarts.length - 1, chunks[i].buffer.length);\n                this._buffers.push(chunks[i]);\n                lastNode = this.rbInsertRight(lastNode, piece);\n            }\n        }\n        this._searchCache = new PieceTreeSearchCache(1);\n        this._lastVisitedLine = { lineNumber: 0, value: '' };\n        this.computeBufferMetadata();\n    }\n    normalizeEOL(eol) {\n        const averageBufferSize = AverageBufferSize;\n        const min = averageBufferSize - Math.floor(averageBufferSize / 3);\n        const max = min * 2;\n        let tempChunk = '';\n        let tempChunkLen = 0;\n        const chunks = [];\n        this.iterate(this.root, node => {\n            const str = this.getNodeContent(node);\n            const len = str.length;\n            if (tempChunkLen <= min || tempChunkLen + len < max) {\n                tempChunk += str;\n                tempChunkLen += len;\n                return true;\n            }\n            // flush anyways\n            const text = tempChunk.replace(/\\r\\n|\\r|\\n/g, eol);\n            chunks.push(new StringBuffer(text, createLineStartsFast(text)));\n            tempChunk = str;\n            tempChunkLen = len;\n            return true;\n        });\n        if (tempChunkLen > 0) {\n            const text = tempChunk.replace(/\\r\\n|\\r|\\n/g, eol);\n            chunks.push(new StringBuffer(text, createLineStartsFast(text)));\n        }\n        this.create(chunks, eol, true);\n    }\n    // #region Buffer API\n    getEOL() {\n        return this._EOL;\n    }\n    setEOL(newEOL) {\n        this._EOL = newEOL;\n        this._EOLLength = this._EOL.length;\n        this.normalizeEOL(newEOL);\n    }\n    createSnapshot(BOM) {\n        return new PieceTreeSnapshot(this, BOM);\n    }\n    getOffsetAt(lineNumber, column) {\n        let leftLen = 0; // inorder\n        let x = this.root;\n        while (x !== SENTINEL) {\n            if (x.left !== SENTINEL && x.lf_left + 1 >= lineNumber) {\n                x = x.left;\n            }\n            else if (x.lf_left + x.piece.lineFeedCnt + 1 >= lineNumber) {\n                leftLen += x.size_left;\n                // lineNumber >= 2\n                const accumualtedValInCurrentIndex = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n                return leftLen += accumualtedValInCurrentIndex + column - 1;\n            }\n            else {\n                lineNumber -= x.lf_left + x.piece.lineFeedCnt;\n                leftLen += x.size_left + x.piece.length;\n                x = x.right;\n            }\n        }\n        return leftLen;\n    }\n    getPositionAt(offset) {\n        offset = Math.floor(offset);\n        offset = Math.max(0, offset);\n        let x = this.root;\n        let lfCnt = 0;\n        const originalOffset = offset;\n        while (x !== SENTINEL) {\n            if (x.size_left !== 0 && x.size_left >= offset) {\n                x = x.left;\n            }\n            else if (x.size_left + x.piece.length >= offset) {\n                const out = this.getIndexOf(x, offset - x.size_left);\n                lfCnt += x.lf_left + out.index;\n                if (out.index === 0) {\n                    const lineStartOffset = this.getOffsetAt(lfCnt + 1, 1);\n                    const column = originalOffset - lineStartOffset;\n                    return new Position(lfCnt + 1, column + 1);\n                }\n                return new Position(lfCnt + 1, out.remainder + 1);\n            }\n            else {\n                offset -= x.size_left + x.piece.length;\n                lfCnt += x.lf_left + x.piece.lineFeedCnt;\n                if (x.right === SENTINEL) {\n                    // last node\n                    const lineStartOffset = this.getOffsetAt(lfCnt + 1, 1);\n                    const column = originalOffset - offset - lineStartOffset;\n                    return new Position(lfCnt + 1, column + 1);\n                }\n                else {\n                    x = x.right;\n                }\n            }\n        }\n        return new Position(1, 1);\n    }\n    getValueInRange(range, eol) {\n        if (range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn) {\n            return '';\n        }\n        const startPosition = this.nodeAt2(range.startLineNumber, range.startColumn);\n        const endPosition = this.nodeAt2(range.endLineNumber, range.endColumn);\n        const value = this.getValueInRange2(startPosition, endPosition);\n        if (eol) {\n            if (eol !== this._EOL || !this._EOLNormalized) {\n                return value.replace(/\\r\\n|\\r|\\n/g, eol);\n            }\n            if (eol === this.getEOL() && this._EOLNormalized) {\n                if (eol === '\\r\\n') {\n                }\n                return value;\n            }\n            return value.replace(/\\r\\n|\\r|\\n/g, eol);\n        }\n        return value;\n    }\n    getValueInRange2(startPosition, endPosition) {\n        if (startPosition.node === endPosition.node) {\n            const node = startPosition.node;\n            const buffer = this._buffers[node.piece.bufferIndex].buffer;\n            const startOffset = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start);\n            return buffer.substring(startOffset + startPosition.remainder, startOffset + endPosition.remainder);\n        }\n        let x = startPosition.node;\n        const buffer = this._buffers[x.piece.bufferIndex].buffer;\n        const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n        let ret = buffer.substring(startOffset + startPosition.remainder, startOffset + x.piece.length);\n        x = x.next();\n        while (x !== SENTINEL) {\n            const buffer = this._buffers[x.piece.bufferIndex].buffer;\n            const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n            if (x === endPosition.node) {\n                ret += buffer.substring(startOffset, startOffset + endPosition.remainder);\n                break;\n            }\n            else {\n                ret += buffer.substr(startOffset, x.piece.length);\n            }\n            x = x.next();\n        }\n        return ret;\n    }\n    getLinesContent() {\n        const lines = [];\n        let linesLength = 0;\n        let currentLine = '';\n        let danglingCR = false;\n        this.iterate(this.root, node => {\n            if (node === SENTINEL) {\n                return true;\n            }\n            const piece = node.piece;\n            let pieceLength = piece.length;\n            if (pieceLength === 0) {\n                return true;\n            }\n            const buffer = this._buffers[piece.bufferIndex].buffer;\n            const lineStarts = this._buffers[piece.bufferIndex].lineStarts;\n            const pieceStartLine = piece.start.line;\n            const pieceEndLine = piece.end.line;\n            let pieceStartOffset = lineStarts[pieceStartLine] + piece.start.column;\n            if (danglingCR) {\n                if (buffer.charCodeAt(pieceStartOffset) === 10 /* CharCode.LineFeed */) {\n                    // pretend the \\n was in the previous piece..\n                    pieceStartOffset++;\n                    pieceLength--;\n                }\n                lines[linesLength++] = currentLine;\n                currentLine = '';\n                danglingCR = false;\n                if (pieceLength === 0) {\n                    return true;\n                }\n            }\n            if (pieceStartLine === pieceEndLine) {\n                // this piece has no new lines\n                if (!this._EOLNormalized && buffer.charCodeAt(pieceStartOffset + pieceLength - 1) === 13 /* CharCode.CarriageReturn */) {\n                    danglingCR = true;\n                    currentLine += buffer.substr(pieceStartOffset, pieceLength - 1);\n                }\n                else {\n                    currentLine += buffer.substr(pieceStartOffset, pieceLength);\n                }\n                return true;\n            }\n            // add the text before the first line start in this piece\n            currentLine += (this._EOLNormalized\n                ? buffer.substring(pieceStartOffset, Math.max(pieceStartOffset, lineStarts[pieceStartLine + 1] - this._EOLLength))\n                : buffer.substring(pieceStartOffset, lineStarts[pieceStartLine + 1]).replace(/(\\r\\n|\\r|\\n)$/, ''));\n            lines[linesLength++] = currentLine;\n            for (let line = pieceStartLine + 1; line < pieceEndLine; line++) {\n                currentLine = (this._EOLNormalized\n                    ? buffer.substring(lineStarts[line], lineStarts[line + 1] - this._EOLLength)\n                    : buffer.substring(lineStarts[line], lineStarts[line + 1]).replace(/(\\r\\n|\\r|\\n)$/, ''));\n                lines[linesLength++] = currentLine;\n            }\n            if (!this._EOLNormalized && buffer.charCodeAt(lineStarts[pieceEndLine] + piece.end.column - 1) === 13 /* CharCode.CarriageReturn */) {\n                danglingCR = true;\n                if (piece.end.column === 0) {\n                    // The last line ended with a \\r, let's undo the push, it will be pushed by next iteration\n                    linesLength--;\n                }\n                else {\n                    currentLine = buffer.substr(lineStarts[pieceEndLine], piece.end.column - 1);\n                }\n            }\n            else {\n                currentLine = buffer.substr(lineStarts[pieceEndLine], piece.end.column);\n            }\n            return true;\n        });\n        if (danglingCR) {\n            lines[linesLength++] = currentLine;\n            currentLine = '';\n        }\n        lines[linesLength++] = currentLine;\n        return lines;\n    }\n    getLength() {\n        return this._length;\n    }\n    getLineCount() {\n        return this._lineCnt;\n    }\n    getLineContent(lineNumber) {\n        if (this._lastVisitedLine.lineNumber === lineNumber) {\n            return this._lastVisitedLine.value;\n        }\n        this._lastVisitedLine.lineNumber = lineNumber;\n        if (lineNumber === this._lineCnt) {\n            this._lastVisitedLine.value = this.getLineRawContent(lineNumber);\n        }\n        else if (this._EOLNormalized) {\n            this._lastVisitedLine.value = this.getLineRawContent(lineNumber, this._EOLLength);\n        }\n        else {\n            this._lastVisitedLine.value = this.getLineRawContent(lineNumber).replace(/(\\r\\n|\\r|\\n)$/, '');\n        }\n        return this._lastVisitedLine.value;\n    }\n    _getCharCode(nodePos) {\n        if (nodePos.remainder === nodePos.node.piece.length) {\n            // the char we want to fetch is at the head of next node.\n            const matchingNode = nodePos.node.next();\n            if (!matchingNode) {\n                return 0;\n            }\n            const buffer = this._buffers[matchingNode.piece.bufferIndex];\n            const startOffset = this.offsetInBuffer(matchingNode.piece.bufferIndex, matchingNode.piece.start);\n            return buffer.buffer.charCodeAt(startOffset);\n        }\n        else {\n            const buffer = this._buffers[nodePos.node.piece.bufferIndex];\n            const startOffset = this.offsetInBuffer(nodePos.node.piece.bufferIndex, nodePos.node.piece.start);\n            const targetOffset = startOffset + nodePos.remainder;\n            return buffer.buffer.charCodeAt(targetOffset);\n        }\n    }\n    getLineCharCode(lineNumber, index) {\n        const nodePos = this.nodeAt2(lineNumber, index + 1);\n        return this._getCharCode(nodePos);\n    }\n    getLineLength(lineNumber) {\n        if (lineNumber === this.getLineCount()) {\n            const startOffset = this.getOffsetAt(lineNumber, 1);\n            return this.getLength() - startOffset;\n        }\n        return this.getOffsetAt(lineNumber + 1, 1) - this.getOffsetAt(lineNumber, 1) - this._EOLLength;\n    }\n    findMatchesInNode(node, searcher, startLineNumber, startColumn, startCursor, endCursor, searchData, captureMatches, limitResultCount, resultLen, result) {\n        const buffer = this._buffers[node.piece.bufferIndex];\n        const startOffsetInBuffer = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start);\n        const start = this.offsetInBuffer(node.piece.bufferIndex, startCursor);\n        const end = this.offsetInBuffer(node.piece.bufferIndex, endCursor);\n        let m;\n        // Reset regex to search from the beginning\n        const ret = { line: 0, column: 0 };\n        let searchText;\n        let offsetInBuffer;\n        if (searcher._wordSeparators) {\n            searchText = buffer.buffer.substring(start, end);\n            offsetInBuffer = (offset) => offset + start;\n            searcher.reset(0);\n        }\n        else {\n            searchText = buffer.buffer;\n            offsetInBuffer = (offset) => offset;\n            searcher.reset(start);\n        }\n        do {\n            m = searcher.next(searchText);\n            if (m) {\n                if (offsetInBuffer(m.index) >= end) {\n                    return resultLen;\n                }\n                this.positionInBuffer(node, offsetInBuffer(m.index) - startOffsetInBuffer, ret);\n                const lineFeedCnt = this.getLineFeedCnt(node.piece.bufferIndex, startCursor, ret);\n                const retStartColumn = ret.line === startCursor.line ? ret.column - startCursor.column + startColumn : ret.column + 1;\n                const retEndColumn = retStartColumn + m[0].length;\n                result[resultLen++] = createFindMatch(new Range(startLineNumber + lineFeedCnt, retStartColumn, startLineNumber + lineFeedCnt, retEndColumn), m, captureMatches);\n                if (offsetInBuffer(m.index) + m[0].length >= end) {\n                    return resultLen;\n                }\n                if (resultLen >= limitResultCount) {\n                    return resultLen;\n                }\n            }\n        } while (m);\n        return resultLen;\n    }\n    findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount) {\n        const result = [];\n        let resultLen = 0;\n        const searcher = new Searcher(searchData.wordSeparators, searchData.regex);\n        let startPosition = this.nodeAt2(searchRange.startLineNumber, searchRange.startColumn);\n        if (startPosition === null) {\n            return [];\n        }\n        const endPosition = this.nodeAt2(searchRange.endLineNumber, searchRange.endColumn);\n        if (endPosition === null) {\n            return [];\n        }\n        let start = this.positionInBuffer(startPosition.node, startPosition.remainder);\n        const end = this.positionInBuffer(endPosition.node, endPosition.remainder);\n        if (startPosition.node === endPosition.node) {\n            this.findMatchesInNode(startPosition.node, searcher, searchRange.startLineNumber, searchRange.startColumn, start, end, searchData, captureMatches, limitResultCount, resultLen, result);\n            return result;\n        }\n        let startLineNumber = searchRange.startLineNumber;\n        let currentNode = startPosition.node;\n        while (currentNode !== endPosition.node) {\n            const lineBreakCnt = this.getLineFeedCnt(currentNode.piece.bufferIndex, start, currentNode.piece.end);\n            if (lineBreakCnt >= 1) {\n                // last line break position\n                const lineStarts = this._buffers[currentNode.piece.bufferIndex].lineStarts;\n                const startOffsetInBuffer = this.offsetInBuffer(currentNode.piece.bufferIndex, currentNode.piece.start);\n                const nextLineStartOffset = lineStarts[start.line + lineBreakCnt];\n                const startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn : 1;\n                resultLen = this.findMatchesInNode(currentNode, searcher, startLineNumber, startColumn, start, this.positionInBuffer(currentNode, nextLineStartOffset - startOffsetInBuffer), searchData, captureMatches, limitResultCount, resultLen, result);\n                if (resultLen >= limitResultCount) {\n                    return result;\n                }\n                startLineNumber += lineBreakCnt;\n            }\n            const startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn - 1 : 0;\n            // search for the remaining content\n            if (startLineNumber === searchRange.endLineNumber) {\n                const text = this.getLineContent(startLineNumber).substring(startColumn, searchRange.endColumn - 1);\n                resultLen = this._findMatchesInLine(searchData, searcher, text, searchRange.endLineNumber, startColumn, resultLen, result, captureMatches, limitResultCount);\n                return result;\n            }\n            resultLen = this._findMatchesInLine(searchData, searcher, this.getLineContent(startLineNumber).substr(startColumn), startLineNumber, startColumn, resultLen, result, captureMatches, limitResultCount);\n            if (resultLen >= limitResultCount) {\n                return result;\n            }\n            startLineNumber++;\n            startPosition = this.nodeAt2(startLineNumber, 1);\n            currentNode = startPosition.node;\n            start = this.positionInBuffer(startPosition.node, startPosition.remainder);\n        }\n        if (startLineNumber === searchRange.endLineNumber) {\n            const startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn - 1 : 0;\n            const text = this.getLineContent(startLineNumber).substring(startColumn, searchRange.endColumn - 1);\n            resultLen = this._findMatchesInLine(searchData, searcher, text, searchRange.endLineNumber, startColumn, resultLen, result, captureMatches, limitResultCount);\n            return result;\n        }\n        const startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn : 1;\n        resultLen = this.findMatchesInNode(endPosition.node, searcher, startLineNumber, startColumn, start, end, searchData, captureMatches, limitResultCount, resultLen, result);\n        return result;\n    }\n    _findMatchesInLine(searchData, searcher, text, lineNumber, deltaOffset, resultLen, result, captureMatches, limitResultCount) {\n        const wordSeparators = searchData.wordSeparators;\n        if (!captureMatches && searchData.simpleSearch) {\n            const searchString = searchData.simpleSearch;\n            const searchStringLen = searchString.length;\n            const textLength = text.length;\n            let lastMatchIndex = -searchStringLen;\n            while ((lastMatchIndex = text.indexOf(searchString, lastMatchIndex + searchStringLen)) !== -1) {\n                if (!wordSeparators || isValidMatch(wordSeparators, text, textLength, lastMatchIndex, searchStringLen)) {\n                    result[resultLen++] = new FindMatch(new Range(lineNumber, lastMatchIndex + 1 + deltaOffset, lineNumber, lastMatchIndex + 1 + searchStringLen + deltaOffset), null);\n                    if (resultLen >= limitResultCount) {\n                        return resultLen;\n                    }\n                }\n            }\n            return resultLen;\n        }\n        let m;\n        // Reset regex to search from the beginning\n        searcher.reset(0);\n        do {\n            m = searcher.next(text);\n            if (m) {\n                result[resultLen++] = createFindMatch(new Range(lineNumber, m.index + 1 + deltaOffset, lineNumber, m.index + 1 + m[0].length + deltaOffset), m, captureMatches);\n                if (resultLen >= limitResultCount) {\n                    return resultLen;\n                }\n            }\n        } while (m);\n        return resultLen;\n    }\n    // #endregion\n    // #region Piece Table\n    insert(offset, value, eolNormalized = false) {\n        this._EOLNormalized = this._EOLNormalized && eolNormalized;\n        this._lastVisitedLine.lineNumber = 0;\n        this._lastVisitedLine.value = '';\n        if (this.root !== SENTINEL) {\n            const { node, remainder, nodeStartOffset } = this.nodeAt(offset);\n            const piece = node.piece;\n            const bufferIndex = piece.bufferIndex;\n            const insertPosInBuffer = this.positionInBuffer(node, remainder);\n            if (node.piece.bufferIndex === 0 &&\n                piece.end.line === this._lastChangeBufferPos.line &&\n                piece.end.column === this._lastChangeBufferPos.column &&\n                (nodeStartOffset + piece.length === offset) &&\n                value.length < AverageBufferSize) {\n                // changed buffer\n                this.appendToNode(node, value);\n                this.computeBufferMetadata();\n                return;\n            }\n            if (nodeStartOffset === offset) {\n                this.insertContentToNodeLeft(value, node);\n                this._searchCache.validate(offset);\n            }\n            else if (nodeStartOffset + node.piece.length > offset) {\n                // we are inserting into the middle of a node.\n                const nodesToDel = [];\n                let newRightPiece = new Piece(piece.bufferIndex, insertPosInBuffer, piece.end, this.getLineFeedCnt(piece.bufferIndex, insertPosInBuffer, piece.end), this.offsetInBuffer(bufferIndex, piece.end) - this.offsetInBuffer(bufferIndex, insertPosInBuffer));\n                if (this.shouldCheckCRLF() && this.endWithCR(value)) {\n                    const headOfRight = this.nodeCharCodeAt(node, remainder);\n                    if (headOfRight === 10 /** \\n */) {\n                        const newStart = { line: newRightPiece.start.line + 1, column: 0 };\n                        newRightPiece = new Piece(newRightPiece.bufferIndex, newStart, newRightPiece.end, this.getLineFeedCnt(newRightPiece.bufferIndex, newStart, newRightPiece.end), newRightPiece.length - 1);\n                        value += '\\n';\n                    }\n                }\n                // reuse node for content before insertion point.\n                if (this.shouldCheckCRLF() && this.startWithLF(value)) {\n                    const tailOfLeft = this.nodeCharCodeAt(node, remainder - 1);\n                    if (tailOfLeft === 13 /** \\r */) {\n                        const previousPos = this.positionInBuffer(node, remainder - 1);\n                        this.deleteNodeTail(node, previousPos);\n                        value = '\\r' + value;\n                        if (node.piece.length === 0) {\n                            nodesToDel.push(node);\n                        }\n                    }\n                    else {\n                        this.deleteNodeTail(node, insertPosInBuffer);\n                    }\n                }\n                else {\n                    this.deleteNodeTail(node, insertPosInBuffer);\n                }\n                const newPieces = this.createNewPieces(value);\n                if (newRightPiece.length > 0) {\n                    this.rbInsertRight(node, newRightPiece);\n                }\n                let tmpNode = node;\n                for (let k = 0; k < newPieces.length; k++) {\n                    tmpNode = this.rbInsertRight(tmpNode, newPieces[k]);\n                }\n                this.deleteNodes(nodesToDel);\n            }\n            else {\n                this.insertContentToNodeRight(value, node);\n            }\n        }\n        else {\n            // insert new node\n            const pieces = this.createNewPieces(value);\n            let node = this.rbInsertLeft(null, pieces[0]);\n            for (let k = 1; k < pieces.length; k++) {\n                node = this.rbInsertRight(node, pieces[k]);\n            }\n        }\n        // todo, this is too brutal. Total line feed count should be updated the same way as lf_left.\n        this.computeBufferMetadata();\n    }\n    delete(offset, cnt) {\n        this._lastVisitedLine.lineNumber = 0;\n        this._lastVisitedLine.value = '';\n        if (cnt <= 0 || this.root === SENTINEL) {\n            return;\n        }\n        const startPosition = this.nodeAt(offset);\n        const endPosition = this.nodeAt(offset + cnt);\n        const startNode = startPosition.node;\n        const endNode = endPosition.node;\n        if (startNode === endNode) {\n            const startSplitPosInBuffer = this.positionInBuffer(startNode, startPosition.remainder);\n            const endSplitPosInBuffer = this.positionInBuffer(startNode, endPosition.remainder);\n            if (startPosition.nodeStartOffset === offset) {\n                if (cnt === startNode.piece.length) { // delete node\n                    const next = startNode.next();\n                    rbDelete(this, startNode);\n                    this.validateCRLFWithPrevNode(next);\n                    this.computeBufferMetadata();\n                    return;\n                }\n                this.deleteNodeHead(startNode, endSplitPosInBuffer);\n                this._searchCache.validate(offset);\n                this.validateCRLFWithPrevNode(startNode);\n                this.computeBufferMetadata();\n                return;\n            }\n            if (startPosition.nodeStartOffset + startNode.piece.length === offset + cnt) {\n                this.deleteNodeTail(startNode, startSplitPosInBuffer);\n                this.validateCRLFWithNextNode(startNode);\n                this.computeBufferMetadata();\n                return;\n            }\n            // delete content in the middle, this node will be splitted to nodes\n            this.shrinkNode(startNode, startSplitPosInBuffer, endSplitPosInBuffer);\n            this.computeBufferMetadata();\n            return;\n        }\n        const nodesToDel = [];\n        const startSplitPosInBuffer = this.positionInBuffer(startNode, startPosition.remainder);\n        this.deleteNodeTail(startNode, startSplitPosInBuffer);\n        this._searchCache.validate(offset);\n        if (startNode.piece.length === 0) {\n            nodesToDel.push(startNode);\n        }\n        // update last touched node\n        const endSplitPosInBuffer = this.positionInBuffer(endNode, endPosition.remainder);\n        this.deleteNodeHead(endNode, endSplitPosInBuffer);\n        if (endNode.piece.length === 0) {\n            nodesToDel.push(endNode);\n        }\n        // delete nodes in between\n        const secondNode = startNode.next();\n        for (let node = secondNode; node !== SENTINEL && node !== endNode; node = node.next()) {\n            nodesToDel.push(node);\n        }\n        const prev = startNode.piece.length === 0 ? startNode.prev() : startNode;\n        this.deleteNodes(nodesToDel);\n        this.validateCRLFWithNextNode(prev);\n        this.computeBufferMetadata();\n    }\n    insertContentToNodeLeft(value, node) {\n        // we are inserting content to the beginning of node\n        const nodesToDel = [];\n        if (this.shouldCheckCRLF() && this.endWithCR(value) && this.startWithLF(node)) {\n            // move `\\n` to new node.\n            const piece = node.piece;\n            const newStart = { line: piece.start.line + 1, column: 0 };\n            const nPiece = new Piece(piece.bufferIndex, newStart, piece.end, this.getLineFeedCnt(piece.bufferIndex, newStart, piece.end), piece.length - 1);\n            node.piece = nPiece;\n            value += '\\n';\n            updateTreeMetadata(this, node, -1, -1);\n            if (node.piece.length === 0) {\n                nodesToDel.push(node);\n            }\n        }\n        const newPieces = this.createNewPieces(value);\n        let newNode = this.rbInsertLeft(node, newPieces[newPieces.length - 1]);\n        for (let k = newPieces.length - 2; k >= 0; k--) {\n            newNode = this.rbInsertLeft(newNode, newPieces[k]);\n        }\n        this.validateCRLFWithPrevNode(newNode);\n        this.deleteNodes(nodesToDel);\n    }\n    insertContentToNodeRight(value, node) {\n        // we are inserting to the right of this node.\n        if (this.adjustCarriageReturnFromNext(value, node)) {\n            // move \\n to the new node.\n            value += '\\n';\n        }\n        const newPieces = this.createNewPieces(value);\n        const newNode = this.rbInsertRight(node, newPieces[0]);\n        let tmpNode = newNode;\n        for (let k = 1; k < newPieces.length; k++) {\n            tmpNode = this.rbInsertRight(tmpNode, newPieces[k]);\n        }\n        this.validateCRLFWithPrevNode(newNode);\n    }\n    positionInBuffer(node, remainder, ret) {\n        const piece = node.piece;\n        const bufferIndex = node.piece.bufferIndex;\n        const lineStarts = this._buffers[bufferIndex].lineStarts;\n        const startOffset = lineStarts[piece.start.line] + piece.start.column;\n        const offset = startOffset + remainder;\n        // binary search offset between startOffset and endOffset\n        let low = piece.start.line;\n        let high = piece.end.line;\n        let mid = 0;\n        let midStop = 0;\n        let midStart = 0;\n        while (low <= high) {\n            mid = low + ((high - low) / 2) | 0;\n            midStart = lineStarts[mid];\n            if (mid === high) {\n                break;\n            }\n            midStop = lineStarts[mid + 1];\n            if (offset < midStart) {\n                high = mid - 1;\n            }\n            else if (offset >= midStop) {\n                low = mid + 1;\n            }\n            else {\n                break;\n            }\n        }\n        if (ret) {\n            ret.line = mid;\n            ret.column = offset - midStart;\n            return null;\n        }\n        return {\n            line: mid,\n            column: offset - midStart\n        };\n    }\n    getLineFeedCnt(bufferIndex, start, end) {\n        // we don't need to worry about start: abc\\r|\\n, or abc|\\r, or abc|\\n, or abc|\\r\\n doesn't change the fact that, there is one line break after start.\n        // now let's take care of end: abc\\r|\\n, if end is in between \\r and \\n, we need to add line feed count by 1\n        if (end.column === 0) {\n            return end.line - start.line;\n        }\n        const lineStarts = this._buffers[bufferIndex].lineStarts;\n        if (end.line === lineStarts.length - 1) { // it means, there is no \\n after end, otherwise, there will be one more lineStart.\n            return end.line - start.line;\n        }\n        const nextLineStartOffset = lineStarts[end.line + 1];\n        const endOffset = lineStarts[end.line] + end.column;\n        if (nextLineStartOffset > endOffset + 1) { // there are more than 1 character after end, which means it can't be \\n\n            return end.line - start.line;\n        }\n        // endOffset + 1 === nextLineStartOffset\n        // character at endOffset is \\n, so we check the character before first\n        // if character at endOffset is \\r, end.column is 0 and we can't get here.\n        const previousCharOffset = endOffset - 1; // end.column > 0 so it's okay.\n        const buffer = this._buffers[bufferIndex].buffer;\n        if (buffer.charCodeAt(previousCharOffset) === 13) {\n            return end.line - start.line + 1;\n        }\n        else {\n            return end.line - start.line;\n        }\n    }\n    offsetInBuffer(bufferIndex, cursor) {\n        const lineStarts = this._buffers[bufferIndex].lineStarts;\n        return lineStarts[cursor.line] + cursor.column;\n    }\n    deleteNodes(nodes) {\n        for (let i = 0; i < nodes.length; i++) {\n            rbDelete(this, nodes[i]);\n        }\n    }\n    createNewPieces(text) {\n        if (text.length > AverageBufferSize) {\n            // the content is large, operations like substring, charCode becomes slow\n            // so here we split it into smaller chunks, just like what we did for CR/LF normalization\n            const newPieces = [];\n            while (text.length > AverageBufferSize) {\n                const lastChar = text.charCodeAt(AverageBufferSize - 1);\n                let splitText;\n                if (lastChar === 13 /* CharCode.CarriageReturn */ || (lastChar >= 0xD800 && lastChar <= 0xDBFF)) {\n                    // last character is \\r or a high surrogate => keep it back\n                    splitText = text.substring(0, AverageBufferSize - 1);\n                    text = text.substring(AverageBufferSize - 1);\n                }\n                else {\n                    splitText = text.substring(0, AverageBufferSize);\n                    text = text.substring(AverageBufferSize);\n                }\n                const lineStarts = createLineStartsFast(splitText);\n                newPieces.push(new Piece(this._buffers.length, /* buffer index */ { line: 0, column: 0 }, { line: lineStarts.length - 1, column: splitText.length - lineStarts[lineStarts.length - 1] }, lineStarts.length - 1, splitText.length));\n                this._buffers.push(new StringBuffer(splitText, lineStarts));\n            }\n            const lineStarts = createLineStartsFast(text);\n            newPieces.push(new Piece(this._buffers.length, /* buffer index */ { line: 0, column: 0 }, { line: lineStarts.length - 1, column: text.length - lineStarts[lineStarts.length - 1] }, lineStarts.length - 1, text.length));\n            this._buffers.push(new StringBuffer(text, lineStarts));\n            return newPieces;\n        }\n        let startOffset = this._buffers[0].buffer.length;\n        const lineStarts = createLineStartsFast(text, false);\n        let start = this._lastChangeBufferPos;\n        if (this._buffers[0].lineStarts[this._buffers[0].lineStarts.length - 1] === startOffset\n            && startOffset !== 0\n            && this.startWithLF(text)\n            && this.endWithCR(this._buffers[0].buffer) // todo, we can check this._lastChangeBufferPos's column as it's the last one\n        ) {\n            this._lastChangeBufferPos = { line: this._lastChangeBufferPos.line, column: this._lastChangeBufferPos.column + 1 };\n            start = this._lastChangeBufferPos;\n            for (let i = 0; i < lineStarts.length; i++) {\n                lineStarts[i] += startOffset + 1;\n            }\n            this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(lineStarts.slice(1));\n            this._buffers[0].buffer += '_' + text;\n            startOffset += 1;\n        }\n        else {\n            if (startOffset !== 0) {\n                for (let i = 0; i < lineStarts.length; i++) {\n                    lineStarts[i] += startOffset;\n                }\n            }\n            this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(lineStarts.slice(1));\n            this._buffers[0].buffer += text;\n        }\n        const endOffset = this._buffers[0].buffer.length;\n        const endIndex = this._buffers[0].lineStarts.length - 1;\n        const endColumn = endOffset - this._buffers[0].lineStarts[endIndex];\n        const endPos = { line: endIndex, column: endColumn };\n        const newPiece = new Piece(0, /** todo@peng */ start, endPos, this.getLineFeedCnt(0, start, endPos), endOffset - startOffset);\n        this._lastChangeBufferPos = endPos;\n        return [newPiece];\n    }\n    getLineRawContent(lineNumber, endOffset = 0) {\n        let x = this.root;\n        let ret = '';\n        const cache = this._searchCache.get2(lineNumber);\n        if (cache) {\n            x = cache.node;\n            const prevAccumulatedValue = this.getAccumulatedValue(x, lineNumber - cache.nodeStartLineNumber - 1);\n            const buffer = this._buffers[x.piece.bufferIndex].buffer;\n            const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n            if (cache.nodeStartLineNumber + x.piece.lineFeedCnt === lineNumber) {\n                ret = buffer.substring(startOffset + prevAccumulatedValue, startOffset + x.piece.length);\n            }\n            else {\n                const accumulatedValue = this.getAccumulatedValue(x, lineNumber - cache.nodeStartLineNumber);\n                return buffer.substring(startOffset + prevAccumulatedValue, startOffset + accumulatedValue - endOffset);\n            }\n        }\n        else {\n            let nodeStartOffset = 0;\n            const originalLineNumber = lineNumber;\n            while (x !== SENTINEL) {\n                if (x.left !== SENTINEL && x.lf_left >= lineNumber - 1) {\n                    x = x.left;\n                }\n                else if (x.lf_left + x.piece.lineFeedCnt > lineNumber - 1) {\n                    const prevAccumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n                    const accumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 1);\n                    const buffer = this._buffers[x.piece.bufferIndex].buffer;\n                    const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n                    nodeStartOffset += x.size_left;\n                    this._searchCache.set({\n                        node: x,\n                        nodeStartOffset,\n                        nodeStartLineNumber: originalLineNumber - (lineNumber - 1 - x.lf_left)\n                    });\n                    return buffer.substring(startOffset + prevAccumulatedValue, startOffset + accumulatedValue - endOffset);\n                }\n                else if (x.lf_left + x.piece.lineFeedCnt === lineNumber - 1) {\n                    const prevAccumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n                    const buffer = this._buffers[x.piece.bufferIndex].buffer;\n                    const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n                    ret = buffer.substring(startOffset + prevAccumulatedValue, startOffset + x.piece.length);\n                    break;\n                }\n                else {\n                    lineNumber -= x.lf_left + x.piece.lineFeedCnt;\n                    nodeStartOffset += x.size_left + x.piece.length;\n                    x = x.right;\n                }\n            }\n        }\n        // search in order, to find the node contains end column\n        x = x.next();\n        while (x !== SENTINEL) {\n            const buffer = this._buffers[x.piece.bufferIndex].buffer;\n            if (x.piece.lineFeedCnt > 0) {\n                const accumulatedValue = this.getAccumulatedValue(x, 0);\n                const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n                ret += buffer.substring(startOffset, startOffset + accumulatedValue - endOffset);\n                return ret;\n            }\n            else {\n                const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n                ret += buffer.substr(startOffset, x.piece.length);\n            }\n            x = x.next();\n        }\n        return ret;\n    }\n    computeBufferMetadata() {\n        let x = this.root;\n        let lfCnt = 1;\n        let len = 0;\n        while (x !== SENTINEL) {\n            lfCnt += x.lf_left + x.piece.lineFeedCnt;\n            len += x.size_left + x.piece.length;\n            x = x.right;\n        }\n        this._lineCnt = lfCnt;\n        this._length = len;\n        this._searchCache.validate(this._length);\n    }\n    // #region node operations\n    getIndexOf(node, accumulatedValue) {\n        const piece = node.piece;\n        const pos = this.positionInBuffer(node, accumulatedValue);\n        const lineCnt = pos.line - piece.start.line;\n        if (this.offsetInBuffer(piece.bufferIndex, piece.end) - this.offsetInBuffer(piece.bufferIndex, piece.start) === accumulatedValue) {\n            // we are checking the end of this node, so a CRLF check is necessary.\n            const realLineCnt = this.getLineFeedCnt(node.piece.bufferIndex, piece.start, pos);\n            if (realLineCnt !== lineCnt) {\n                // aha yes, CRLF\n                return { index: realLineCnt, remainder: 0 };\n            }\n        }\n        return { index: lineCnt, remainder: pos.column };\n    }\n    getAccumulatedValue(node, index) {\n        if (index < 0) {\n            return 0;\n        }\n        const piece = node.piece;\n        const lineStarts = this._buffers[piece.bufferIndex].lineStarts;\n        const expectedLineStartIndex = piece.start.line + index + 1;\n        if (expectedLineStartIndex > piece.end.line) {\n            return lineStarts[piece.end.line] + piece.end.column - lineStarts[piece.start.line] - piece.start.column;\n        }\n        else {\n            return lineStarts[expectedLineStartIndex] - lineStarts[piece.start.line] - piece.start.column;\n        }\n    }\n    deleteNodeTail(node, pos) {\n        const piece = node.piece;\n        const originalLFCnt = piece.lineFeedCnt;\n        const originalEndOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);\n        const newEnd = pos;\n        const newEndOffset = this.offsetInBuffer(piece.bufferIndex, newEnd);\n        const newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, piece.start, newEnd);\n        const lf_delta = newLineFeedCnt - originalLFCnt;\n        const size_delta = newEndOffset - originalEndOffset;\n        const newLength = piece.length + size_delta;\n        node.piece = new Piece(piece.bufferIndex, piece.start, newEnd, newLineFeedCnt, newLength);\n        updateTreeMetadata(this, node, size_delta, lf_delta);\n    }\n    deleteNodeHead(node, pos) {\n        const piece = node.piece;\n        const originalLFCnt = piece.lineFeedCnt;\n        const originalStartOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);\n        const newStart = pos;\n        const newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, newStart, piece.end);\n        const newStartOffset = this.offsetInBuffer(piece.bufferIndex, newStart);\n        const lf_delta = newLineFeedCnt - originalLFCnt;\n        const size_delta = originalStartOffset - newStartOffset;\n        const newLength = piece.length + size_delta;\n        node.piece = new Piece(piece.bufferIndex, newStart, piece.end, newLineFeedCnt, newLength);\n        updateTreeMetadata(this, node, size_delta, lf_delta);\n    }\n    shrinkNode(node, start, end) {\n        const piece = node.piece;\n        const originalStartPos = piece.start;\n        const originalEndPos = piece.end;\n        // old piece, originalStartPos, start\n        const oldLength = piece.length;\n        const oldLFCnt = piece.lineFeedCnt;\n        const newEnd = start;\n        const newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, piece.start, newEnd);\n        const newLength = this.offsetInBuffer(piece.bufferIndex, start) - this.offsetInBuffer(piece.bufferIndex, originalStartPos);\n        node.piece = new Piece(piece.bufferIndex, piece.start, newEnd, newLineFeedCnt, newLength);\n        updateTreeMetadata(this, node, newLength - oldLength, newLineFeedCnt - oldLFCnt);\n        // new right piece, end, originalEndPos\n        const newPiece = new Piece(piece.bufferIndex, end, originalEndPos, this.getLineFeedCnt(piece.bufferIndex, end, originalEndPos), this.offsetInBuffer(piece.bufferIndex, originalEndPos) - this.offsetInBuffer(piece.bufferIndex, end));\n        const newNode = this.rbInsertRight(node, newPiece);\n        this.validateCRLFWithPrevNode(newNode);\n    }\n    appendToNode(node, value) {\n        if (this.adjustCarriageReturnFromNext(value, node)) {\n            value += '\\n';\n        }\n        const hitCRLF = this.shouldCheckCRLF() && this.startWithLF(value) && this.endWithCR(node);\n        const startOffset = this._buffers[0].buffer.length;\n        this._buffers[0].buffer += value;\n        const lineStarts = createLineStartsFast(value, false);\n        for (let i = 0; i < lineStarts.length; i++) {\n            lineStarts[i] += startOffset;\n        }\n        if (hitCRLF) {\n            const prevStartOffset = this._buffers[0].lineStarts[this._buffers[0].lineStarts.length - 2];\n            this._buffers[0].lineStarts.pop();\n            // _lastChangeBufferPos is already wrong\n            this._lastChangeBufferPos = { line: this._lastChangeBufferPos.line - 1, column: startOffset - prevStartOffset };\n        }\n        this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(lineStarts.slice(1));\n        const endIndex = this._buffers[0].lineStarts.length - 1;\n        const endColumn = this._buffers[0].buffer.length - this._buffers[0].lineStarts[endIndex];\n        const newEnd = { line: endIndex, column: endColumn };\n        const newLength = node.piece.length + value.length;\n        const oldLineFeedCnt = node.piece.lineFeedCnt;\n        const newLineFeedCnt = this.getLineFeedCnt(0, node.piece.start, newEnd);\n        const lf_delta = newLineFeedCnt - oldLineFeedCnt;\n        node.piece = new Piece(node.piece.bufferIndex, node.piece.start, newEnd, newLineFeedCnt, newLength);\n        this._lastChangeBufferPos = newEnd;\n        updateTreeMetadata(this, node, value.length, lf_delta);\n    }\n    nodeAt(offset) {\n        let x = this.root;\n        const cache = this._searchCache.get(offset);\n        if (cache) {\n            return {\n                node: cache.node,\n                nodeStartOffset: cache.nodeStartOffset,\n                remainder: offset - cache.nodeStartOffset\n            };\n        }\n        let nodeStartOffset = 0;\n        while (x !== SENTINEL) {\n            if (x.size_left > offset) {\n                x = x.left;\n            }\n            else if (x.size_left + x.piece.length >= offset) {\n                nodeStartOffset += x.size_left;\n                const ret = {\n                    node: x,\n                    remainder: offset - x.size_left,\n                    nodeStartOffset\n                };\n                this._searchCache.set(ret);\n                return ret;\n            }\n            else {\n                offset -= x.size_left + x.piece.length;\n                nodeStartOffset += x.size_left + x.piece.length;\n                x = x.right;\n            }\n        }\n        return null;\n    }\n    nodeAt2(lineNumber, column) {\n        let x = this.root;\n        let nodeStartOffset = 0;\n        while (x !== SENTINEL) {\n            if (x.left !== SENTINEL && x.lf_left >= lineNumber - 1) {\n                x = x.left;\n            }\n            else if (x.lf_left + x.piece.lineFeedCnt > lineNumber - 1) {\n                const prevAccumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n                const accumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 1);\n                nodeStartOffset += x.size_left;\n                return {\n                    node: x,\n                    remainder: Math.min(prevAccumualtedValue + column - 1, accumulatedValue),\n                    nodeStartOffset\n                };\n            }\n            else if (x.lf_left + x.piece.lineFeedCnt === lineNumber - 1) {\n                const prevAccumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n                if (prevAccumualtedValue + column - 1 <= x.piece.length) {\n                    return {\n                        node: x,\n                        remainder: prevAccumualtedValue + column - 1,\n                        nodeStartOffset\n                    };\n                }\n                else {\n                    column -= x.piece.length - prevAccumualtedValue;\n                    break;\n                }\n            }\n            else {\n                lineNumber -= x.lf_left + x.piece.lineFeedCnt;\n                nodeStartOffset += x.size_left + x.piece.length;\n                x = x.right;\n            }\n        }\n        // search in order, to find the node contains position.column\n        x = x.next();\n        while (x !== SENTINEL) {\n            if (x.piece.lineFeedCnt > 0) {\n                const accumulatedValue = this.getAccumulatedValue(x, 0);\n                const nodeStartOffset = this.offsetOfNode(x);\n                return {\n                    node: x,\n                    remainder: Math.min(column - 1, accumulatedValue),\n                    nodeStartOffset\n                };\n            }\n            else {\n                if (x.piece.length >= column - 1) {\n                    const nodeStartOffset = this.offsetOfNode(x);\n                    return {\n                        node: x,\n                        remainder: column - 1,\n                        nodeStartOffset\n                    };\n                }\n                else {\n                    column -= x.piece.length;\n                }\n            }\n            x = x.next();\n        }\n        return null;\n    }\n    nodeCharCodeAt(node, offset) {\n        if (node.piece.lineFeedCnt < 1) {\n            return -1;\n        }\n        const buffer = this._buffers[node.piece.bufferIndex];\n        const newOffset = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start) + offset;\n        return buffer.buffer.charCodeAt(newOffset);\n    }\n    offsetOfNode(node) {\n        if (!node) {\n            return 0;\n        }\n        let pos = node.size_left;\n        while (node !== this.root) {\n            if (node.parent.right === node) {\n                pos += node.parent.size_left + node.parent.piece.length;\n            }\n            node = node.parent;\n        }\n        return pos;\n    }\n    // #endregion\n    // #region CRLF\n    shouldCheckCRLF() {\n        return !(this._EOLNormalized && this._EOL === '\\n');\n    }\n    startWithLF(val) {\n        if (typeof val === 'string') {\n            return val.charCodeAt(0) === 10;\n        }\n        if (val === SENTINEL || val.piece.lineFeedCnt === 0) {\n            return false;\n        }\n        const piece = val.piece;\n        const lineStarts = this._buffers[piece.bufferIndex].lineStarts;\n        const line = piece.start.line;\n        const startOffset = lineStarts[line] + piece.start.column;\n        if (line === lineStarts.length - 1) {\n            // last line, so there is no line feed at the end of this line\n            return false;\n        }\n        const nextLineOffset = lineStarts[line + 1];\n        if (nextLineOffset > startOffset + 1) {\n            return false;\n        }\n        return this._buffers[piece.bufferIndex].buffer.charCodeAt(startOffset) === 10;\n    }\n    endWithCR(val) {\n        if (typeof val === 'string') {\n            return val.charCodeAt(val.length - 1) === 13;\n        }\n        if (val === SENTINEL || val.piece.lineFeedCnt === 0) {\n            return false;\n        }\n        return this.nodeCharCodeAt(val, val.piece.length - 1) === 13;\n    }\n    validateCRLFWithPrevNode(nextNode) {\n        if (this.shouldCheckCRLF() && this.startWithLF(nextNode)) {\n            const node = nextNode.prev();\n            if (this.endWithCR(node)) {\n                this.fixCRLF(node, nextNode);\n            }\n        }\n    }\n    validateCRLFWithNextNode(node) {\n        if (this.shouldCheckCRLF() && this.endWithCR(node)) {\n            const nextNode = node.next();\n            if (this.startWithLF(nextNode)) {\n                this.fixCRLF(node, nextNode);\n            }\n        }\n    }\n    fixCRLF(prev, next) {\n        const nodesToDel = [];\n        // update node\n        const lineStarts = this._buffers[prev.piece.bufferIndex].lineStarts;\n        let newEnd;\n        if (prev.piece.end.column === 0) {\n            // it means, last line ends with \\r, not \\r\\n\n            newEnd = { line: prev.piece.end.line - 1, column: lineStarts[prev.piece.end.line] - lineStarts[prev.piece.end.line - 1] - 1 };\n        }\n        else {\n            // \\r\\n\n            newEnd = { line: prev.piece.end.line, column: prev.piece.end.column - 1 };\n        }\n        const prevNewLength = prev.piece.length - 1;\n        const prevNewLFCnt = prev.piece.lineFeedCnt - 1;\n        prev.piece = new Piece(prev.piece.bufferIndex, prev.piece.start, newEnd, prevNewLFCnt, prevNewLength);\n        updateTreeMetadata(this, prev, -1, -1);\n        if (prev.piece.length === 0) {\n            nodesToDel.push(prev);\n        }\n        // update nextNode\n        const newStart = { line: next.piece.start.line + 1, column: 0 };\n        const newLength = next.piece.length - 1;\n        const newLineFeedCnt = this.getLineFeedCnt(next.piece.bufferIndex, newStart, next.piece.end);\n        next.piece = new Piece(next.piece.bufferIndex, newStart, next.piece.end, newLineFeedCnt, newLength);\n        updateTreeMetadata(this, next, -1, -1);\n        if (next.piece.length === 0) {\n            nodesToDel.push(next);\n        }\n        // create new piece which contains \\r\\n\n        const pieces = this.createNewPieces('\\r\\n');\n        this.rbInsertRight(prev, pieces[0]);\n        // delete empty nodes\n        for (let i = 0; i < nodesToDel.length; i++) {\n            rbDelete(this, nodesToDel[i]);\n        }\n    }\n    adjustCarriageReturnFromNext(value, node) {\n        if (this.shouldCheckCRLF() && this.endWithCR(value)) {\n            const nextNode = node.next();\n            if (this.startWithLF(nextNode)) {\n                // move `\\n` forward\n                value += '\\n';\n                if (nextNode.piece.length === 1) {\n                    rbDelete(this, nextNode);\n                }\n                else {\n                    const piece = nextNode.piece;\n                    const newStart = { line: piece.start.line + 1, column: 0 };\n                    const newLength = piece.length - 1;\n                    const newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, newStart, piece.end);\n                    nextNode.piece = new Piece(piece.bufferIndex, newStart, piece.end, newLineFeedCnt, newLength);\n                    updateTreeMetadata(this, nextNode, -1, -1);\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n    // #endregion\n    // #endregion\n    // #region Tree operations\n    iterate(node, callback) {\n        if (node === SENTINEL) {\n            return callback(SENTINEL);\n        }\n        const leftRet = this.iterate(node.left, callback);\n        if (!leftRet) {\n            return leftRet;\n        }\n        return callback(node) && this.iterate(node.right, callback);\n    }\n    getNodeContent(node) {\n        if (node === SENTINEL) {\n            return '';\n        }\n        const buffer = this._buffers[node.piece.bufferIndex];\n        const piece = node.piece;\n        const startOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);\n        const endOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);\n        const currentContent = buffer.buffer.substring(startOffset, endOffset);\n        return currentContent;\n    }\n    getPieceContent(piece) {\n        const buffer = this._buffers[piece.bufferIndex];\n        const startOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);\n        const endOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);\n        const currentContent = buffer.buffer.substring(startOffset, endOffset);\n        return currentContent;\n    }\n    /**\n     *      node              node\n     *     /  \\              /  \\\n     *    a   b    <----   a    b\n     *                         /\n     *                        z\n     */\n    rbInsertRight(node, p) {\n        const z = new TreeNode(p, 1 /* NodeColor.Red */);\n        z.left = SENTINEL;\n        z.right = SENTINEL;\n        z.parent = SENTINEL;\n        z.size_left = 0;\n        z.lf_left = 0;\n        const x = this.root;\n        if (x === SENTINEL) {\n            this.root = z;\n            z.color = 0 /* NodeColor.Black */;\n        }\n        else if (node.right === SENTINEL) {\n            node.right = z;\n            z.parent = node;\n        }\n        else {\n            const nextNode = leftest(node.right);\n            nextNode.left = z;\n            z.parent = nextNode;\n        }\n        fixInsert(this, z);\n        return z;\n    }\n    /**\n     *      node              node\n     *     /  \\              /  \\\n     *    a   b     ---->   a    b\n     *                       \\\n     *                        z\n     */\n    rbInsertLeft(node, p) {\n        const z = new TreeNode(p, 1 /* NodeColor.Red */);\n        z.left = SENTINEL;\n        z.right = SENTINEL;\n        z.parent = SENTINEL;\n        z.size_left = 0;\n        z.lf_left = 0;\n        if (this.root === SENTINEL) {\n            this.root = z;\n            z.color = 0 /* NodeColor.Black */;\n        }\n        else if (node.left === SENTINEL) {\n            node.left = z;\n            z.parent = node;\n        }\n        else {\n            const prevNode = righttest(node.left); // a\n            prevNode.right = z;\n            z.parent = prevNode;\n        }\n        fixInsert(this, z);\n        return z;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../../../base/common/event.js';\nimport * as strings from '../../../../base/common/strings.js';\nimport { Range } from '../../core/range.js';\nimport { ApplyEditsResult } from '../../model.js';\nimport { PieceTreeBase } from './pieceTreeBase.js';\nimport { countEOL } from '../../core/eolCounter.js';\nimport { TextChange } from '../../core/textChange.js';\nimport { Disposable } from '../../../../base/common/lifecycle.js';\nexport class PieceTreeTextBuffer extends Disposable {\n    constructor(chunks, BOM, eol, containsRTL, containsUnusualLineTerminators, isBasicASCII, eolNormalized) {\n        super();\n        this._onDidChangeContent = this._register(new Emitter());\n        this._BOM = BOM;\n        this._mightContainNonBasicASCII = !isBasicASCII;\n        this._mightContainRTL = containsRTL;\n        this._mightContainUnusualLineTerminators = containsUnusualLineTerminators;\n        this._pieceTree = new PieceTreeBase(chunks, eol, eolNormalized);\n    }\n    mightContainRTL() {\n        return this._mightContainRTL;\n    }\n    mightContainUnusualLineTerminators() {\n        return this._mightContainUnusualLineTerminators;\n    }\n    resetMightContainUnusualLineTerminators() {\n        this._mightContainUnusualLineTerminators = false;\n    }\n    mightContainNonBasicASCII() {\n        return this._mightContainNonBasicASCII;\n    }\n    getBOM() {\n        return this._BOM;\n    }\n    getEOL() {\n        return this._pieceTree.getEOL();\n    }\n    createSnapshot(preserveBOM) {\n        return this._pieceTree.createSnapshot(preserveBOM ? this._BOM : '');\n    }\n    getOffsetAt(lineNumber, column) {\n        return this._pieceTree.getOffsetAt(lineNumber, column);\n    }\n    getPositionAt(offset) {\n        return this._pieceTree.getPositionAt(offset);\n    }\n    getRangeAt(start, length) {\n        const end = start + length;\n        const startPosition = this.getPositionAt(start);\n        const endPosition = this.getPositionAt(end);\n        return new Range(startPosition.lineNumber, startPosition.column, endPosition.lineNumber, endPosition.column);\n    }\n    getValueInRange(range, eol = 0 /* EndOfLinePreference.TextDefined */) {\n        if (range.isEmpty()) {\n            return '';\n        }\n        const lineEnding = this._getEndOfLine(eol);\n        return this._pieceTree.getValueInRange(range, lineEnding);\n    }\n    getValueLengthInRange(range, eol = 0 /* EndOfLinePreference.TextDefined */) {\n        if (range.isEmpty()) {\n            return 0;\n        }\n        if (range.startLineNumber === range.endLineNumber) {\n            return (range.endColumn - range.startColumn);\n        }\n        const startOffset = this.getOffsetAt(range.startLineNumber, range.startColumn);\n        const endOffset = this.getOffsetAt(range.endLineNumber, range.endColumn);\n        // offsets use the text EOL, so we need to compensate for length differences\n        // if the requested EOL doesn't match the text EOL\n        let eolOffsetCompensation = 0;\n        const desiredEOL = this._getEndOfLine(eol);\n        const actualEOL = this.getEOL();\n        if (desiredEOL.length !== actualEOL.length) {\n            const delta = desiredEOL.length - actualEOL.length;\n            const eolCount = range.endLineNumber - range.startLineNumber;\n            eolOffsetCompensation = delta * eolCount;\n        }\n        return endOffset - startOffset + eolOffsetCompensation;\n    }\n    getCharacterCountInRange(range, eol = 0 /* EndOfLinePreference.TextDefined */) {\n        if (this._mightContainNonBasicASCII) {\n            // we must count by iterating\n            let result = 0;\n            const fromLineNumber = range.startLineNumber;\n            const toLineNumber = range.endLineNumber;\n            for (let lineNumber = fromLineNumber; lineNumber <= toLineNumber; lineNumber++) {\n                const lineContent = this.getLineContent(lineNumber);\n                const fromOffset = (lineNumber === fromLineNumber ? range.startColumn - 1 : 0);\n                const toOffset = (lineNumber === toLineNumber ? range.endColumn - 1 : lineContent.length);\n                for (let offset = fromOffset; offset < toOffset; offset++) {\n                    if (strings.isHighSurrogate(lineContent.charCodeAt(offset))) {\n                        result = result + 1;\n                        offset = offset + 1;\n                    }\n                    else {\n                        result = result + 1;\n                    }\n                }\n            }\n            result += this._getEndOfLine(eol).length * (toLineNumber - fromLineNumber);\n            return result;\n        }\n        return this.getValueLengthInRange(range, eol);\n    }\n    getLength() {\n        return this._pieceTree.getLength();\n    }\n    getLineCount() {\n        return this._pieceTree.getLineCount();\n    }\n    getLinesContent() {\n        return this._pieceTree.getLinesContent();\n    }\n    getLineContent(lineNumber) {\n        return this._pieceTree.getLineContent(lineNumber);\n    }\n    getLineCharCode(lineNumber, index) {\n        return this._pieceTree.getLineCharCode(lineNumber, index);\n    }\n    getLineLength(lineNumber) {\n        return this._pieceTree.getLineLength(lineNumber);\n    }\n    getLineFirstNonWhitespaceColumn(lineNumber) {\n        const result = strings.firstNonWhitespaceIndex(this.getLineContent(lineNumber));\n        if (result === -1) {\n            return 0;\n        }\n        return result + 1;\n    }\n    getLineLastNonWhitespaceColumn(lineNumber) {\n        const result = strings.lastNonWhitespaceIndex(this.getLineContent(lineNumber));\n        if (result === -1) {\n            return 0;\n        }\n        return result + 2;\n    }\n    _getEndOfLine(eol) {\n        switch (eol) {\n            case 1 /* EndOfLinePreference.LF */:\n                return '\\n';\n            case 2 /* EndOfLinePreference.CRLF */:\n                return '\\r\\n';\n            case 0 /* EndOfLinePreference.TextDefined */:\n                return this.getEOL();\n            default:\n                throw new Error('Unknown EOL preference');\n        }\n    }\n    setEOL(newEOL) {\n        this._pieceTree.setEOL(newEOL);\n    }\n    applyEdits(rawOperations, recordTrimAutoWhitespace, computeUndoEdits) {\n        let mightContainRTL = this._mightContainRTL;\n        let mightContainUnusualLineTerminators = this._mightContainUnusualLineTerminators;\n        let mightContainNonBasicASCII = this._mightContainNonBasicASCII;\n        let canReduceOperations = true;\n        let operations = [];\n        for (let i = 0; i < rawOperations.length; i++) {\n            const op = rawOperations[i];\n            if (canReduceOperations && op._isTracked) {\n                canReduceOperations = false;\n            }\n            const validatedRange = op.range;\n            if (op.text) {\n                let textMightContainNonBasicASCII = true;\n                if (!mightContainNonBasicASCII) {\n                    textMightContainNonBasicASCII = !strings.isBasicASCII(op.text);\n                    mightContainNonBasicASCII = textMightContainNonBasicASCII;\n                }\n                if (!mightContainRTL && textMightContainNonBasicASCII) {\n                    // check if the new inserted text contains RTL\n                    mightContainRTL = strings.containsRTL(op.text);\n                }\n                if (!mightContainUnusualLineTerminators && textMightContainNonBasicASCII) {\n                    // check if the new inserted text contains unusual line terminators\n                    mightContainUnusualLineTerminators = strings.containsUnusualLineTerminators(op.text);\n                }\n            }\n            let validText = '';\n            let eolCount = 0;\n            let firstLineLength = 0;\n            let lastLineLength = 0;\n            if (op.text) {\n                let strEOL;\n                [eolCount, firstLineLength, lastLineLength, strEOL] = countEOL(op.text);\n                const bufferEOL = this.getEOL();\n                const expectedStrEOL = (bufferEOL === '\\r\\n' ? 2 /* StringEOL.CRLF */ : 1 /* StringEOL.LF */);\n                if (strEOL === 0 /* StringEOL.Unknown */ || strEOL === expectedStrEOL) {\n                    validText = op.text;\n                }\n                else {\n                    validText = op.text.replace(/\\r\\n|\\r|\\n/g, bufferEOL);\n                }\n            }\n            operations[i] = {\n                sortIndex: i,\n                identifier: op.identifier || null,\n                range: validatedRange,\n                rangeOffset: this.getOffsetAt(validatedRange.startLineNumber, validatedRange.startColumn),\n                rangeLength: this.getValueLengthInRange(validatedRange),\n                text: validText,\n                eolCount: eolCount,\n                firstLineLength: firstLineLength,\n                lastLineLength: lastLineLength,\n                forceMoveMarkers: Boolean(op.forceMoveMarkers),\n                isAutoWhitespaceEdit: op.isAutoWhitespaceEdit || false\n            };\n        }\n        // Sort operations ascending\n        operations.sort(PieceTreeTextBuffer._sortOpsAscending);\n        let hasTouchingRanges = false;\n        for (let i = 0, count = operations.length - 1; i < count; i++) {\n            const rangeEnd = operations[i].range.getEndPosition();\n            const nextRangeStart = operations[i + 1].range.getStartPosition();\n            if (nextRangeStart.isBeforeOrEqual(rangeEnd)) {\n                if (nextRangeStart.isBefore(rangeEnd)) {\n                    // overlapping ranges\n                    throw new Error('Overlapping ranges are not allowed!');\n                }\n                hasTouchingRanges = true;\n            }\n        }\n        if (canReduceOperations) {\n            operations = this._reduceOperations(operations);\n        }\n        // Delta encode operations\n        const reverseRanges = (computeUndoEdits || recordTrimAutoWhitespace ? PieceTreeTextBuffer._getInverseEditRanges(operations) : []);\n        const newTrimAutoWhitespaceCandidates = [];\n        if (recordTrimAutoWhitespace) {\n            for (let i = 0; i < operations.length; i++) {\n                const op = operations[i];\n                const reverseRange = reverseRanges[i];\n                if (op.isAutoWhitespaceEdit && op.range.isEmpty()) {\n                    // Record already the future line numbers that might be auto whitespace removal candidates on next edit\n                    for (let lineNumber = reverseRange.startLineNumber; lineNumber <= reverseRange.endLineNumber; lineNumber++) {\n                        let currentLineContent = '';\n                        if (lineNumber === reverseRange.startLineNumber) {\n                            currentLineContent = this.getLineContent(op.range.startLineNumber);\n                            if (strings.firstNonWhitespaceIndex(currentLineContent) !== -1) {\n                                continue;\n                            }\n                        }\n                        newTrimAutoWhitespaceCandidates.push({ lineNumber: lineNumber, oldContent: currentLineContent });\n                    }\n                }\n            }\n        }\n        let reverseOperations = null;\n        if (computeUndoEdits) {\n            let reverseRangeDeltaOffset = 0;\n            reverseOperations = [];\n            for (let i = 0; i < operations.length; i++) {\n                const op = operations[i];\n                const reverseRange = reverseRanges[i];\n                const bufferText = this.getValueInRange(op.range);\n                const reverseRangeOffset = op.rangeOffset + reverseRangeDeltaOffset;\n                reverseRangeDeltaOffset += (op.text.length - bufferText.length);\n                reverseOperations[i] = {\n                    sortIndex: op.sortIndex,\n                    identifier: op.identifier,\n                    range: reverseRange,\n                    text: bufferText,\n                    textChange: new TextChange(op.rangeOffset, bufferText, reverseRangeOffset, op.text)\n                };\n            }\n            // Can only sort reverse operations when the order is not significant\n            if (!hasTouchingRanges) {\n                reverseOperations.sort((a, b) => a.sortIndex - b.sortIndex);\n            }\n        }\n        this._mightContainRTL = mightContainRTL;\n        this._mightContainUnusualLineTerminators = mightContainUnusualLineTerminators;\n        this._mightContainNonBasicASCII = mightContainNonBasicASCII;\n        const contentChanges = this._doApplyEdits(operations);\n        let trimAutoWhitespaceLineNumbers = null;\n        if (recordTrimAutoWhitespace && newTrimAutoWhitespaceCandidates.length > 0) {\n            // sort line numbers auto whitespace removal candidates for next edit descending\n            newTrimAutoWhitespaceCandidates.sort((a, b) => b.lineNumber - a.lineNumber);\n            trimAutoWhitespaceLineNumbers = [];\n            for (let i = 0, len = newTrimAutoWhitespaceCandidates.length; i < len; i++) {\n                const lineNumber = newTrimAutoWhitespaceCandidates[i].lineNumber;\n                if (i > 0 && newTrimAutoWhitespaceCandidates[i - 1].lineNumber === lineNumber) {\n                    // Do not have the same line number twice\n                    continue;\n                }\n                const prevContent = newTrimAutoWhitespaceCandidates[i].oldContent;\n                const lineContent = this.getLineContent(lineNumber);\n                if (lineContent.length === 0 || lineContent === prevContent || strings.firstNonWhitespaceIndex(lineContent) !== -1) {\n                    continue;\n                }\n                trimAutoWhitespaceLineNumbers.push(lineNumber);\n            }\n        }\n        this._onDidChangeContent.fire();\n        return new ApplyEditsResult(reverseOperations, contentChanges, trimAutoWhitespaceLineNumbers);\n    }\n    /**\n     * Transform operations such that they represent the same logic edit,\n     * but that they also do not cause OOM crashes.\n     */\n    _reduceOperations(operations) {\n        if (operations.length < 1000) {\n            // We know from empirical testing that a thousand edits work fine regardless of their shape.\n            return operations;\n        }\n        // At one point, due to how events are emitted and how each operation is handled,\n        // some operations can trigger a high amount of temporary string allocations,\n        // that will immediately get edited again.\n        // e.g. a formatter inserting ridiculous ammounts of \\n on a model with a single line\n        // Therefore, the strategy is to collapse all the operations into a huge single edit operation\n        return [this._toSingleEditOperation(operations)];\n    }\n    _toSingleEditOperation(operations) {\n        let forceMoveMarkers = false;\n        const firstEditRange = operations[0].range;\n        const lastEditRange = operations[operations.length - 1].range;\n        const entireEditRange = new Range(firstEditRange.startLineNumber, firstEditRange.startColumn, lastEditRange.endLineNumber, lastEditRange.endColumn);\n        let lastEndLineNumber = firstEditRange.startLineNumber;\n        let lastEndColumn = firstEditRange.startColumn;\n        const result = [];\n        for (let i = 0, len = operations.length; i < len; i++) {\n            const operation = operations[i];\n            const range = operation.range;\n            forceMoveMarkers = forceMoveMarkers || operation.forceMoveMarkers;\n            // (1) -- Push old text\n            result.push(this.getValueInRange(new Range(lastEndLineNumber, lastEndColumn, range.startLineNumber, range.startColumn)));\n            // (2) -- Push new text\n            if (operation.text.length > 0) {\n                result.push(operation.text);\n            }\n            lastEndLineNumber = range.endLineNumber;\n            lastEndColumn = range.endColumn;\n        }\n        const text = result.join('');\n        const [eolCount, firstLineLength, lastLineLength] = countEOL(text);\n        return {\n            sortIndex: 0,\n            identifier: operations[0].identifier,\n            range: entireEditRange,\n            rangeOffset: this.getOffsetAt(entireEditRange.startLineNumber, entireEditRange.startColumn),\n            rangeLength: this.getValueLengthInRange(entireEditRange, 0 /* EndOfLinePreference.TextDefined */),\n            text: text,\n            eolCount: eolCount,\n            firstLineLength: firstLineLength,\n            lastLineLength: lastLineLength,\n            forceMoveMarkers: forceMoveMarkers,\n            isAutoWhitespaceEdit: false\n        };\n    }\n    _doApplyEdits(operations) {\n        operations.sort(PieceTreeTextBuffer._sortOpsDescending);\n        const contentChanges = [];\n        // operations are from bottom to top\n        for (let i = 0; i < operations.length; i++) {\n            const op = operations[i];\n            const startLineNumber = op.range.startLineNumber;\n            const startColumn = op.range.startColumn;\n            const endLineNumber = op.range.endLineNumber;\n            const endColumn = op.range.endColumn;\n            if (startLineNumber === endLineNumber && startColumn === endColumn && op.text.length === 0) {\n                // no-op\n                continue;\n            }\n            if (op.text) {\n                // replacement\n                this._pieceTree.delete(op.rangeOffset, op.rangeLength);\n                this._pieceTree.insert(op.rangeOffset, op.text, true);\n            }\n            else {\n                // deletion\n                this._pieceTree.delete(op.rangeOffset, op.rangeLength);\n            }\n            const contentChangeRange = new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n            contentChanges.push({\n                range: contentChangeRange,\n                rangeLength: op.rangeLength,\n                text: op.text,\n                rangeOffset: op.rangeOffset,\n                forceMoveMarkers: op.forceMoveMarkers\n            });\n        }\n        return contentChanges;\n    }\n    findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount) {\n        return this._pieceTree.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);\n    }\n    /**\n     * Assumes `operations` are validated and sorted ascending\n     */\n    static _getInverseEditRanges(operations) {\n        const result = [];\n        let prevOpEndLineNumber = 0;\n        let prevOpEndColumn = 0;\n        let prevOp = null;\n        for (let i = 0, len = operations.length; i < len; i++) {\n            const op = operations[i];\n            let startLineNumber;\n            let startColumn;\n            if (prevOp) {\n                if (prevOp.range.endLineNumber === op.range.startLineNumber) {\n                    startLineNumber = prevOpEndLineNumber;\n                    startColumn = prevOpEndColumn + (op.range.startColumn - prevOp.range.endColumn);\n                }\n                else {\n                    startLineNumber = prevOpEndLineNumber + (op.range.startLineNumber - prevOp.range.endLineNumber);\n                    startColumn = op.range.startColumn;\n                }\n            }\n            else {\n                startLineNumber = op.range.startLineNumber;\n                startColumn = op.range.startColumn;\n            }\n            let resultRange;\n            if (op.text.length > 0) {\n                // the operation inserts something\n                const lineCount = op.eolCount + 1;\n                if (lineCount === 1) {\n                    // single line insert\n                    resultRange = new Range(startLineNumber, startColumn, startLineNumber, startColumn + op.firstLineLength);\n                }\n                else {\n                    // multi line insert\n                    resultRange = new Range(startLineNumber, startColumn, startLineNumber + lineCount - 1, op.lastLineLength + 1);\n                }\n            }\n            else {\n                // There is nothing to insert\n                resultRange = new Range(startLineNumber, startColumn, startLineNumber, startColumn);\n            }\n            prevOpEndLineNumber = resultRange.endLineNumber;\n            prevOpEndColumn = resultRange.endColumn;\n            result.push(resultRange);\n            prevOp = op;\n        }\n        return result;\n    }\n    static _sortOpsAscending(a, b) {\n        const r = Range.compareRangesUsingEnds(a.range, b.range);\n        if (r === 0) {\n            return a.sortIndex - b.sortIndex;\n        }\n        return r;\n    }\n    static _sortOpsDescending(a, b) {\n        const r = Range.compareRangesUsingEnds(a.range, b.range);\n        if (r === 0) {\n            return b.sortIndex - a.sortIndex;\n        }\n        return -r;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../../base/common/strings.js';\nimport { StringBuffer, createLineStarts, createLineStartsFast } from './pieceTreeBase.js';\nimport { PieceTreeTextBuffer } from './pieceTreeTextBuffer.js';\nclass PieceTreeTextBufferFactory {\n    constructor(_chunks, _bom, _cr, _lf, _crlf, _containsRTL, _containsUnusualLineTerminators, _isBasicASCII, _normalizeEOL) {\n        this._chunks = _chunks;\n        this._bom = _bom;\n        this._cr = _cr;\n        this._lf = _lf;\n        this._crlf = _crlf;\n        this._containsRTL = _containsRTL;\n        this._containsUnusualLineTerminators = _containsUnusualLineTerminators;\n        this._isBasicASCII = _isBasicASCII;\n        this._normalizeEOL = _normalizeEOL;\n    }\n    _getEOL(defaultEOL) {\n        const totalEOLCount = this._cr + this._lf + this._crlf;\n        const totalCRCount = this._cr + this._crlf;\n        if (totalEOLCount === 0) {\n            // This is an empty file or a file with precisely one line\n            return (defaultEOL === 1 /* DefaultEndOfLine.LF */ ? '\\n' : '\\r\\n');\n        }\n        if (totalCRCount > totalEOLCount / 2) {\n            // More than half of the file contains \\r\\n ending lines\n            return '\\r\\n';\n        }\n        // At least one line more ends in \\n\n        return '\\n';\n    }\n    create(defaultEOL) {\n        const eol = this._getEOL(defaultEOL);\n        const chunks = this._chunks;\n        if (this._normalizeEOL &&\n            ((eol === '\\r\\n' && (this._cr > 0 || this._lf > 0))\n                || (eol === '\\n' && (this._cr > 0 || this._crlf > 0)))) {\n            // Normalize pieces\n            for (let i = 0, len = chunks.length; i < len; i++) {\n                const str = chunks[i].buffer.replace(/\\r\\n|\\r|\\n/g, eol);\n                const newLineStart = createLineStartsFast(str);\n                chunks[i] = new StringBuffer(str, newLineStart);\n            }\n        }\n        const textBuffer = new PieceTreeTextBuffer(chunks, this._bom, eol, this._containsRTL, this._containsUnusualLineTerminators, this._isBasicASCII, this._normalizeEOL);\n        return { textBuffer: textBuffer, disposable: textBuffer };\n    }\n}\nexport class PieceTreeTextBufferBuilder {\n    constructor() {\n        this.chunks = [];\n        this.BOM = '';\n        this._hasPreviousChar = false;\n        this._previousChar = 0;\n        this._tmpLineStarts = [];\n        this.cr = 0;\n        this.lf = 0;\n        this.crlf = 0;\n        this.containsRTL = false;\n        this.containsUnusualLineTerminators = false;\n        this.isBasicASCII = true;\n    }\n    acceptChunk(chunk) {\n        if (chunk.length === 0) {\n            return;\n        }\n        if (this.chunks.length === 0) {\n            if (strings.startsWithUTF8BOM(chunk)) {\n                this.BOM = strings.UTF8_BOM_CHARACTER;\n                chunk = chunk.substr(1);\n            }\n        }\n        const lastChar = chunk.charCodeAt(chunk.length - 1);\n        if (lastChar === 13 /* CharCode.CarriageReturn */ || (lastChar >= 0xD800 && lastChar <= 0xDBFF)) {\n            // last character is \\r or a high surrogate => keep it back\n            this._acceptChunk1(chunk.substr(0, chunk.length - 1), false);\n            this._hasPreviousChar = true;\n            this._previousChar = lastChar;\n        }\n        else {\n            this._acceptChunk1(chunk, false);\n            this._hasPreviousChar = false;\n            this._previousChar = lastChar;\n        }\n    }\n    _acceptChunk1(chunk, allowEmptyStrings) {\n        if (!allowEmptyStrings && chunk.length === 0) {\n            // Nothing to do\n            return;\n        }\n        if (this._hasPreviousChar) {\n            this._acceptChunk2(String.fromCharCode(this._previousChar) + chunk);\n        }\n        else {\n            this._acceptChunk2(chunk);\n        }\n    }\n    _acceptChunk2(chunk) {\n        const lineStarts = createLineStarts(this._tmpLineStarts, chunk);\n        this.chunks.push(new StringBuffer(chunk, lineStarts.lineStarts));\n        this.cr += lineStarts.cr;\n        this.lf += lineStarts.lf;\n        this.crlf += lineStarts.crlf;\n        if (!lineStarts.isBasicASCII) {\n            // this chunk contains non basic ASCII characters\n            this.isBasicASCII = false;\n            if (!this.containsRTL) {\n                this.containsRTL = strings.containsRTL(chunk);\n            }\n            if (!this.containsUnusualLineTerminators) {\n                this.containsUnusualLineTerminators = strings.containsUnusualLineTerminators(chunk);\n            }\n        }\n    }\n    finish(normalizeEOL = true) {\n        this._finish();\n        return new PieceTreeTextBufferFactory(this.chunks, this.BOM, this.cr, this.lf, this.crlf, this.containsRTL, this.containsUnusualLineTerminators, this.isBasicASCII, normalizeEOL);\n    }\n    _finish() {\n        if (this.chunks.length === 0) {\n            this._acceptChunk1('', true);\n        }\n        if (this._hasPreviousChar) {\n            this._hasPreviousChar = false;\n            // recreate last chunk\n            const lastChunk = this.chunks[this.chunks.length - 1];\n            lastChunk.buffer += String.fromCharCode(this._previousChar);\n            const newLineStarts = createLineStartsFast(lastChunk.buffer);\n            lastChunk.lineStarts = newLineStarts;\n            if (this._previousChar === 13 /* CharCode.CarriageReturn */) {\n                this.cr++;\n            }\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { arrayInsert } from '../../../base/common/arrays.js';\n/**\n * An array that avoids being sparse by always\n * filling up unused indices with a default value.\n */\nexport class FixedArray {\n    constructor(_default) {\n        this._default = _default;\n        this._store = [];\n    }\n    get(index) {\n        if (index < this._store.length) {\n            return this._store[index];\n        }\n        return this._default;\n    }\n    set(index, value) {\n        while (index >= this._store.length) {\n            this._store[this._store.length] = this._default;\n        }\n        this._store[index] = value;\n    }\n    replace(index, oldLength, newLength) {\n        if (index >= this._store.length) {\n            return;\n        }\n        if (oldLength === 0) {\n            this.insert(index, newLength);\n            return;\n        }\n        else if (newLength === 0) {\n            this.delete(index, oldLength);\n            return;\n        }\n        const before = this._store.slice(0, index);\n        const after = this._store.slice(index + oldLength);\n        const insertArr = arrayFill(newLength, this._default);\n        this._store = before.concat(insertArr, after);\n    }\n    delete(deleteIndex, deleteCount) {\n        if (deleteCount === 0 || deleteIndex >= this._store.length) {\n            return;\n        }\n        this._store.splice(deleteIndex, deleteCount);\n    }\n    insert(insertIndex, insertCount) {\n        if (insertCount === 0 || insertIndex >= this._store.length) {\n            return;\n        }\n        const arr = [];\n        for (let i = 0; i < insertCount; i++) {\n            arr[i] = this._default;\n        }\n        this._store = arrayInsert(this._store, insertIndex, arr);\n    }\n}\nfunction arrayFill(length, value) {\n    const arr = [];\n    for (let i = 0; i < length; i++) {\n        arr[i] = value;\n    }\n    return arr;\n}\n","/**\n * Represents contiguous tokens over a contiguous range of lines.\n */\nexport class ContiguousMultilineTokens {\n    /**\n     * (Inclusive) start line number for these tokens.\n     */\n    get startLineNumber() {\n        return this._startLineNumber;\n    }\n    /**\n     * (Inclusive) end line number for these tokens.\n     */\n    get endLineNumber() {\n        return this._startLineNumber + this._tokens.length - 1;\n    }\n    constructor(startLineNumber, tokens) {\n        this._startLineNumber = startLineNumber;\n        this._tokens = tokens;\n    }\n    /**\n     * @see {@link _tokens}\n     */\n    getLineTokens(lineNumber) {\n        return this._tokens[lineNumber - this._startLineNumber];\n    }\n    appendLineTokens(lineTokens) {\n        this._tokens.push(lineTokens);\n    }\n}\n","import { ContiguousMultilineTokens } from './contiguousMultilineTokens.js';\nexport class ContiguousMultilineTokensBuilder {\n    constructor() {\n        this._tokens = [];\n    }\n    add(lineNumber, lineTokens) {\n        if (this._tokens.length > 0) {\n            const last = this._tokens[this._tokens.length - 1];\n            if (last.endLineNumber + 1 === lineNumber) {\n                // append\n                last.appendLineTokens(lineTokens);\n                return;\n            }\n        }\n        this._tokens.push(new ContiguousMultilineTokens(lineNumber, [lineTokens]));\n    }\n    finalize() {\n        return this._tokens;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { runWhenGlobalIdle } from '../../../base/common/async.js';\nimport { BugIndicatingError, onUnexpectedError } from '../../../base/common/errors.js';\nimport { setTimeout0 } from '../../../base/common/platform.js';\nimport { StopWatch } from '../../../base/common/stopwatch.js';\nimport { countEOL } from '../core/eolCounter.js';\nimport { LineRange } from '../core/lineRange.js';\nimport { OffsetRange } from '../core/offsetRange.js';\nimport { nullTokenizeEncoded } from '../languages/nullTokenize.js';\nimport { FixedArray } from './fixedArray.js';\nimport { ContiguousMultilineTokensBuilder } from '../tokens/contiguousMultilineTokensBuilder.js';\nimport { LineTokens } from '../tokens/lineTokens.js';\nexport class TokenizerWithStateStore {\n    constructor(lineCount, tokenizationSupport) {\n        this.tokenizationSupport = tokenizationSupport;\n        this.initialState = this.tokenizationSupport.getInitialState();\n        this.store = new TrackingTokenizationStateStore(lineCount);\n    }\n    getStartState(lineNumber) {\n        return this.store.getStartState(lineNumber, this.initialState);\n    }\n    getFirstInvalidLine() {\n        return this.store.getFirstInvalidLine(this.initialState);\n    }\n}\nexport class TokenizerWithStateStoreAndTextModel extends TokenizerWithStateStore {\n    constructor(lineCount, tokenizationSupport, _textModel, _languageIdCodec) {\n        super(lineCount, tokenizationSupport);\n        this._textModel = _textModel;\n        this._languageIdCodec = _languageIdCodec;\n    }\n    updateTokensUntilLine(builder, lineNumber) {\n        const languageId = this._textModel.getLanguageId();\n        while (true) {\n            const lineToTokenize = this.getFirstInvalidLine();\n            if (!lineToTokenize || lineToTokenize.lineNumber > lineNumber) {\n                break;\n            }\n            const text = this._textModel.getLineContent(lineToTokenize.lineNumber);\n            const r = safeTokenize(this._languageIdCodec, languageId, this.tokenizationSupport, text, true, lineToTokenize.startState);\n            builder.add(lineToTokenize.lineNumber, r.tokens);\n            this.store.setEndState(lineToTokenize.lineNumber, r.endState);\n        }\n    }\n    /** assumes state is up to date */\n    getTokenTypeIfInsertingCharacter(position, character) {\n        // TODO@hediet: use tokenizeLineWithEdit\n        const lineStartState = this.getStartState(position.lineNumber);\n        if (!lineStartState) {\n            return 0 /* StandardTokenType.Other */;\n        }\n        const languageId = this._textModel.getLanguageId();\n        const lineContent = this._textModel.getLineContent(position.lineNumber);\n        // Create the text as if `character` was inserted\n        const text = (lineContent.substring(0, position.column - 1)\n            + character\n            + lineContent.substring(position.column - 1));\n        const r = safeTokenize(this._languageIdCodec, languageId, this.tokenizationSupport, text, true, lineStartState);\n        const lineTokens = new LineTokens(r.tokens, text, this._languageIdCodec);\n        if (lineTokens.getCount() === 0) {\n            return 0 /* StandardTokenType.Other */;\n        }\n        const tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n        return lineTokens.getStandardTokenType(tokenIndex);\n    }\n    /** assumes state is up to date */\n    tokenizeLineWithEdit(position, length, newText) {\n        const lineNumber = position.lineNumber;\n        const column = position.column;\n        const lineStartState = this.getStartState(lineNumber);\n        if (!lineStartState) {\n            return null;\n        }\n        const curLineContent = this._textModel.getLineContent(lineNumber);\n        const newLineContent = curLineContent.substring(0, column - 1)\n            + newText + curLineContent.substring(column - 1 + length);\n        const languageId = this._textModel.getLanguageIdAtPosition(lineNumber, 0);\n        const result = safeTokenize(this._languageIdCodec, languageId, this.tokenizationSupport, newLineContent, true, lineStartState);\n        const lineTokens = new LineTokens(result.tokens, newLineContent, this._languageIdCodec);\n        return lineTokens;\n    }\n    hasAccurateTokensForLine(lineNumber) {\n        const firstInvalidLineNumber = this.store.getFirstInvalidEndStateLineNumberOrMax();\n        return (lineNumber < firstInvalidLineNumber);\n    }\n    isCheapToTokenize(lineNumber) {\n        const firstInvalidLineNumber = this.store.getFirstInvalidEndStateLineNumberOrMax();\n        if (lineNumber < firstInvalidLineNumber) {\n            return true;\n        }\n        if (lineNumber === firstInvalidLineNumber\n            && this._textModel.getLineLength(lineNumber) < 2048 /* Constants.CHEAP_TOKENIZATION_LENGTH_LIMIT */) {\n            return true;\n        }\n        return false;\n    }\n    /**\n     * The result is not cached.\n     */\n    tokenizeHeuristically(builder, startLineNumber, endLineNumber) {\n        if (endLineNumber <= this.store.getFirstInvalidEndStateLineNumberOrMax()) {\n            // nothing to do\n            return { heuristicTokens: false };\n        }\n        if (startLineNumber <= this.store.getFirstInvalidEndStateLineNumberOrMax()) {\n            // tokenization has reached the viewport start...\n            this.updateTokensUntilLine(builder, endLineNumber);\n            return { heuristicTokens: false };\n        }\n        let state = this.guessStartState(startLineNumber);\n        const languageId = this._textModel.getLanguageId();\n        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n            const text = this._textModel.getLineContent(lineNumber);\n            const r = safeTokenize(this._languageIdCodec, languageId, this.tokenizationSupport, text, true, state);\n            builder.add(lineNumber, r.tokens);\n            state = r.endState;\n        }\n        return { heuristicTokens: true };\n    }\n    guessStartState(lineNumber) {\n        let nonWhitespaceColumn = this._textModel.getLineFirstNonWhitespaceColumn(lineNumber);\n        const likelyRelevantLines = [];\n        let initialState = null;\n        for (let i = lineNumber - 1; nonWhitespaceColumn > 1 && i >= 1; i--) {\n            const newNonWhitespaceIndex = this._textModel.getLineFirstNonWhitespaceColumn(i);\n            // Ignore lines full of whitespace\n            if (newNonWhitespaceIndex === 0) {\n                continue;\n            }\n            if (newNonWhitespaceIndex < nonWhitespaceColumn) {\n                likelyRelevantLines.push(this._textModel.getLineContent(i));\n                nonWhitespaceColumn = newNonWhitespaceIndex;\n                initialState = this.getStartState(i);\n                if (initialState) {\n                    break;\n                }\n            }\n        }\n        if (!initialState) {\n            initialState = this.tokenizationSupport.getInitialState();\n        }\n        likelyRelevantLines.reverse();\n        const languageId = this._textModel.getLanguageId();\n        let state = initialState;\n        for (const line of likelyRelevantLines) {\n            const r = safeTokenize(this._languageIdCodec, languageId, this.tokenizationSupport, line, false, state);\n            state = r.endState;\n        }\n        return state;\n    }\n}\n/**\n * **Invariant:**\n * If the text model is retokenized from line 1 to {@link getFirstInvalidEndStateLineNumber}() - 1,\n * then the recomputed end state for line l will be equal to {@link getEndState}(l).\n */\nexport class TrackingTokenizationStateStore {\n    constructor(lineCount) {\n        this.lineCount = lineCount;\n        this._tokenizationStateStore = new TokenizationStateStore();\n        this._invalidEndStatesLineNumbers = new RangePriorityQueueImpl();\n        this._invalidEndStatesLineNumbers.addRange(new OffsetRange(1, lineCount + 1));\n    }\n    getEndState(lineNumber) {\n        return this._tokenizationStateStore.getEndState(lineNumber);\n    }\n    /**\n     * @returns if the end state has changed.\n     */\n    setEndState(lineNumber, state) {\n        if (!state) {\n            throw new BugIndicatingError('Cannot set null/undefined state');\n        }\n        this._invalidEndStatesLineNumbers.delete(lineNumber);\n        const r = this._tokenizationStateStore.setEndState(lineNumber, state);\n        if (r && lineNumber < this.lineCount) {\n            // because the state changed, we cannot trust the next state anymore and have to invalidate it.\n            this._invalidEndStatesLineNumbers.addRange(new OffsetRange(lineNumber + 1, lineNumber + 2));\n        }\n        return r;\n    }\n    acceptChange(range, newLineCount) {\n        this.lineCount += newLineCount - range.length;\n        this._tokenizationStateStore.acceptChange(range, newLineCount);\n        this._invalidEndStatesLineNumbers.addRangeAndResize(new OffsetRange(range.startLineNumber, range.endLineNumberExclusive), newLineCount);\n    }\n    acceptChanges(changes) {\n        for (const c of changes) {\n            const [eolCount] = countEOL(c.text);\n            this.acceptChange(new LineRange(c.range.startLineNumber, c.range.endLineNumber + 1), eolCount + 1);\n        }\n    }\n    invalidateEndStateRange(range) {\n        this._invalidEndStatesLineNumbers.addRange(new OffsetRange(range.startLineNumber, range.endLineNumberExclusive));\n    }\n    getFirstInvalidEndStateLineNumber() { return this._invalidEndStatesLineNumbers.min; }\n    getFirstInvalidEndStateLineNumberOrMax() {\n        return this.getFirstInvalidEndStateLineNumber() || Number.MAX_SAFE_INTEGER;\n    }\n    allStatesValid() { return this._invalidEndStatesLineNumbers.min === null; }\n    getStartState(lineNumber, initialState) {\n        if (lineNumber === 1) {\n            return initialState;\n        }\n        return this.getEndState(lineNumber - 1);\n    }\n    getFirstInvalidLine(initialState) {\n        const lineNumber = this.getFirstInvalidEndStateLineNumber();\n        if (lineNumber === null) {\n            return null;\n        }\n        const startState = this.getStartState(lineNumber, initialState);\n        if (!startState) {\n            throw new BugIndicatingError('Start state must be defined');\n        }\n        return { lineNumber, startState };\n    }\n}\nexport class TokenizationStateStore {\n    constructor() {\n        this._lineEndStates = new FixedArray(null);\n    }\n    getEndState(lineNumber) {\n        return this._lineEndStates.get(lineNumber);\n    }\n    setEndState(lineNumber, state) {\n        const oldState = this._lineEndStates.get(lineNumber);\n        if (oldState && oldState.equals(state)) {\n            return false;\n        }\n        this._lineEndStates.set(lineNumber, state);\n        return true;\n    }\n    acceptChange(range, newLineCount) {\n        let length = range.length;\n        if (newLineCount > 0 && length > 0) {\n            // Keep the last state, even though it is unrelated.\n            // But if the new state happens to agree with this last state, then we know we can stop tokenizing.\n            length--;\n            newLineCount--;\n        }\n        this._lineEndStates.replace(range.startLineNumber, length, newLineCount);\n    }\n}\nexport class RangePriorityQueueImpl {\n    constructor() {\n        this._ranges = [];\n    }\n    get min() {\n        if (this._ranges.length === 0) {\n            return null;\n        }\n        return this._ranges[0].start;\n    }\n    delete(value) {\n        const idx = this._ranges.findIndex(r => r.contains(value));\n        if (idx !== -1) {\n            const range = this._ranges[idx];\n            if (range.start === value) {\n                if (range.endExclusive === value + 1) {\n                    this._ranges.splice(idx, 1);\n                }\n                else {\n                    this._ranges[idx] = new OffsetRange(value + 1, range.endExclusive);\n                }\n            }\n            else {\n                if (range.endExclusive === value + 1) {\n                    this._ranges[idx] = new OffsetRange(range.start, value);\n                }\n                else {\n                    this._ranges.splice(idx, 1, new OffsetRange(range.start, value), new OffsetRange(value + 1, range.endExclusive));\n                }\n            }\n        }\n    }\n    addRange(range) {\n        OffsetRange.addRange(range, this._ranges);\n    }\n    addRangeAndResize(range, newLength) {\n        let idxFirstMightBeIntersecting = 0;\n        while (!(idxFirstMightBeIntersecting >= this._ranges.length || range.start <= this._ranges[idxFirstMightBeIntersecting].endExclusive)) {\n            idxFirstMightBeIntersecting++;\n        }\n        let idxFirstIsAfter = idxFirstMightBeIntersecting;\n        while (!(idxFirstIsAfter >= this._ranges.length || range.endExclusive < this._ranges[idxFirstIsAfter].start)) {\n            idxFirstIsAfter++;\n        }\n        const delta = newLength - range.length;\n        for (let i = idxFirstIsAfter; i < this._ranges.length; i++) {\n            this._ranges[i] = this._ranges[i].delta(delta);\n        }\n        if (idxFirstMightBeIntersecting === idxFirstIsAfter) {\n            const newRange = new OffsetRange(range.start, range.start + newLength);\n            if (!newRange.isEmpty) {\n                this._ranges.splice(idxFirstMightBeIntersecting, 0, newRange);\n            }\n        }\n        else {\n            const start = Math.min(range.start, this._ranges[idxFirstMightBeIntersecting].start);\n            const endEx = Math.max(range.endExclusive, this._ranges[idxFirstIsAfter - 1].endExclusive);\n            const newRange = new OffsetRange(start, endEx + delta);\n            if (!newRange.isEmpty) {\n                this._ranges.splice(idxFirstMightBeIntersecting, idxFirstIsAfter - idxFirstMightBeIntersecting, newRange);\n            }\n            else {\n                this._ranges.splice(idxFirstMightBeIntersecting, idxFirstIsAfter - idxFirstMightBeIntersecting);\n            }\n        }\n    }\n    toString() {\n        return this._ranges.map(r => r.toString()).join(' + ');\n    }\n}\nfunction safeTokenize(languageIdCodec, languageId, tokenizationSupport, text, hasEOL, state) {\n    let r = null;\n    if (tokenizationSupport) {\n        try {\n            r = tokenizationSupport.tokenizeEncoded(text, hasEOL, state.clone());\n        }\n        catch (e) {\n            onUnexpectedError(e);\n        }\n    }\n    if (!r) {\n        r = nullTokenizeEncoded(languageIdCodec.encodeLanguageId(languageId), state);\n    }\n    LineTokens.convertToEndOffset(r.tokens, text.length);\n    return r;\n}\nexport class DefaultBackgroundTokenizer {\n    constructor(_tokenizerWithStateStore, _backgroundTokenStore) {\n        this._tokenizerWithStateStore = _tokenizerWithStateStore;\n        this._backgroundTokenStore = _backgroundTokenStore;\n        this._isDisposed = false;\n        this._isScheduled = false;\n    }\n    dispose() {\n        this._isDisposed = true;\n    }\n    handleChanges() {\n        this._beginBackgroundTokenization();\n    }\n    _beginBackgroundTokenization() {\n        if (this._isScheduled || !this._tokenizerWithStateStore._textModel.isAttachedToEditor() || !this._hasLinesToTokenize()) {\n            return;\n        }\n        this._isScheduled = true;\n        runWhenGlobalIdle((deadline) => {\n            this._isScheduled = false;\n            this._backgroundTokenizeWithDeadline(deadline);\n        });\n    }\n    /**\n     * Tokenize until the deadline occurs, but try to yield every 1-2ms.\n     */\n    _backgroundTokenizeWithDeadline(deadline) {\n        // Read the time remaining from the `deadline` immediately because it is unclear\n        // if the `deadline` object will be valid after execution leaves this function.\n        const endTime = Date.now() + deadline.timeRemaining();\n        const execute = () => {\n            if (this._isDisposed || !this._tokenizerWithStateStore._textModel.isAttachedToEditor() || !this._hasLinesToTokenize()) {\n                // disposed in the meantime or detached or finished\n                return;\n            }\n            this._backgroundTokenizeForAtLeast1ms();\n            if (Date.now() < endTime) {\n                // There is still time before reaching the deadline, so yield to the browser and then\n                // continue execution\n                setTimeout0(execute);\n            }\n            else {\n                // The deadline has been reached, so schedule a new idle callback if necessary\n                this._beginBackgroundTokenization();\n            }\n        };\n        execute();\n    }\n    /**\n     * Tokenize for at least 1ms.\n     */\n    _backgroundTokenizeForAtLeast1ms() {\n        const lineCount = this._tokenizerWithStateStore._textModel.getLineCount();\n        const builder = new ContiguousMultilineTokensBuilder();\n        const sw = StopWatch.create(false);\n        do {\n            if (sw.elapsed() > 1) {\n                // the comparison is intentionally > 1 and not >= 1 to ensure that\n                // a full millisecond has elapsed, given how microseconds are rounded\n                // to milliseconds\n                break;\n            }\n            const tokenizedLineNumber = this._tokenizeOneInvalidLine(builder);\n            if (tokenizedLineNumber >= lineCount) {\n                break;\n            }\n        } while (this._hasLinesToTokenize());\n        this._backgroundTokenStore.setTokens(builder.finalize());\n        this.checkFinished();\n    }\n    _hasLinesToTokenize() {\n        if (!this._tokenizerWithStateStore) {\n            return false;\n        }\n        return !this._tokenizerWithStateStore.store.allStatesValid();\n    }\n    _tokenizeOneInvalidLine(builder) {\n        const firstInvalidLine = this._tokenizerWithStateStore?.getFirstInvalidLine();\n        if (!firstInvalidLine) {\n            return this._tokenizerWithStateStore._textModel.getLineCount() + 1;\n        }\n        this._tokenizerWithStateStore.updateTokensUntilLine(builder, firstInvalidLine.lineNumber);\n        return firstInvalidLine.lineNumber;\n    }\n    checkFinished() {\n        if (this._isDisposed) {\n            return;\n        }\n        if (this._tokenizerWithStateStore.store.allStatesValid()) {\n            this._backgroundTokenStore.backgroundTokenizationFinished();\n        }\n    }\n    requestTokens(startLineNumber, endLineNumberExclusive) {\n        this._tokenizerWithStateStore.store.invalidateEndStateRange(new LineRange(startLineNumber, endLineNumberExclusive));\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { equals } from '../../../base/common/arrays.js';\nimport { RunOnceScheduler } from '../../../base/common/async.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport { LineRange } from '../core/lineRange.js';\n/**\n * @internal\n */\nexport class AttachedViews {\n    constructor() {\n        this._onDidChangeVisibleRanges = new Emitter();\n        this.onDidChangeVisibleRanges = this._onDidChangeVisibleRanges.event;\n        this._views = new Set();\n    }\n    attachView() {\n        const view = new AttachedViewImpl((state) => {\n            this._onDidChangeVisibleRanges.fire({ view, state });\n        });\n        this._views.add(view);\n        return view;\n    }\n    detachView(view) {\n        this._views.delete(view);\n        this._onDidChangeVisibleRanges.fire({ view, state: undefined });\n    }\n}\nclass AttachedViewImpl {\n    constructor(handleStateChange) {\n        this.handleStateChange = handleStateChange;\n    }\n    setVisibleLines(visibleLines, stabilized) {\n        const visibleLineRanges = visibleLines.map((line) => new LineRange(line.startLineNumber, line.endLineNumber + 1));\n        this.handleStateChange({ visibleLineRanges, stabilized });\n    }\n}\nexport class AttachedViewHandler extends Disposable {\n    get lineRanges() { return this._lineRanges; }\n    constructor(_refreshTokens) {\n        super();\n        this._refreshTokens = _refreshTokens;\n        this.runner = this._register(new RunOnceScheduler(() => this.update(), 50));\n        this._computedLineRanges = [];\n        this._lineRanges = [];\n    }\n    update() {\n        if (equals(this._computedLineRanges, this._lineRanges, (a, b) => a.equals(b))) {\n            return;\n        }\n        this._computedLineRanges = this._lineRanges;\n        this._refreshTokens();\n    }\n    handleStateChange(state) {\n        this._lineRanges = state.visibleLineRanges;\n        if (state.stabilized) {\n            this.runner.cancel();\n            this.update();\n        }\n        else {\n            this.runner.schedule();\n        }\n    }\n}\nexport class AbstractTokens extends Disposable {\n    get backgroundTokenizationState() {\n        return this._backgroundTokenizationState;\n    }\n    constructor(_languageIdCodec, _textModel, getLanguageId) {\n        super();\n        this._languageIdCodec = _languageIdCodec;\n        this._textModel = _textModel;\n        this.getLanguageId = getLanguageId;\n        this._backgroundTokenizationState = 1 /* BackgroundTokenizationState.InProgress */;\n        this._onDidChangeBackgroundTokenizationState = this._register(new Emitter());\n        /** @internal, should not be exposed by the text model! */\n        this.onDidChangeBackgroundTokenizationState = this._onDidChangeBackgroundTokenizationState.event;\n        this._onDidChangeTokens = this._register(new Emitter());\n        /** @internal, should not be exposed by the text model! */\n        this.onDidChangeTokens = this._onDidChangeTokens.event;\n    }\n    tokenizeIfCheap(lineNumber) {\n        if (this.isCheapToTokenize(lineNumber)) {\n            this.forceTokenization(lineNumber);\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { TreeSitterTokenizationRegistry } from '../languages.js';\nimport { LineTokens } from '../tokens/lineTokens.js';\nimport { AbstractTokens } from './tokens.js';\nexport class TreeSitterTokens extends AbstractTokens {\n    constructor(_treeSitterService, languageIdCodec, textModel, languageId) {\n        super(languageIdCodec, textModel, languageId);\n        this._treeSitterService = _treeSitterService;\n        this._tokenizationSupport = null;\n        this._initialize();\n    }\n    _initialize() {\n        const newLanguage = this.getLanguageId();\n        if (!this._tokenizationSupport || this._lastLanguageId !== newLanguage) {\n            this._lastLanguageId = newLanguage;\n            this._tokenizationSupport = TreeSitterTokenizationRegistry.get(newLanguage);\n        }\n    }\n    getLineTokens(lineNumber) {\n        const content = this._textModel.getLineContent(lineNumber);\n        if (this._tokenizationSupport) {\n            const rawTokens = this._tokenizationSupport.tokenizeEncoded(lineNumber, this._textModel);\n            if (rawTokens) {\n                return new LineTokens(rawTokens, content, this._languageIdCodec);\n            }\n        }\n        return LineTokens.createEmpty(content, this._languageIdCodec);\n    }\n    resetTokenization(fireTokenChangeEvent = true) {\n        if (fireTokenChangeEvent) {\n            this._onDidChangeTokens.fire({\n                semanticTokensApplied: false,\n                ranges: [\n                    {\n                        fromLineNumber: 1,\n                        toLineNumber: this._textModel.getLineCount(),\n                    },\n                ],\n            });\n        }\n        this._initialize();\n    }\n    handleDidChangeAttached() {\n        // TODO @alexr00 implement for background tokenization\n    }\n    handleDidChangeContent(e) {\n        if (e.isFlush) {\n            // Don't fire the event, as the view might not have got the text change event yet\n            this.resetTokenization(false);\n        }\n    }\n    forceTokenization(lineNumber) {\n        // TODO @alexr00 implement\n    }\n    hasAccurateTokensForLine(lineNumber) {\n        // TODO @alexr00 update for background tokenization\n        return true;\n    }\n    isCheapToTokenize(lineNumber) {\n        // TODO @alexr00 update for background tokenization\n        return true;\n    }\n    getTokenTypeIfInsertingCharacter(lineNumber, column, character) {\n        // TODO @alexr00 implement once we have custom parsing and don't just feed in the whole text model value\n        return 0 /* StandardTokenType.Other */;\n    }\n    tokenizeLineWithEdit(position, length, newText) {\n        // TODO @alexr00 understand what this is for and implement\n        return null;\n    }\n    get hasTokens() {\n        // TODO @alexr00 once we have a token store, implement properly\n        const hasTree = this._treeSitterService.getParseResult(this._textModel) !== undefined;\n        return hasTree;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { LineTokens } from './lineTokens.js';\nexport const EMPTY_LINE_TOKENS = (new Uint32Array(0)).buffer;\nexport class ContiguousTokensEditing {\n    static deleteBeginning(lineTokens, toChIndex) {\n        if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS) {\n            return lineTokens;\n        }\n        return ContiguousTokensEditing.delete(lineTokens, 0, toChIndex);\n    }\n    static deleteEnding(lineTokens, fromChIndex) {\n        if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS) {\n            return lineTokens;\n        }\n        const tokens = toUint32Array(lineTokens);\n        const lineTextLength = tokens[tokens.length - 2];\n        return ContiguousTokensEditing.delete(lineTokens, fromChIndex, lineTextLength);\n    }\n    static delete(lineTokens, fromChIndex, toChIndex) {\n        if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS || fromChIndex === toChIndex) {\n            return lineTokens;\n        }\n        const tokens = toUint32Array(lineTokens);\n        const tokensCount = (tokens.length >>> 1);\n        // special case: deleting everything\n        if (fromChIndex === 0 && tokens[tokens.length - 2] === toChIndex) {\n            return EMPTY_LINE_TOKENS;\n        }\n        const fromTokenIndex = LineTokens.findIndexInTokensArray(tokens, fromChIndex);\n        const fromTokenStartOffset = (fromTokenIndex > 0 ? tokens[(fromTokenIndex - 1) << 1] : 0);\n        const fromTokenEndOffset = tokens[fromTokenIndex << 1];\n        if (toChIndex < fromTokenEndOffset) {\n            // the delete range is inside a single token\n            const delta = (toChIndex - fromChIndex);\n            for (let i = fromTokenIndex; i < tokensCount; i++) {\n                tokens[i << 1] -= delta;\n            }\n            return lineTokens;\n        }\n        let dest;\n        let lastEnd;\n        if (fromTokenStartOffset !== fromChIndex) {\n            tokens[fromTokenIndex << 1] = fromChIndex;\n            dest = ((fromTokenIndex + 1) << 1);\n            lastEnd = fromChIndex;\n        }\n        else {\n            dest = (fromTokenIndex << 1);\n            lastEnd = fromTokenStartOffset;\n        }\n        const delta = (toChIndex - fromChIndex);\n        for (let tokenIndex = fromTokenIndex + 1; tokenIndex < tokensCount; tokenIndex++) {\n            const tokenEndOffset = tokens[tokenIndex << 1] - delta;\n            if (tokenEndOffset > lastEnd) {\n                tokens[dest++] = tokenEndOffset;\n                tokens[dest++] = tokens[(tokenIndex << 1) + 1];\n                lastEnd = tokenEndOffset;\n            }\n        }\n        if (dest === tokens.length) {\n            // nothing to trim\n            return lineTokens;\n        }\n        const tmp = new Uint32Array(dest);\n        tmp.set(tokens.subarray(0, dest), 0);\n        return tmp.buffer;\n    }\n    static append(lineTokens, _otherTokens) {\n        if (_otherTokens === EMPTY_LINE_TOKENS) {\n            return lineTokens;\n        }\n        if (lineTokens === EMPTY_LINE_TOKENS) {\n            return _otherTokens;\n        }\n        if (lineTokens === null) {\n            return lineTokens;\n        }\n        if (_otherTokens === null) {\n            // cannot determine combined line length...\n            return null;\n        }\n        const myTokens = toUint32Array(lineTokens);\n        const otherTokens = toUint32Array(_otherTokens);\n        const otherTokensCount = (otherTokens.length >>> 1);\n        const result = new Uint32Array(myTokens.length + otherTokens.length);\n        result.set(myTokens, 0);\n        let dest = myTokens.length;\n        const delta = myTokens[myTokens.length - 2];\n        for (let i = 0; i < otherTokensCount; i++) {\n            result[dest++] = otherTokens[(i << 1)] + delta;\n            result[dest++] = otherTokens[(i << 1) + 1];\n        }\n        return result.buffer;\n    }\n    static insert(lineTokens, chIndex, textLength) {\n        if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS) {\n            // nothing to do\n            return lineTokens;\n        }\n        const tokens = toUint32Array(lineTokens);\n        const tokensCount = (tokens.length >>> 1);\n        let fromTokenIndex = LineTokens.findIndexInTokensArray(tokens, chIndex);\n        if (fromTokenIndex > 0) {\n            const fromTokenStartOffset = tokens[(fromTokenIndex - 1) << 1];\n            if (fromTokenStartOffset === chIndex) {\n                fromTokenIndex--;\n            }\n        }\n        for (let tokenIndex = fromTokenIndex; tokenIndex < tokensCount; tokenIndex++) {\n            tokens[tokenIndex << 1] += textLength;\n        }\n        return lineTokens;\n    }\n}\nexport function toUint32Array(arr) {\n    if (arr instanceof Uint32Array) {\n        return arr;\n    }\n    else {\n        return new Uint32Array(arr);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as arrays from '../../../base/common/arrays.js';\nimport { Position } from '../core/position.js';\nimport { ContiguousTokensEditing, EMPTY_LINE_TOKENS, toUint32Array } from './contiguousTokensEditing.js';\nimport { LineTokens } from './lineTokens.js';\nimport { TokenMetadata } from '../encodedTokenAttributes.js';\n/**\n * Represents contiguous tokens in a text model.\n */\nexport class ContiguousTokensStore {\n    constructor(languageIdCodec) {\n        this._lineTokens = [];\n        this._len = 0;\n        this._languageIdCodec = languageIdCodec;\n    }\n    flush() {\n        this._lineTokens = [];\n        this._len = 0;\n    }\n    get hasTokens() {\n        return this._lineTokens.length > 0;\n    }\n    getTokens(topLevelLanguageId, lineIndex, lineText) {\n        let rawLineTokens = null;\n        if (lineIndex < this._len) {\n            rawLineTokens = this._lineTokens[lineIndex];\n        }\n        if (rawLineTokens !== null && rawLineTokens !== EMPTY_LINE_TOKENS) {\n            return new LineTokens(toUint32Array(rawLineTokens), lineText, this._languageIdCodec);\n        }\n        const lineTokens = new Uint32Array(2);\n        lineTokens[0] = lineText.length;\n        lineTokens[1] = getDefaultMetadata(this._languageIdCodec.encodeLanguageId(topLevelLanguageId));\n        return new LineTokens(lineTokens, lineText, this._languageIdCodec);\n    }\n    static _massageTokens(topLevelLanguageId, lineTextLength, _tokens) {\n        const tokens = _tokens ? toUint32Array(_tokens) : null;\n        if (lineTextLength === 0) {\n            let hasDifferentLanguageId = false;\n            if (tokens && tokens.length > 1) {\n                hasDifferentLanguageId = (TokenMetadata.getLanguageId(tokens[1]) !== topLevelLanguageId);\n            }\n            if (!hasDifferentLanguageId) {\n                return EMPTY_LINE_TOKENS;\n            }\n        }\n        if (!tokens || tokens.length === 0) {\n            const tokens = new Uint32Array(2);\n            tokens[0] = lineTextLength;\n            tokens[1] = getDefaultMetadata(topLevelLanguageId);\n            return tokens.buffer;\n        }\n        // Ensure the last token covers the end of the text\n        tokens[tokens.length - 2] = lineTextLength;\n        if (tokens.byteOffset === 0 && tokens.byteLength === tokens.buffer.byteLength) {\n            // Store directly the ArrayBuffer pointer to save an object\n            return tokens.buffer;\n        }\n        return tokens;\n    }\n    _ensureLine(lineIndex) {\n        while (lineIndex >= this._len) {\n            this._lineTokens[this._len] = null;\n            this._len++;\n        }\n    }\n    _deleteLines(start, deleteCount) {\n        if (deleteCount === 0) {\n            return;\n        }\n        if (start + deleteCount > this._len) {\n            deleteCount = this._len - start;\n        }\n        this._lineTokens.splice(start, deleteCount);\n        this._len -= deleteCount;\n    }\n    _insertLines(insertIndex, insertCount) {\n        if (insertCount === 0) {\n            return;\n        }\n        const lineTokens = [];\n        for (let i = 0; i < insertCount; i++) {\n            lineTokens[i] = null;\n        }\n        this._lineTokens = arrays.arrayInsert(this._lineTokens, insertIndex, lineTokens);\n        this._len += insertCount;\n    }\n    setTokens(topLevelLanguageId, lineIndex, lineTextLength, _tokens, checkEquality) {\n        const tokens = ContiguousTokensStore._massageTokens(this._languageIdCodec.encodeLanguageId(topLevelLanguageId), lineTextLength, _tokens);\n        this._ensureLine(lineIndex);\n        const oldTokens = this._lineTokens[lineIndex];\n        this._lineTokens[lineIndex] = tokens;\n        if (checkEquality) {\n            return !ContiguousTokensStore._equals(oldTokens, tokens);\n        }\n        return false;\n    }\n    static _equals(_a, _b) {\n        if (!_a || !_b) {\n            return !_a && !_b;\n        }\n        const a = toUint32Array(_a);\n        const b = toUint32Array(_b);\n        if (a.length !== b.length) {\n            return false;\n        }\n        for (let i = 0, len = a.length; i < len; i++) {\n            if (a[i] !== b[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    //#region Editing\n    acceptEdit(range, eolCount, firstLineLength) {\n        this._acceptDeleteRange(range);\n        this._acceptInsertText(new Position(range.startLineNumber, range.startColumn), eolCount, firstLineLength);\n    }\n    _acceptDeleteRange(range) {\n        const firstLineIndex = range.startLineNumber - 1;\n        if (firstLineIndex >= this._len) {\n            return;\n        }\n        if (range.startLineNumber === range.endLineNumber) {\n            if (range.startColumn === range.endColumn) {\n                // Nothing to delete\n                return;\n            }\n            this._lineTokens[firstLineIndex] = ContiguousTokensEditing.delete(this._lineTokens[firstLineIndex], range.startColumn - 1, range.endColumn - 1);\n            return;\n        }\n        this._lineTokens[firstLineIndex] = ContiguousTokensEditing.deleteEnding(this._lineTokens[firstLineIndex], range.startColumn - 1);\n        const lastLineIndex = range.endLineNumber - 1;\n        let lastLineTokens = null;\n        if (lastLineIndex < this._len) {\n            lastLineTokens = ContiguousTokensEditing.deleteBeginning(this._lineTokens[lastLineIndex], range.endColumn - 1);\n        }\n        // Take remaining text on last line and append it to remaining text on first line\n        this._lineTokens[firstLineIndex] = ContiguousTokensEditing.append(this._lineTokens[firstLineIndex], lastLineTokens);\n        // Delete middle lines\n        this._deleteLines(range.startLineNumber, range.endLineNumber - range.startLineNumber);\n    }\n    _acceptInsertText(position, eolCount, firstLineLength) {\n        if (eolCount === 0 && firstLineLength === 0) {\n            // Nothing to insert\n            return;\n        }\n        const lineIndex = position.lineNumber - 1;\n        if (lineIndex >= this._len) {\n            return;\n        }\n        if (eolCount === 0) {\n            // Inserting text on one line\n            this._lineTokens[lineIndex] = ContiguousTokensEditing.insert(this._lineTokens[lineIndex], position.column - 1, firstLineLength);\n            return;\n        }\n        this._lineTokens[lineIndex] = ContiguousTokensEditing.deleteEnding(this._lineTokens[lineIndex], position.column - 1);\n        this._lineTokens[lineIndex] = ContiguousTokensEditing.insert(this._lineTokens[lineIndex], position.column - 1, firstLineLength);\n        this._insertLines(position.lineNumber, eolCount);\n    }\n    //#endregion\n    setMultilineTokens(tokens, textModel) {\n        if (tokens.length === 0) {\n            return { changes: [] };\n        }\n        const ranges = [];\n        for (let i = 0, len = tokens.length; i < len; i++) {\n            const element = tokens[i];\n            let minChangedLineNumber = 0;\n            let maxChangedLineNumber = 0;\n            let hasChange = false;\n            for (let lineNumber = element.startLineNumber; lineNumber <= element.endLineNumber; lineNumber++) {\n                if (hasChange) {\n                    this.setTokens(textModel.getLanguageId(), lineNumber - 1, textModel.getLineLength(lineNumber), element.getLineTokens(lineNumber), false);\n                    maxChangedLineNumber = lineNumber;\n                }\n                else {\n                    const lineHasChange = this.setTokens(textModel.getLanguageId(), lineNumber - 1, textModel.getLineLength(lineNumber), element.getLineTokens(lineNumber), true);\n                    if (lineHasChange) {\n                        hasChange = true;\n                        minChangedLineNumber = lineNumber;\n                        maxChangedLineNumber = lineNumber;\n                    }\n                }\n            }\n            if (hasChange) {\n                ranges.push({ fromLineNumber: minChangedLineNumber, toLineNumber: maxChangedLineNumber, });\n            }\n        }\n        return { changes: ranges };\n    }\n}\nfunction getDefaultMetadata(topLevelLanguageId) {\n    return ((topLevelLanguageId << 0 /* MetadataConsts.LANGUAGEID_OFFSET */)\n        | (0 /* StandardTokenType.Other */ << 8 /* MetadataConsts.TOKEN_TYPE_OFFSET */)\n        | (0 /* FontStyle.None */ << 11 /* MetadataConsts.FONT_STYLE_OFFSET */)\n        | (1 /* ColorId.DefaultForeground */ << 15 /* MetadataConsts.FOREGROUND_OFFSET */)\n        | (2 /* ColorId.DefaultBackground */ << 24 /* MetadataConsts.BACKGROUND_OFFSET */)\n        // If there is no grammar, we just take a guess and try to match brackets.\n        | (1024 /* MetadataConsts.BALANCED_BRACKETS_MASK */)) >>> 0;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as arrays from '../../../base/common/arrays.js';\nimport { LineTokens } from './lineTokens.js';\n/**\n * Represents sparse tokens in a text model.\n */\nexport class SparseTokensStore {\n    constructor(languageIdCodec) {\n        this._pieces = [];\n        this._isComplete = false;\n        this._languageIdCodec = languageIdCodec;\n    }\n    flush() {\n        this._pieces = [];\n        this._isComplete = false;\n    }\n    isEmpty() {\n        return (this._pieces.length === 0);\n    }\n    set(pieces, isComplete) {\n        this._pieces = pieces || [];\n        this._isComplete = isComplete;\n    }\n    setPartial(_range, pieces) {\n        // console.log(`setPartial ${_range} ${pieces.map(p => p.toString()).join(', ')}`);\n        let range = _range;\n        if (pieces.length > 0) {\n            const _firstRange = pieces[0].getRange();\n            const _lastRange = pieces[pieces.length - 1].getRange();\n            if (!_firstRange || !_lastRange) {\n                return _range;\n            }\n            range = _range.plusRange(_firstRange).plusRange(_lastRange);\n        }\n        let insertPosition = null;\n        for (let i = 0, len = this._pieces.length; i < len; i++) {\n            const piece = this._pieces[i];\n            if (piece.endLineNumber < range.startLineNumber) {\n                // this piece is before the range\n                continue;\n            }\n            if (piece.startLineNumber > range.endLineNumber) {\n                // this piece is after the range, so mark the spot before this piece\n                // as a good insertion position and stop looping\n                insertPosition = insertPosition || { index: i };\n                break;\n            }\n            // this piece might intersect with the range\n            piece.removeTokens(range);\n            if (piece.isEmpty()) {\n                // remove the piece if it became empty\n                this._pieces.splice(i, 1);\n                i--;\n                len--;\n                continue;\n            }\n            if (piece.endLineNumber < range.startLineNumber) {\n                // after removal, this piece is before the range\n                continue;\n            }\n            if (piece.startLineNumber > range.endLineNumber) {\n                // after removal, this piece is after the range\n                insertPosition = insertPosition || { index: i };\n                continue;\n            }\n            // after removal, this piece contains the range\n            const [a, b] = piece.split(range);\n            if (a.isEmpty()) {\n                // this piece is actually after the range\n                insertPosition = insertPosition || { index: i };\n                continue;\n            }\n            if (b.isEmpty()) {\n                // this piece is actually before the range\n                continue;\n            }\n            this._pieces.splice(i, 1, a, b);\n            i++;\n            len++;\n            insertPosition = insertPosition || { index: i };\n        }\n        insertPosition = insertPosition || { index: this._pieces.length };\n        if (pieces.length > 0) {\n            this._pieces = arrays.arrayInsert(this._pieces, insertPosition.index, pieces);\n        }\n        // console.log(`I HAVE ${this._pieces.length} pieces`);\n        // console.log(`${this._pieces.map(p => p.toString()).join('\\n')}`);\n        return range;\n    }\n    isComplete() {\n        return this._isComplete;\n    }\n    addSparseTokens(lineNumber, aTokens) {\n        if (aTokens.getLineContent().length === 0) {\n            // Don't do anything for empty lines\n            return aTokens;\n        }\n        const pieces = this._pieces;\n        if (pieces.length === 0) {\n            return aTokens;\n        }\n        const pieceIndex = SparseTokensStore._findFirstPieceWithLine(pieces, lineNumber);\n        const bTokens = pieces[pieceIndex].getLineTokens(lineNumber);\n        if (!bTokens) {\n            return aTokens;\n        }\n        const aLen = aTokens.getCount();\n        const bLen = bTokens.getCount();\n        let aIndex = 0;\n        const result = [];\n        let resultLen = 0;\n        let lastEndOffset = 0;\n        const emitToken = (endOffset, metadata) => {\n            if (endOffset === lastEndOffset) {\n                return;\n            }\n            lastEndOffset = endOffset;\n            result[resultLen++] = endOffset;\n            result[resultLen++] = metadata;\n        };\n        for (let bIndex = 0; bIndex < bLen; bIndex++) {\n            const bStartCharacter = bTokens.getStartCharacter(bIndex);\n            const bEndCharacter = bTokens.getEndCharacter(bIndex);\n            const bMetadata = bTokens.getMetadata(bIndex);\n            const bMask = (((bMetadata & 1 /* MetadataConsts.SEMANTIC_USE_ITALIC */) ? 2048 /* MetadataConsts.ITALIC_MASK */ : 0)\n                | ((bMetadata & 2 /* MetadataConsts.SEMANTIC_USE_BOLD */) ? 4096 /* MetadataConsts.BOLD_MASK */ : 0)\n                | ((bMetadata & 4 /* MetadataConsts.SEMANTIC_USE_UNDERLINE */) ? 8192 /* MetadataConsts.UNDERLINE_MASK */ : 0)\n                | ((bMetadata & 8 /* MetadataConsts.SEMANTIC_USE_STRIKETHROUGH */) ? 16384 /* MetadataConsts.STRIKETHROUGH_MASK */ : 0)\n                | ((bMetadata & 16 /* MetadataConsts.SEMANTIC_USE_FOREGROUND */) ? 16744448 /* MetadataConsts.FOREGROUND_MASK */ : 0)\n                | ((bMetadata & 32 /* MetadataConsts.SEMANTIC_USE_BACKGROUND */) ? 4278190080 /* MetadataConsts.BACKGROUND_MASK */ : 0)) >>> 0;\n            const aMask = (~bMask) >>> 0;\n            // push any token from `a` that is before `b`\n            while (aIndex < aLen && aTokens.getEndOffset(aIndex) <= bStartCharacter) {\n                emitToken(aTokens.getEndOffset(aIndex), aTokens.getMetadata(aIndex));\n                aIndex++;\n            }\n            // push the token from `a` if it intersects the token from `b`\n            if (aIndex < aLen && aTokens.getStartOffset(aIndex) < bStartCharacter) {\n                emitToken(bStartCharacter, aTokens.getMetadata(aIndex));\n            }\n            // skip any tokens from `a` that are contained inside `b`\n            while (aIndex < aLen && aTokens.getEndOffset(aIndex) < bEndCharacter) {\n                emitToken(aTokens.getEndOffset(aIndex), (aTokens.getMetadata(aIndex) & aMask) | (bMetadata & bMask));\n                aIndex++;\n            }\n            if (aIndex < aLen) {\n                emitToken(bEndCharacter, (aTokens.getMetadata(aIndex) & aMask) | (bMetadata & bMask));\n                if (aTokens.getEndOffset(aIndex) === bEndCharacter) {\n                    // `a` ends exactly at the same spot as `b`!\n                    aIndex++;\n                }\n            }\n            else {\n                const aMergeIndex = Math.min(Math.max(0, aIndex - 1), aLen - 1);\n                // push the token from `b`\n                emitToken(bEndCharacter, (aTokens.getMetadata(aMergeIndex) & aMask) | (bMetadata & bMask));\n            }\n        }\n        // push the remaining tokens from `a`\n        while (aIndex < aLen) {\n            emitToken(aTokens.getEndOffset(aIndex), aTokens.getMetadata(aIndex));\n            aIndex++;\n        }\n        return new LineTokens(new Uint32Array(result), aTokens.getLineContent(), this._languageIdCodec);\n    }\n    static _findFirstPieceWithLine(pieces, lineNumber) {\n        let low = 0;\n        let high = pieces.length - 1;\n        while (low < high) {\n            let mid = low + Math.floor((high - low) / 2);\n            if (pieces[mid].endLineNumber < lineNumber) {\n                low = mid + 1;\n            }\n            else if (pieces[mid].startLineNumber > lineNumber) {\n                high = mid - 1;\n            }\n            else {\n                while (mid > low && pieces[mid - 1].startLineNumber <= lineNumber && lineNumber <= pieces[mid - 1].endLineNumber) {\n                    mid--;\n                }\n                return mid;\n            }\n        }\n        return low;\n    }\n    acceptEdit(range, eolCount, firstLineLength, lastLineLength, firstCharCode) {\n        for (const piece of this._pieces) {\n            piece.acceptEdit(range, eolCount, firstLineLength, lastLineLength, firstCharCode);\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar TokenizationTextModelPart_1;\nimport { BugIndicatingError, onUnexpectedError } from '../../../base/common/errors.js';\nimport { Emitter, Event } from '../../../base/common/event.js';\nimport { DisposableMap, DisposableStore, MutableDisposable } from '../../../base/common/lifecycle.js';\nimport { countEOL } from '../core/eolCounter.js';\nimport { LineRange } from '../core/lineRange.js';\nimport { Position } from '../core/position.js';\nimport { getWordAtText } from '../core/wordHelper.js';\nimport { TokenizationRegistry, TreeSitterTokenizationRegistry } from '../languages.js';\nimport { ILanguageService } from '../languages/language.js';\nimport { ILanguageConfigurationService } from '../languages/languageConfigurationRegistry.js';\nimport { TextModelPart } from './textModelPart.js';\nimport { DefaultBackgroundTokenizer, TokenizerWithStateStoreAndTextModel, TrackingTokenizationStateStore } from './textModelTokens.js';\nimport { AbstractTokens, AttachedViewHandler } from './tokens.js';\nimport { TreeSitterTokens } from './treeSitterTokens.js';\nimport { ITreeSitterParserService } from '../services/treeSitterParserService.js';\nimport { ContiguousMultilineTokensBuilder } from '../tokens/contiguousMultilineTokensBuilder.js';\nimport { ContiguousTokensStore } from '../tokens/contiguousTokensStore.js';\nimport { SparseTokensStore } from '../tokens/sparseTokensStore.js';\nlet TokenizationTextModelPart = TokenizationTextModelPart_1 = class TokenizationTextModelPart extends TextModelPart {\n    constructor(_textModel, _bracketPairsTextModelPart, _languageId, _attachedViews, _languageService, _languageConfigurationService, _treeSitterService) {\n        super();\n        this._textModel = _textModel;\n        this._bracketPairsTextModelPart = _bracketPairsTextModelPart;\n        this._languageId = _languageId;\n        this._attachedViews = _attachedViews;\n        this._languageService = _languageService;\n        this._languageConfigurationService = _languageConfigurationService;\n        this._treeSitterService = _treeSitterService;\n        this._semanticTokens = new SparseTokensStore(this._languageService.languageIdCodec);\n        this._onDidChangeLanguage = this._register(new Emitter());\n        this.onDidChangeLanguage = this._onDidChangeLanguage.event;\n        this._onDidChangeLanguageConfiguration = this._register(new Emitter());\n        this.onDidChangeLanguageConfiguration = this._onDidChangeLanguageConfiguration.event;\n        this._onDidChangeTokens = this._register(new Emitter());\n        this.onDidChangeTokens = this._onDidChangeTokens.event;\n        this._tokensDisposables = this._register(new DisposableStore());\n        this._register(this._languageConfigurationService.onDidChange(e => {\n            if (e.affects(this._languageId)) {\n                this._onDidChangeLanguageConfiguration.fire({});\n            }\n        }));\n        // We just look at registry changes to determine whether to use tree sitter.\n        // This means that removing a language from the setting will not cause a switch to textmate and will require a reload.\n        // Adding a language to the setting will not need a reload, however.\n        this._register(Event.filter(TreeSitterTokenizationRegistry.onDidChange, (e) => e.changedLanguages.includes(this._languageId))(() => {\n            this.createPreferredTokenProvider();\n        }));\n        this.createPreferredTokenProvider();\n    }\n    createGrammarTokens() {\n        return this._register(new GrammarTokens(this._languageService.languageIdCodec, this._textModel, () => this._languageId, this._attachedViews));\n    }\n    createTreeSitterTokens() {\n        return this._register(new TreeSitterTokens(this._treeSitterService, this._languageService.languageIdCodec, this._textModel, () => this._languageId));\n    }\n    createTokens(useTreeSitter) {\n        const needsReset = this._tokens !== undefined;\n        this._tokens?.dispose();\n        this._tokens = useTreeSitter ? this.createTreeSitterTokens() : this.createGrammarTokens();\n        this._tokensDisposables.clear();\n        this._tokensDisposables.add(this._tokens.onDidChangeTokens(e => {\n            this._emitModelTokensChangedEvent(e);\n        }));\n        this._tokensDisposables.add(this._tokens.onDidChangeBackgroundTokenizationState(e => {\n            this._bracketPairsTextModelPart.handleDidChangeBackgroundTokenizationState();\n        }));\n        if (needsReset) {\n            // We need to reset the tokenization, as the new token provider otherwise won't have a chance to provide tokens until some action happens in the editor.\n            this._tokens.resetTokenization();\n        }\n    }\n    createPreferredTokenProvider() {\n        if (TreeSitterTokenizationRegistry.get(this._languageId)) {\n            if (!(this._tokens instanceof TreeSitterTokens)) {\n                this.createTokens(true);\n            }\n        }\n        else {\n            if (!(this._tokens instanceof GrammarTokens)) {\n                this.createTokens(false);\n            }\n        }\n    }\n    handleLanguageConfigurationServiceChange(e) {\n        if (e.affects(this._languageId)) {\n            this._onDidChangeLanguageConfiguration.fire({});\n        }\n    }\n    handleDidChangeContent(e) {\n        if (e.isFlush) {\n            this._semanticTokens.flush();\n        }\n        else if (!e.isEolChange) { // We don't have to do anything on an EOL change\n            for (const c of e.changes) {\n                const [eolCount, firstLineLength, lastLineLength] = countEOL(c.text);\n                this._semanticTokens.acceptEdit(c.range, eolCount, firstLineLength, lastLineLength, c.text.length > 0 ? c.text.charCodeAt(0) : 0 /* CharCode.Null */);\n            }\n        }\n        this._tokens.handleDidChangeContent(e);\n    }\n    handleDidChangeAttached() {\n        this._tokens.handleDidChangeAttached();\n    }\n    /**\n     * Includes grammar and semantic tokens.\n     */\n    getLineTokens(lineNumber) {\n        this.validateLineNumber(lineNumber);\n        const syntacticTokens = this._tokens.getLineTokens(lineNumber);\n        return this._semanticTokens.addSparseTokens(lineNumber, syntacticTokens);\n    }\n    _emitModelTokensChangedEvent(e) {\n        if (!this._textModel._isDisposing()) {\n            this._bracketPairsTextModelPart.handleDidChangeTokens(e);\n            this._onDidChangeTokens.fire(e);\n        }\n    }\n    // #region Grammar Tokens\n    validateLineNumber(lineNumber) {\n        if (lineNumber < 1 || lineNumber > this._textModel.getLineCount()) {\n            throw new BugIndicatingError('Illegal value for lineNumber');\n        }\n    }\n    get hasTokens() {\n        return this._tokens.hasTokens;\n    }\n    resetTokenization() {\n        this._tokens.resetTokenization();\n    }\n    get backgroundTokenizationState() {\n        return this._tokens.backgroundTokenizationState;\n    }\n    forceTokenization(lineNumber) {\n        this.validateLineNumber(lineNumber);\n        this._tokens.forceTokenization(lineNumber);\n    }\n    hasAccurateTokensForLine(lineNumber) {\n        this.validateLineNumber(lineNumber);\n        return this._tokens.hasAccurateTokensForLine(lineNumber);\n    }\n    isCheapToTokenize(lineNumber) {\n        this.validateLineNumber(lineNumber);\n        return this._tokens.isCheapToTokenize(lineNumber);\n    }\n    tokenizeIfCheap(lineNumber) {\n        this.validateLineNumber(lineNumber);\n        this._tokens.tokenizeIfCheap(lineNumber);\n    }\n    getTokenTypeIfInsertingCharacter(lineNumber, column, character) {\n        return this._tokens.getTokenTypeIfInsertingCharacter(lineNumber, column, character);\n    }\n    tokenizeLineWithEdit(position, length, newText) {\n        return this._tokens.tokenizeLineWithEdit(position, length, newText);\n    }\n    // #endregion\n    // #region Semantic Tokens\n    setSemanticTokens(tokens, isComplete) {\n        this._semanticTokens.set(tokens, isComplete);\n        this._emitModelTokensChangedEvent({\n            semanticTokensApplied: tokens !== null,\n            ranges: [{ fromLineNumber: 1, toLineNumber: this._textModel.getLineCount() }],\n        });\n    }\n    hasCompleteSemanticTokens() {\n        return this._semanticTokens.isComplete();\n    }\n    hasSomeSemanticTokens() {\n        return !this._semanticTokens.isEmpty();\n    }\n    setPartialSemanticTokens(range, tokens) {\n        if (this.hasCompleteSemanticTokens()) {\n            return;\n        }\n        const changedRange = this._textModel.validateRange(this._semanticTokens.setPartial(range, tokens));\n        this._emitModelTokensChangedEvent({\n            semanticTokensApplied: true,\n            ranges: [\n                {\n                    fromLineNumber: changedRange.startLineNumber,\n                    toLineNumber: changedRange.endLineNumber,\n                },\n            ],\n        });\n    }\n    // #endregion\n    // #region Utility Methods\n    getWordAtPosition(_position) {\n        this.assertNotDisposed();\n        const position = this._textModel.validatePosition(_position);\n        const lineContent = this._textModel.getLineContent(position.lineNumber);\n        const lineTokens = this.getLineTokens(position.lineNumber);\n        const tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n        // (1). First try checking right biased word\n        const [rbStartOffset, rbEndOffset] = TokenizationTextModelPart_1._findLanguageBoundaries(lineTokens, tokenIndex);\n        const rightBiasedWord = getWordAtText(position.column, this.getLanguageConfiguration(lineTokens.getLanguageId(tokenIndex)).getWordDefinition(), lineContent.substring(rbStartOffset, rbEndOffset), rbStartOffset);\n        // Make sure the result touches the original passed in position\n        if (rightBiasedWord &&\n            rightBiasedWord.startColumn <= _position.column &&\n            _position.column <= rightBiasedWord.endColumn) {\n            return rightBiasedWord;\n        }\n        // (2). Else, if we were at a language boundary, check the left biased word\n        if (tokenIndex > 0 && rbStartOffset === position.column - 1) {\n            // edge case, where `position` sits between two tokens belonging to two different languages\n            const [lbStartOffset, lbEndOffset] = TokenizationTextModelPart_1._findLanguageBoundaries(lineTokens, tokenIndex - 1);\n            const leftBiasedWord = getWordAtText(position.column, this.getLanguageConfiguration(lineTokens.getLanguageId(tokenIndex - 1)).getWordDefinition(), lineContent.substring(lbStartOffset, lbEndOffset), lbStartOffset);\n            // Make sure the result touches the original passed in position\n            if (leftBiasedWord &&\n                leftBiasedWord.startColumn <= _position.column &&\n                _position.column <= leftBiasedWord.endColumn) {\n                return leftBiasedWord;\n            }\n        }\n        return null;\n    }\n    getLanguageConfiguration(languageId) {\n        return this._languageConfigurationService.getLanguageConfiguration(languageId);\n    }\n    static _findLanguageBoundaries(lineTokens, tokenIndex) {\n        const languageId = lineTokens.getLanguageId(tokenIndex);\n        // go left until a different language is hit\n        let startOffset = 0;\n        for (let i = tokenIndex; i >= 0 && lineTokens.getLanguageId(i) === languageId; i--) {\n            startOffset = lineTokens.getStartOffset(i);\n        }\n        // go right until a different language is hit\n        let endOffset = lineTokens.getLineContent().length;\n        for (let i = tokenIndex, tokenCount = lineTokens.getCount(); i < tokenCount && lineTokens.getLanguageId(i) === languageId; i++) {\n            endOffset = lineTokens.getEndOffset(i);\n        }\n        return [startOffset, endOffset];\n    }\n    getWordUntilPosition(position) {\n        const wordAtPosition = this.getWordAtPosition(position);\n        if (!wordAtPosition) {\n            return { word: '', startColumn: position.column, endColumn: position.column, };\n        }\n        return {\n            word: wordAtPosition.word.substr(0, position.column - wordAtPosition.startColumn),\n            startColumn: wordAtPosition.startColumn,\n            endColumn: position.column,\n        };\n    }\n    // #endregion\n    // #region Language Id handling\n    getLanguageId() {\n        return this._languageId;\n    }\n    getLanguageIdAtPosition(lineNumber, column) {\n        const position = this._textModel.validatePosition(new Position(lineNumber, column));\n        const lineTokens = this.getLineTokens(position.lineNumber);\n        return lineTokens.getLanguageId(lineTokens.findTokenIndexAtOffset(position.column - 1));\n    }\n    setLanguageId(languageId, source = 'api') {\n        if (this._languageId === languageId) {\n            // There's nothing to do\n            return;\n        }\n        const e = {\n            oldLanguage: this._languageId,\n            newLanguage: languageId,\n            source\n        };\n        this._languageId = languageId;\n        this._bracketPairsTextModelPart.handleDidChangeLanguage(e);\n        this._tokens.resetTokenization();\n        this.createPreferredTokenProvider();\n        this._onDidChangeLanguage.fire(e);\n        this._onDidChangeLanguageConfiguration.fire({});\n    }\n};\nTokenizationTextModelPart = TokenizationTextModelPart_1 = __decorate([\n    __param(4, ILanguageService),\n    __param(5, ILanguageConfigurationService),\n    __param(6, ITreeSitterParserService)\n], TokenizationTextModelPart);\nexport { TokenizationTextModelPart };\nclass GrammarTokens extends AbstractTokens {\n    constructor(languageIdCodec, textModel, getLanguageId, attachedViews) {\n        super(languageIdCodec, textModel, getLanguageId);\n        this._tokenizer = null;\n        this._defaultBackgroundTokenizer = null;\n        this._backgroundTokenizer = this._register(new MutableDisposable());\n        this._tokens = new ContiguousTokensStore(this._languageIdCodec);\n        this._debugBackgroundTokenizer = this._register(new MutableDisposable());\n        this._attachedViewStates = this._register(new DisposableMap());\n        this._register(TokenizationRegistry.onDidChange((e) => {\n            const languageId = this.getLanguageId();\n            if (e.changedLanguages.indexOf(languageId) === -1) {\n                return;\n            }\n            this.resetTokenization();\n        }));\n        this.resetTokenization();\n        this._register(attachedViews.onDidChangeVisibleRanges(({ view, state }) => {\n            if (state) {\n                let existing = this._attachedViewStates.get(view);\n                if (!existing) {\n                    existing = new AttachedViewHandler(() => this.refreshRanges(existing.lineRanges));\n                    this._attachedViewStates.set(view, existing);\n                }\n                existing.handleStateChange(state);\n            }\n            else {\n                this._attachedViewStates.deleteAndDispose(view);\n            }\n        }));\n    }\n    resetTokenization(fireTokenChangeEvent = true) {\n        this._tokens.flush();\n        this._debugBackgroundTokens?.flush();\n        if (this._debugBackgroundStates) {\n            this._debugBackgroundStates = new TrackingTokenizationStateStore(this._textModel.getLineCount());\n        }\n        if (fireTokenChangeEvent) {\n            this._onDidChangeTokens.fire({\n                semanticTokensApplied: false,\n                ranges: [\n                    {\n                        fromLineNumber: 1,\n                        toLineNumber: this._textModel.getLineCount(),\n                    },\n                ],\n            });\n        }\n        const initializeTokenization = () => {\n            if (this._textModel.isTooLargeForTokenization()) {\n                return [null, null];\n            }\n            const tokenizationSupport = TokenizationRegistry.get(this.getLanguageId());\n            if (!tokenizationSupport) {\n                return [null, null];\n            }\n            let initialState;\n            try {\n                initialState = tokenizationSupport.getInitialState();\n            }\n            catch (e) {\n                onUnexpectedError(e);\n                return [null, null];\n            }\n            return [tokenizationSupport, initialState];\n        };\n        const [tokenizationSupport, initialState] = initializeTokenization();\n        if (tokenizationSupport && initialState) {\n            this._tokenizer = new TokenizerWithStateStoreAndTextModel(this._textModel.getLineCount(), tokenizationSupport, this._textModel, this._languageIdCodec);\n        }\n        else {\n            this._tokenizer = null;\n        }\n        this._backgroundTokenizer.clear();\n        this._defaultBackgroundTokenizer = null;\n        if (this._tokenizer) {\n            const b = {\n                setTokens: (tokens) => {\n                    this.setTokens(tokens);\n                },\n                backgroundTokenizationFinished: () => {\n                    if (this._backgroundTokenizationState === 2 /* BackgroundTokenizationState.Completed */) {\n                        // We already did a full tokenization and don't go back to progressing.\n                        return;\n                    }\n                    const newState = 2 /* BackgroundTokenizationState.Completed */;\n                    this._backgroundTokenizationState = newState;\n                    this._onDidChangeBackgroundTokenizationState.fire();\n                },\n                setEndState: (lineNumber, state) => {\n                    if (!this._tokenizer) {\n                        return;\n                    }\n                    const firstInvalidEndStateLineNumber = this._tokenizer.store.getFirstInvalidEndStateLineNumber();\n                    // Don't accept states for definitely valid states, the renderer is ahead of the worker!\n                    if (firstInvalidEndStateLineNumber !== null && lineNumber >= firstInvalidEndStateLineNumber) {\n                        this._tokenizer?.store.setEndState(lineNumber, state);\n                    }\n                },\n            };\n            if (tokenizationSupport && tokenizationSupport.createBackgroundTokenizer && !tokenizationSupport.backgroundTokenizerShouldOnlyVerifyTokens) {\n                this._backgroundTokenizer.value = tokenizationSupport.createBackgroundTokenizer(this._textModel, b);\n            }\n            if (!this._backgroundTokenizer.value && !this._textModel.isTooLargeForTokenization()) {\n                this._backgroundTokenizer.value = this._defaultBackgroundTokenizer =\n                    new DefaultBackgroundTokenizer(this._tokenizer, b);\n                this._defaultBackgroundTokenizer.handleChanges();\n            }\n            if (tokenizationSupport?.backgroundTokenizerShouldOnlyVerifyTokens && tokenizationSupport.createBackgroundTokenizer) {\n                this._debugBackgroundTokens = new ContiguousTokensStore(this._languageIdCodec);\n                this._debugBackgroundStates = new TrackingTokenizationStateStore(this._textModel.getLineCount());\n                this._debugBackgroundTokenizer.clear();\n                this._debugBackgroundTokenizer.value = tokenizationSupport.createBackgroundTokenizer(this._textModel, {\n                    setTokens: (tokens) => {\n                        this._debugBackgroundTokens?.setMultilineTokens(tokens, this._textModel);\n                    },\n                    backgroundTokenizationFinished() {\n                        // NO OP\n                    },\n                    setEndState: (lineNumber, state) => {\n                        this._debugBackgroundStates?.setEndState(lineNumber, state);\n                    },\n                });\n            }\n            else {\n                this._debugBackgroundTokens = undefined;\n                this._debugBackgroundStates = undefined;\n                this._debugBackgroundTokenizer.value = undefined;\n            }\n        }\n        this.refreshAllVisibleLineTokens();\n    }\n    handleDidChangeAttached() {\n        this._defaultBackgroundTokenizer?.handleChanges();\n    }\n    handleDidChangeContent(e) {\n        if (e.isFlush) {\n            // Don't fire the event, as the view might not have got the text change event yet\n            this.resetTokenization(false);\n        }\n        else if (!e.isEolChange) { // We don't have to do anything on an EOL change\n            for (const c of e.changes) {\n                const [eolCount, firstLineLength] = countEOL(c.text);\n                this._tokens.acceptEdit(c.range, eolCount, firstLineLength);\n                this._debugBackgroundTokens?.acceptEdit(c.range, eolCount, firstLineLength);\n            }\n            this._debugBackgroundStates?.acceptChanges(e.changes);\n            if (this._tokenizer) {\n                this._tokenizer.store.acceptChanges(e.changes);\n            }\n            this._defaultBackgroundTokenizer?.handleChanges();\n        }\n    }\n    setTokens(tokens) {\n        const { changes } = this._tokens.setMultilineTokens(tokens, this._textModel);\n        if (changes.length > 0) {\n            this._onDidChangeTokens.fire({ semanticTokensApplied: false, ranges: changes, });\n        }\n        return { changes: changes };\n    }\n    refreshAllVisibleLineTokens() {\n        const ranges = LineRange.joinMany([...this._attachedViewStates].map(([_, s]) => s.lineRanges));\n        this.refreshRanges(ranges);\n    }\n    refreshRanges(ranges) {\n        for (const range of ranges) {\n            this.refreshRange(range.startLineNumber, range.endLineNumberExclusive - 1);\n        }\n    }\n    refreshRange(startLineNumber, endLineNumber) {\n        if (!this._tokenizer) {\n            return;\n        }\n        startLineNumber = Math.max(1, Math.min(this._textModel.getLineCount(), startLineNumber));\n        endLineNumber = Math.min(this._textModel.getLineCount(), endLineNumber);\n        const builder = new ContiguousMultilineTokensBuilder();\n        const { heuristicTokens } = this._tokenizer.tokenizeHeuristically(builder, startLineNumber, endLineNumber);\n        const changedTokens = this.setTokens(builder.finalize());\n        if (heuristicTokens) {\n            // We overrode tokens with heuristically computed ones.\n            // Because old states might get reused (thus stopping invalidation),\n            // we have to explicitly request the tokens for the changed ranges again.\n            for (const c of changedTokens.changes) {\n                this._backgroundTokenizer.value?.requestTokens(c.fromLineNumber, c.toLineNumber + 1);\n            }\n        }\n        this._defaultBackgroundTokenizer?.checkFinished();\n    }\n    forceTokenization(lineNumber) {\n        const builder = new ContiguousMultilineTokensBuilder();\n        this._tokenizer?.updateTokensUntilLine(builder, lineNumber);\n        this.setTokens(builder.finalize());\n        this._defaultBackgroundTokenizer?.checkFinished();\n    }\n    hasAccurateTokensForLine(lineNumber) {\n        if (!this._tokenizer) {\n            return true;\n        }\n        return this._tokenizer.hasAccurateTokensForLine(lineNumber);\n    }\n    isCheapToTokenize(lineNumber) {\n        if (!this._tokenizer) {\n            return true;\n        }\n        return this._tokenizer.isCheapToTokenize(lineNumber);\n    }\n    getLineTokens(lineNumber) {\n        const lineText = this._textModel.getLineContent(lineNumber);\n        const result = this._tokens.getTokens(this._textModel.getLanguageId(), lineNumber - 1, lineText);\n        if (this._debugBackgroundTokens && this._debugBackgroundStates && this._tokenizer) {\n            if (this._debugBackgroundStates.getFirstInvalidEndStateLineNumberOrMax() > lineNumber && this._tokenizer.store.getFirstInvalidEndStateLineNumberOrMax() > lineNumber) {\n                const backgroundResult = this._debugBackgroundTokens.getTokens(this._textModel.getLanguageId(), lineNumber - 1, lineText);\n                if (!result.equals(backgroundResult) && this._debugBackgroundTokenizer.value?.reportMismatchingTokens) {\n                    this._debugBackgroundTokenizer.value.reportMismatchingTokens(lineNumber);\n                }\n            }\n        }\n        return result;\n    }\n    getTokenTypeIfInsertingCharacter(lineNumber, column, character) {\n        if (!this._tokenizer) {\n            return 0 /* StandardTokenType.Other */;\n        }\n        const position = this._textModel.validatePosition(new Position(lineNumber, column));\n        this.forceTokenization(position.lineNumber);\n        return this._tokenizer.getTokenTypeIfInsertingCharacter(position, character);\n    }\n    tokenizeLineWithEdit(position, length, newText) {\n        if (!this._tokenizer) {\n            return null;\n        }\n        const validatedPosition = this._textModel.validatePosition(position);\n        this.forceTokenization(validatedPosition.lineNumber);\n        return this._tokenizer.tokenizeLineWithEdit(validatedPosition, length, newText);\n    }\n    get hasTokens() {\n        return this._tokens.hasTokens;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar TextModel_1;\nimport { ArrayQueue, pushMany } from '../../../base/common/arrays.js';\nimport { Color } from '../../../base/common/color.js';\nimport { BugIndicatingError, illegalArgument, onUnexpectedError } from '../../../base/common/errors.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable, MutableDisposable, combinedDisposable } from '../../../base/common/lifecycle.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { countEOL } from '../core/eolCounter.js';\nimport { normalizeIndentation } from '../core/indentation.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\nimport { EDITOR_MODEL_DEFAULTS } from '../core/textModelDefaults.js';\nimport { ILanguageService } from '../languages/language.js';\nimport { ILanguageConfigurationService } from '../languages/languageConfigurationRegistry.js';\nimport * as model from '../model.js';\nimport { BracketPairsTextModelPart } from './bracketPairsTextModelPart/bracketPairsImpl.js';\nimport { ColorizedBracketPairsDecorationProvider } from './bracketPairsTextModelPart/colorizedBracketPairsDecorationProvider.js';\nimport { EditStack } from './editStack.js';\nimport { GuidesTextModelPart } from './guidesTextModelPart.js';\nimport { guessIndentation } from './indentationGuesser.js';\nimport { IntervalNode, IntervalTree, recomputeMaxEnd } from './intervalTree.js';\nimport { PieceTreeTextBuffer } from './pieceTreeTextBuffer/pieceTreeTextBuffer.js';\nimport { PieceTreeTextBufferBuilder } from './pieceTreeTextBuffer/pieceTreeTextBufferBuilder.js';\nimport { SearchParams, TextModelSearch } from './textModelSearch.js';\nimport { TokenizationTextModelPart } from './tokenizationTextModelPart.js';\nimport { AttachedViews } from './tokens.js';\nimport { InternalModelContentChangeEvent, LineInjectedText, ModelInjectedTextChangedEvent, ModelRawContentChangedEvent, ModelRawEOLChanged, ModelRawFlush, ModelRawLineChanged, ModelRawLinesDeleted, ModelRawLinesInserted } from '../textModelEvents.js';\nimport { IInstantiationService } from '../../../platform/instantiation/common/instantiation.js';\nimport { IUndoRedoService } from '../../../platform/undoRedo/common/undoRedo.js';\nexport function createTextBufferFactory(text) {\n    const builder = new PieceTreeTextBufferBuilder();\n    builder.acceptChunk(text);\n    return builder.finish();\n}\nexport function createTextBufferFactoryFromSnapshot(snapshot) {\n    const builder = new PieceTreeTextBufferBuilder();\n    let chunk;\n    while (typeof (chunk = snapshot.read()) === 'string') {\n        builder.acceptChunk(chunk);\n    }\n    return builder.finish();\n}\nexport function createTextBuffer(value, defaultEOL) {\n    let factory;\n    if (typeof value === 'string') {\n        factory = createTextBufferFactory(value);\n    }\n    else if (model.isITextSnapshot(value)) {\n        factory = createTextBufferFactoryFromSnapshot(value);\n    }\n    else {\n        factory = value;\n    }\n    return factory.create(defaultEOL);\n}\nlet MODEL_ID = 0;\nconst LIMIT_FIND_COUNT = 999;\nconst LONG_LINE_BOUNDARY = 10000;\nclass TextModelSnapshot {\n    constructor(source) {\n        this._source = source;\n        this._eos = false;\n    }\n    read() {\n        if (this._eos) {\n            return null;\n        }\n        const result = [];\n        let resultCnt = 0;\n        let resultLength = 0;\n        do {\n            const tmp = this._source.read();\n            if (tmp === null) {\n                // end-of-stream\n                this._eos = true;\n                if (resultCnt === 0) {\n                    return null;\n                }\n                else {\n                    return result.join('');\n                }\n            }\n            if (tmp.length > 0) {\n                result[resultCnt++] = tmp;\n                resultLength += tmp.length;\n            }\n            if (resultLength >= 64 * 1024) {\n                return result.join('');\n            }\n        } while (true);\n    }\n}\nconst invalidFunc = () => { throw new Error(`Invalid change accessor`); };\nlet TextModel = class TextModel extends Disposable {\n    static { TextModel_1 = this; }\n    static { this._MODEL_SYNC_LIMIT = 50 * 1024 * 1024; } // 50 MB,  // used in tests\n    static { this.LARGE_FILE_SIZE_THRESHOLD = 20 * 1024 * 1024; } // 20 MB;\n    static { this.LARGE_FILE_LINE_COUNT_THRESHOLD = 300 * 1000; } // 300K lines\n    static { this.LARGE_FILE_HEAP_OPERATION_THRESHOLD = 256 * 1024 * 1024; } // 256M characters, usually ~> 512MB memory usage\n    static { this.DEFAULT_CREATION_OPTIONS = {\n        isForSimpleWidget: false,\n        tabSize: EDITOR_MODEL_DEFAULTS.tabSize,\n        indentSize: EDITOR_MODEL_DEFAULTS.indentSize,\n        insertSpaces: EDITOR_MODEL_DEFAULTS.insertSpaces,\n        detectIndentation: false,\n        defaultEOL: 1 /* model.DefaultEndOfLine.LF */,\n        trimAutoWhitespace: EDITOR_MODEL_DEFAULTS.trimAutoWhitespace,\n        largeFileOptimizations: EDITOR_MODEL_DEFAULTS.largeFileOptimizations,\n        bracketPairColorizationOptions: EDITOR_MODEL_DEFAULTS.bracketPairColorizationOptions,\n    }; }\n    static resolveOptions(textBuffer, options) {\n        if (options.detectIndentation) {\n            const guessedIndentation = guessIndentation(textBuffer, options.tabSize, options.insertSpaces);\n            return new model.TextModelResolvedOptions({\n                tabSize: guessedIndentation.tabSize,\n                indentSize: 'tabSize', // TODO@Alex: guess indentSize independent of tabSize\n                insertSpaces: guessedIndentation.insertSpaces,\n                trimAutoWhitespace: options.trimAutoWhitespace,\n                defaultEOL: options.defaultEOL,\n                bracketPairColorizationOptions: options.bracketPairColorizationOptions,\n            });\n        }\n        return new model.TextModelResolvedOptions(options);\n    }\n    get onDidChangeLanguage() { return this._tokenizationTextModelPart.onDidChangeLanguage; }\n    get onDidChangeLanguageConfiguration() { return this._tokenizationTextModelPart.onDidChangeLanguageConfiguration; }\n    get onDidChangeTokens() { return this._tokenizationTextModelPart.onDidChangeTokens; }\n    onDidChangeContent(listener) {\n        return this._eventEmitter.slowEvent((e) => listener(e.contentChangedEvent));\n    }\n    onDidChangeContentOrInjectedText(listener) {\n        return combinedDisposable(this._eventEmitter.fastEvent(e => listener(e)), this._onDidChangeInjectedText.event(e => listener(e)));\n    }\n    _isDisposing() { return this.__isDisposing; }\n    get tokenization() { return this._tokenizationTextModelPart; }\n    get bracketPairs() { return this._bracketPairs; }\n    get guides() { return this._guidesTextModelPart; }\n    constructor(source, languageIdOrSelection, creationOptions, associatedResource = null, _undoRedoService, _languageService, _languageConfigurationService, instantiationService) {\n        super();\n        this._undoRedoService = _undoRedoService;\n        this._languageService = _languageService;\n        this._languageConfigurationService = _languageConfigurationService;\n        this.instantiationService = instantiationService;\n        //#region Events\n        this._onWillDispose = this._register(new Emitter());\n        this.onWillDispose = this._onWillDispose.event;\n        this._onDidChangeDecorations = this._register(new DidChangeDecorationsEmitter(affectedInjectedTextLines => this.handleBeforeFireDecorationsChangedEvent(affectedInjectedTextLines)));\n        this.onDidChangeDecorations = this._onDidChangeDecorations.event;\n        this._onDidChangeOptions = this._register(new Emitter());\n        this.onDidChangeOptions = this._onDidChangeOptions.event;\n        this._onDidChangeAttached = this._register(new Emitter());\n        this.onDidChangeAttached = this._onDidChangeAttached.event;\n        this._onDidChangeInjectedText = this._register(new Emitter());\n        this._eventEmitter = this._register(new DidChangeContentEmitter());\n        this._languageSelectionListener = this._register(new MutableDisposable());\n        this._deltaDecorationCallCnt = 0;\n        this._attachedViews = new AttachedViews();\n        // Generate a new unique model id\n        MODEL_ID++;\n        this.id = '$model' + MODEL_ID;\n        this.isForSimpleWidget = creationOptions.isForSimpleWidget;\n        if (typeof associatedResource === 'undefined' || associatedResource === null) {\n            this._associatedResource = URI.parse('inmemory://model/' + MODEL_ID);\n        }\n        else {\n            this._associatedResource = associatedResource;\n        }\n        this._attachedEditorCount = 0;\n        const { textBuffer, disposable } = createTextBuffer(source, creationOptions.defaultEOL);\n        this._buffer = textBuffer;\n        this._bufferDisposable = disposable;\n        this._options = TextModel_1.resolveOptions(this._buffer, creationOptions);\n        const languageId = (typeof languageIdOrSelection === 'string' ? languageIdOrSelection : languageIdOrSelection.languageId);\n        if (typeof languageIdOrSelection !== 'string') {\n            this._languageSelectionListener.value = languageIdOrSelection.onDidChange(() => this._setLanguage(languageIdOrSelection.languageId));\n        }\n        this._bracketPairs = this._register(new BracketPairsTextModelPart(this, this._languageConfigurationService));\n        this._guidesTextModelPart = this._register(new GuidesTextModelPart(this, this._languageConfigurationService));\n        this._decorationProvider = this._register(new ColorizedBracketPairsDecorationProvider(this));\n        this._tokenizationTextModelPart = this.instantiationService.createInstance(TokenizationTextModelPart, this, this._bracketPairs, languageId, this._attachedViews);\n        const bufferLineCount = this._buffer.getLineCount();\n        const bufferTextLength = this._buffer.getValueLengthInRange(new Range(1, 1, bufferLineCount, this._buffer.getLineLength(bufferLineCount) + 1), 0 /* model.EndOfLinePreference.TextDefined */);\n        // !!! Make a decision in the ctor and permanently respect this decision !!!\n        // If a model is too large at construction time, it will never get tokenized,\n        // under no circumstances.\n        if (creationOptions.largeFileOptimizations) {\n            this._isTooLargeForTokenization = ((bufferTextLength > TextModel_1.LARGE_FILE_SIZE_THRESHOLD)\n                || (bufferLineCount > TextModel_1.LARGE_FILE_LINE_COUNT_THRESHOLD));\n            this._isTooLargeForHeapOperation = bufferTextLength > TextModel_1.LARGE_FILE_HEAP_OPERATION_THRESHOLD;\n        }\n        else {\n            this._isTooLargeForTokenization = false;\n            this._isTooLargeForHeapOperation = false;\n        }\n        this._isTooLargeForSyncing = (bufferTextLength > TextModel_1._MODEL_SYNC_LIMIT);\n        this._versionId = 1;\n        this._alternativeVersionId = 1;\n        this._initialUndoRedoSnapshot = null;\n        this._isDisposed = false;\n        this.__isDisposing = false;\n        this._instanceId = strings.singleLetterHash(MODEL_ID);\n        this._lastDecorationId = 0;\n        this._decorations = Object.create(null);\n        this._decorationsTree = new DecorationsTrees();\n        this._commandManager = new EditStack(this, this._undoRedoService);\n        this._isUndoing = false;\n        this._isRedoing = false;\n        this._trimAutoWhitespaceLines = null;\n        this._register(this._decorationProvider.onDidChange(() => {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            this._onDidChangeDecorations.fire();\n            this._onDidChangeDecorations.endDeferredEmit();\n        }));\n        this._languageService.requestRichLanguageFeatures(languageId);\n        this._register(this._languageConfigurationService.onDidChange(e => {\n            this._bracketPairs.handleLanguageConfigurationServiceChange(e);\n            this._tokenizationTextModelPart.handleLanguageConfigurationServiceChange(e);\n        }));\n    }\n    dispose() {\n        this.__isDisposing = true;\n        this._onWillDispose.fire();\n        this._tokenizationTextModelPart.dispose();\n        this._isDisposed = true;\n        super.dispose();\n        this._bufferDisposable.dispose();\n        this.__isDisposing = false;\n        // Manually release reference to previous text buffer to avoid large leaks\n        // in case someone leaks a TextModel reference\n        const emptyDisposedTextBuffer = new PieceTreeTextBuffer([], '', '\\n', false, false, true, true);\n        emptyDisposedTextBuffer.dispose();\n        this._buffer = emptyDisposedTextBuffer;\n        this._bufferDisposable = Disposable.None;\n    }\n    _assertNotDisposed() {\n        if (this._isDisposed) {\n            throw new BugIndicatingError('Model is disposed!');\n        }\n    }\n    _emitContentChangedEvent(rawChange, change) {\n        if (this.__isDisposing) {\n            // Do not confuse listeners by emitting any event after disposing\n            return;\n        }\n        this._tokenizationTextModelPart.handleDidChangeContent(change);\n        this._bracketPairs.handleDidChangeContent(change);\n        this._eventEmitter.fire(new InternalModelContentChangeEvent(rawChange, change));\n    }\n    setValue(value) {\n        this._assertNotDisposed();\n        if (value === null || value === undefined) {\n            throw illegalArgument();\n        }\n        const { textBuffer, disposable } = createTextBuffer(value, this._options.defaultEOL);\n        this._setValueFromTextBuffer(textBuffer, disposable);\n    }\n    _createContentChanged2(range, rangeOffset, rangeLength, text, isUndoing, isRedoing, isFlush, isEolChange) {\n        return {\n            changes: [{\n                    range: range,\n                    rangeOffset: rangeOffset,\n                    rangeLength: rangeLength,\n                    text: text,\n                }],\n            eol: this._buffer.getEOL(),\n            isEolChange: isEolChange,\n            versionId: this.getVersionId(),\n            isUndoing: isUndoing,\n            isRedoing: isRedoing,\n            isFlush: isFlush\n        };\n    }\n    _setValueFromTextBuffer(textBuffer, textBufferDisposable) {\n        this._assertNotDisposed();\n        const oldFullModelRange = this.getFullModelRange();\n        const oldModelValueLength = this.getValueLengthInRange(oldFullModelRange);\n        const endLineNumber = this.getLineCount();\n        const endColumn = this.getLineMaxColumn(endLineNumber);\n        this._buffer = textBuffer;\n        this._bufferDisposable.dispose();\n        this._bufferDisposable = textBufferDisposable;\n        this._increaseVersionId();\n        // Destroy all my decorations\n        this._decorations = Object.create(null);\n        this._decorationsTree = new DecorationsTrees();\n        // Destroy my edit history and settings\n        this._commandManager.clear();\n        this._trimAutoWhitespaceLines = null;\n        this._emitContentChangedEvent(new ModelRawContentChangedEvent([\n            new ModelRawFlush()\n        ], this._versionId, false, false), this._createContentChanged2(new Range(1, 1, endLineNumber, endColumn), 0, oldModelValueLength, this.getValue(), false, false, true, false));\n    }\n    setEOL(eol) {\n        this._assertNotDisposed();\n        const newEOL = (eol === 1 /* model.EndOfLineSequence.CRLF */ ? '\\r\\n' : '\\n');\n        if (this._buffer.getEOL() === newEOL) {\n            // Nothing to do\n            return;\n        }\n        const oldFullModelRange = this.getFullModelRange();\n        const oldModelValueLength = this.getValueLengthInRange(oldFullModelRange);\n        const endLineNumber = this.getLineCount();\n        const endColumn = this.getLineMaxColumn(endLineNumber);\n        this._onBeforeEOLChange();\n        this._buffer.setEOL(newEOL);\n        this._increaseVersionId();\n        this._onAfterEOLChange();\n        this._emitContentChangedEvent(new ModelRawContentChangedEvent([\n            new ModelRawEOLChanged()\n        ], this._versionId, false, false), this._createContentChanged2(new Range(1, 1, endLineNumber, endColumn), 0, oldModelValueLength, this.getValue(), false, false, false, true));\n    }\n    _onBeforeEOLChange() {\n        // Ensure all decorations get their `range` set.\n        this._decorationsTree.ensureAllNodesHaveRanges(this);\n    }\n    _onAfterEOLChange() {\n        // Transform back `range` to offsets\n        const versionId = this.getVersionId();\n        const allDecorations = this._decorationsTree.collectNodesPostOrder();\n        for (let i = 0, len = allDecorations.length; i < len; i++) {\n            const node = allDecorations[i];\n            const range = node.range; // the range is defined due to `_onBeforeEOLChange`\n            const delta = node.cachedAbsoluteStart - node.start;\n            const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n            const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n            node.cachedAbsoluteStart = startOffset;\n            node.cachedAbsoluteEnd = endOffset;\n            node.cachedVersionId = versionId;\n            node.start = startOffset - delta;\n            node.end = endOffset - delta;\n            recomputeMaxEnd(node);\n        }\n    }\n    onBeforeAttached() {\n        this._attachedEditorCount++;\n        if (this._attachedEditorCount === 1) {\n            this._tokenizationTextModelPart.handleDidChangeAttached();\n            this._onDidChangeAttached.fire(undefined);\n        }\n        return this._attachedViews.attachView();\n    }\n    onBeforeDetached(view) {\n        this._attachedEditorCount--;\n        if (this._attachedEditorCount === 0) {\n            this._tokenizationTextModelPart.handleDidChangeAttached();\n            this._onDidChangeAttached.fire(undefined);\n        }\n        this._attachedViews.detachView(view);\n    }\n    isAttachedToEditor() {\n        return this._attachedEditorCount > 0;\n    }\n    getAttachedEditorCount() {\n        return this._attachedEditorCount;\n    }\n    isTooLargeForSyncing() {\n        return this._isTooLargeForSyncing;\n    }\n    isTooLargeForTokenization() {\n        return this._isTooLargeForTokenization;\n    }\n    isTooLargeForHeapOperation() {\n        return this._isTooLargeForHeapOperation;\n    }\n    isDisposed() {\n        return this._isDisposed;\n    }\n    isDominatedByLongLines() {\n        this._assertNotDisposed();\n        if (this.isTooLargeForTokenization()) {\n            // Cannot word wrap huge files anyways, so it doesn't really matter\n            return false;\n        }\n        let smallLineCharCount = 0;\n        let longLineCharCount = 0;\n        const lineCount = this._buffer.getLineCount();\n        for (let lineNumber = 1; lineNumber <= lineCount; lineNumber++) {\n            const lineLength = this._buffer.getLineLength(lineNumber);\n            if (lineLength >= LONG_LINE_BOUNDARY) {\n                longLineCharCount += lineLength;\n            }\n            else {\n                smallLineCharCount += lineLength;\n            }\n        }\n        return (longLineCharCount > smallLineCharCount);\n    }\n    get uri() {\n        return this._associatedResource;\n    }\n    //#region Options\n    getOptions() {\n        this._assertNotDisposed();\n        return this._options;\n    }\n    getFormattingOptions() {\n        return {\n            tabSize: this._options.indentSize,\n            insertSpaces: this._options.insertSpaces\n        };\n    }\n    updateOptions(_newOpts) {\n        this._assertNotDisposed();\n        const tabSize = (typeof _newOpts.tabSize !== 'undefined') ? _newOpts.tabSize : this._options.tabSize;\n        const indentSize = (typeof _newOpts.indentSize !== 'undefined') ? _newOpts.indentSize : this._options.originalIndentSize;\n        const insertSpaces = (typeof _newOpts.insertSpaces !== 'undefined') ? _newOpts.insertSpaces : this._options.insertSpaces;\n        const trimAutoWhitespace = (typeof _newOpts.trimAutoWhitespace !== 'undefined') ? _newOpts.trimAutoWhitespace : this._options.trimAutoWhitespace;\n        const bracketPairColorizationOptions = (typeof _newOpts.bracketColorizationOptions !== 'undefined') ? _newOpts.bracketColorizationOptions : this._options.bracketPairColorizationOptions;\n        const newOpts = new model.TextModelResolvedOptions({\n            tabSize: tabSize,\n            indentSize: indentSize,\n            insertSpaces: insertSpaces,\n            defaultEOL: this._options.defaultEOL,\n            trimAutoWhitespace: trimAutoWhitespace,\n            bracketPairColorizationOptions,\n        });\n        if (this._options.equals(newOpts)) {\n            return;\n        }\n        const e = this._options.createChangeEvent(newOpts);\n        this._options = newOpts;\n        this._bracketPairs.handleDidChangeOptions(e);\n        this._decorationProvider.handleDidChangeOptions(e);\n        this._onDidChangeOptions.fire(e);\n    }\n    detectIndentation(defaultInsertSpaces, defaultTabSize) {\n        this._assertNotDisposed();\n        const guessedIndentation = guessIndentation(this._buffer, defaultTabSize, defaultInsertSpaces);\n        this.updateOptions({\n            insertSpaces: guessedIndentation.insertSpaces,\n            tabSize: guessedIndentation.tabSize,\n            indentSize: guessedIndentation.tabSize, // TODO@Alex: guess indentSize independent of tabSize\n        });\n    }\n    normalizeIndentation(str) {\n        this._assertNotDisposed();\n        return normalizeIndentation(str, this._options.indentSize, this._options.insertSpaces);\n    }\n    //#endregion\n    //#region Reading\n    getVersionId() {\n        this._assertNotDisposed();\n        return this._versionId;\n    }\n    mightContainRTL() {\n        return this._buffer.mightContainRTL();\n    }\n    mightContainUnusualLineTerminators() {\n        return this._buffer.mightContainUnusualLineTerminators();\n    }\n    removeUnusualLineTerminators(selections = null) {\n        const matches = this.findMatches(strings.UNUSUAL_LINE_TERMINATORS.source, false, true, false, null, false, 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */);\n        this._buffer.resetMightContainUnusualLineTerminators();\n        this.pushEditOperations(selections, matches.map(m => ({ range: m.range, text: null })), () => null);\n    }\n    mightContainNonBasicASCII() {\n        return this._buffer.mightContainNonBasicASCII();\n    }\n    getAlternativeVersionId() {\n        this._assertNotDisposed();\n        return this._alternativeVersionId;\n    }\n    getInitialUndoRedoSnapshot() {\n        this._assertNotDisposed();\n        return this._initialUndoRedoSnapshot;\n    }\n    getOffsetAt(rawPosition) {\n        this._assertNotDisposed();\n        const position = this._validatePosition(rawPosition.lineNumber, rawPosition.column, 0 /* StringOffsetValidationType.Relaxed */);\n        return this._buffer.getOffsetAt(position.lineNumber, position.column);\n    }\n    getPositionAt(rawOffset) {\n        this._assertNotDisposed();\n        const offset = (Math.min(this._buffer.getLength(), Math.max(0, rawOffset)));\n        return this._buffer.getPositionAt(offset);\n    }\n    _increaseVersionId() {\n        this._versionId = this._versionId + 1;\n        this._alternativeVersionId = this._versionId;\n    }\n    _overwriteVersionId(versionId) {\n        this._versionId = versionId;\n    }\n    _overwriteAlternativeVersionId(newAlternativeVersionId) {\n        this._alternativeVersionId = newAlternativeVersionId;\n    }\n    _overwriteInitialUndoRedoSnapshot(newInitialUndoRedoSnapshot) {\n        this._initialUndoRedoSnapshot = newInitialUndoRedoSnapshot;\n    }\n    getValue(eol, preserveBOM = false) {\n        this._assertNotDisposed();\n        if (this.isTooLargeForHeapOperation()) {\n            throw new BugIndicatingError('Operation would exceed heap memory limits');\n        }\n        const fullModelRange = this.getFullModelRange();\n        const fullModelValue = this.getValueInRange(fullModelRange, eol);\n        if (preserveBOM) {\n            return this._buffer.getBOM() + fullModelValue;\n        }\n        return fullModelValue;\n    }\n    createSnapshot(preserveBOM = false) {\n        return new TextModelSnapshot(this._buffer.createSnapshot(preserveBOM));\n    }\n    getValueLength(eol, preserveBOM = false) {\n        this._assertNotDisposed();\n        const fullModelRange = this.getFullModelRange();\n        const fullModelValue = this.getValueLengthInRange(fullModelRange, eol);\n        if (preserveBOM) {\n            return this._buffer.getBOM().length + fullModelValue;\n        }\n        return fullModelValue;\n    }\n    getValueInRange(rawRange, eol = 0 /* model.EndOfLinePreference.TextDefined */) {\n        this._assertNotDisposed();\n        return this._buffer.getValueInRange(this.validateRange(rawRange), eol);\n    }\n    getValueLengthInRange(rawRange, eol = 0 /* model.EndOfLinePreference.TextDefined */) {\n        this._assertNotDisposed();\n        return this._buffer.getValueLengthInRange(this.validateRange(rawRange), eol);\n    }\n    getCharacterCountInRange(rawRange, eol = 0 /* model.EndOfLinePreference.TextDefined */) {\n        this._assertNotDisposed();\n        return this._buffer.getCharacterCountInRange(this.validateRange(rawRange), eol);\n    }\n    getLineCount() {\n        this._assertNotDisposed();\n        return this._buffer.getLineCount();\n    }\n    getLineContent(lineNumber) {\n        this._assertNotDisposed();\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            throw new BugIndicatingError('Illegal value for lineNumber');\n        }\n        return this._buffer.getLineContent(lineNumber);\n    }\n    getLineLength(lineNumber) {\n        this._assertNotDisposed();\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            throw new BugIndicatingError('Illegal value for lineNumber');\n        }\n        return this._buffer.getLineLength(lineNumber);\n    }\n    getLinesContent() {\n        this._assertNotDisposed();\n        if (this.isTooLargeForHeapOperation()) {\n            throw new BugIndicatingError('Operation would exceed heap memory limits');\n        }\n        return this._buffer.getLinesContent();\n    }\n    getEOL() {\n        this._assertNotDisposed();\n        return this._buffer.getEOL();\n    }\n    getEndOfLineSequence() {\n        this._assertNotDisposed();\n        return (this._buffer.getEOL() === '\\n'\n            ? 0 /* model.EndOfLineSequence.LF */\n            : 1 /* model.EndOfLineSequence.CRLF */);\n    }\n    getLineMinColumn(lineNumber) {\n        this._assertNotDisposed();\n        return 1;\n    }\n    getLineMaxColumn(lineNumber) {\n        this._assertNotDisposed();\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            throw new BugIndicatingError('Illegal value for lineNumber');\n        }\n        return this._buffer.getLineLength(lineNumber) + 1;\n    }\n    getLineFirstNonWhitespaceColumn(lineNumber) {\n        this._assertNotDisposed();\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            throw new BugIndicatingError('Illegal value for lineNumber');\n        }\n        return this._buffer.getLineFirstNonWhitespaceColumn(lineNumber);\n    }\n    getLineLastNonWhitespaceColumn(lineNumber) {\n        this._assertNotDisposed();\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            throw new BugIndicatingError('Illegal value for lineNumber');\n        }\n        return this._buffer.getLineLastNonWhitespaceColumn(lineNumber);\n    }\n    /**\n     * Validates `range` is within buffer bounds, but allows it to sit in between surrogate pairs, etc.\n     * Will try to not allocate if possible.\n     */\n    _validateRangeRelaxedNoAllocations(range) {\n        const linesCount = this._buffer.getLineCount();\n        const initialStartLineNumber = range.startLineNumber;\n        const initialStartColumn = range.startColumn;\n        let startLineNumber = Math.floor((typeof initialStartLineNumber === 'number' && !isNaN(initialStartLineNumber)) ? initialStartLineNumber : 1);\n        let startColumn = Math.floor((typeof initialStartColumn === 'number' && !isNaN(initialStartColumn)) ? initialStartColumn : 1);\n        if (startLineNumber < 1) {\n            startLineNumber = 1;\n            startColumn = 1;\n        }\n        else if (startLineNumber > linesCount) {\n            startLineNumber = linesCount;\n            startColumn = this.getLineMaxColumn(startLineNumber);\n        }\n        else {\n            if (startColumn <= 1) {\n                startColumn = 1;\n            }\n            else {\n                const maxColumn = this.getLineMaxColumn(startLineNumber);\n                if (startColumn >= maxColumn) {\n                    startColumn = maxColumn;\n                }\n            }\n        }\n        const initialEndLineNumber = range.endLineNumber;\n        const initialEndColumn = range.endColumn;\n        let endLineNumber = Math.floor((typeof initialEndLineNumber === 'number' && !isNaN(initialEndLineNumber)) ? initialEndLineNumber : 1);\n        let endColumn = Math.floor((typeof initialEndColumn === 'number' && !isNaN(initialEndColumn)) ? initialEndColumn : 1);\n        if (endLineNumber < 1) {\n            endLineNumber = 1;\n            endColumn = 1;\n        }\n        else if (endLineNumber > linesCount) {\n            endLineNumber = linesCount;\n            endColumn = this.getLineMaxColumn(endLineNumber);\n        }\n        else {\n            if (endColumn <= 1) {\n                endColumn = 1;\n            }\n            else {\n                const maxColumn = this.getLineMaxColumn(endLineNumber);\n                if (endColumn >= maxColumn) {\n                    endColumn = maxColumn;\n                }\n            }\n        }\n        if (initialStartLineNumber === startLineNumber\n            && initialStartColumn === startColumn\n            && initialEndLineNumber === endLineNumber\n            && initialEndColumn === endColumn\n            && range instanceof Range\n            && !(range instanceof Selection)) {\n            return range;\n        }\n        return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n    }\n    _isValidPosition(lineNumber, column, validationType) {\n        if (typeof lineNumber !== 'number' || typeof column !== 'number') {\n            return false;\n        }\n        if (isNaN(lineNumber) || isNaN(column)) {\n            return false;\n        }\n        if (lineNumber < 1 || column < 1) {\n            return false;\n        }\n        if ((lineNumber | 0) !== lineNumber || (column | 0) !== column) {\n            return false;\n        }\n        const lineCount = this._buffer.getLineCount();\n        if (lineNumber > lineCount) {\n            return false;\n        }\n        if (column === 1) {\n            return true;\n        }\n        const maxColumn = this.getLineMaxColumn(lineNumber);\n        if (column > maxColumn) {\n            return false;\n        }\n        if (validationType === 1 /* StringOffsetValidationType.SurrogatePairs */) {\n            // !!At this point, column > 1\n            const charCodeBefore = this._buffer.getLineCharCode(lineNumber, column - 2);\n            if (strings.isHighSurrogate(charCodeBefore)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    _validatePosition(_lineNumber, _column, validationType) {\n        const lineNumber = Math.floor((typeof _lineNumber === 'number' && !isNaN(_lineNumber)) ? _lineNumber : 1);\n        const column = Math.floor((typeof _column === 'number' && !isNaN(_column)) ? _column : 1);\n        const lineCount = this._buffer.getLineCount();\n        if (lineNumber < 1) {\n            return new Position(1, 1);\n        }\n        if (lineNumber > lineCount) {\n            return new Position(lineCount, this.getLineMaxColumn(lineCount));\n        }\n        if (column <= 1) {\n            return new Position(lineNumber, 1);\n        }\n        const maxColumn = this.getLineMaxColumn(lineNumber);\n        if (column >= maxColumn) {\n            return new Position(lineNumber, maxColumn);\n        }\n        if (validationType === 1 /* StringOffsetValidationType.SurrogatePairs */) {\n            // If the position would end up in the middle of a high-low surrogate pair,\n            // we move it to before the pair\n            // !!At this point, column > 1\n            const charCodeBefore = this._buffer.getLineCharCode(lineNumber, column - 2);\n            if (strings.isHighSurrogate(charCodeBefore)) {\n                return new Position(lineNumber, column - 1);\n            }\n        }\n        return new Position(lineNumber, column);\n    }\n    validatePosition(position) {\n        const validationType = 1 /* StringOffsetValidationType.SurrogatePairs */;\n        this._assertNotDisposed();\n        // Avoid object allocation and cover most likely case\n        if (position instanceof Position) {\n            if (this._isValidPosition(position.lineNumber, position.column, validationType)) {\n                return position;\n            }\n        }\n        return this._validatePosition(position.lineNumber, position.column, validationType);\n    }\n    _isValidRange(range, validationType) {\n        const startLineNumber = range.startLineNumber;\n        const startColumn = range.startColumn;\n        const endLineNumber = range.endLineNumber;\n        const endColumn = range.endColumn;\n        if (!this._isValidPosition(startLineNumber, startColumn, 0 /* StringOffsetValidationType.Relaxed */)) {\n            return false;\n        }\n        if (!this._isValidPosition(endLineNumber, endColumn, 0 /* StringOffsetValidationType.Relaxed */)) {\n            return false;\n        }\n        if (validationType === 1 /* StringOffsetValidationType.SurrogatePairs */) {\n            const charCodeBeforeStart = (startColumn > 1 ? this._buffer.getLineCharCode(startLineNumber, startColumn - 2) : 0);\n            const charCodeBeforeEnd = (endColumn > 1 && endColumn <= this._buffer.getLineLength(endLineNumber) ? this._buffer.getLineCharCode(endLineNumber, endColumn - 2) : 0);\n            const startInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeStart);\n            const endInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeEnd);\n            if (!startInsideSurrogatePair && !endInsideSurrogatePair) {\n                return true;\n            }\n            return false;\n        }\n        return true;\n    }\n    validateRange(_range) {\n        const validationType = 1 /* StringOffsetValidationType.SurrogatePairs */;\n        this._assertNotDisposed();\n        // Avoid object allocation and cover most likely case\n        if ((_range instanceof Range) && !(_range instanceof Selection)) {\n            if (this._isValidRange(_range, validationType)) {\n                return _range;\n            }\n        }\n        const start = this._validatePosition(_range.startLineNumber, _range.startColumn, 0 /* StringOffsetValidationType.Relaxed */);\n        const end = this._validatePosition(_range.endLineNumber, _range.endColumn, 0 /* StringOffsetValidationType.Relaxed */);\n        const startLineNumber = start.lineNumber;\n        const startColumn = start.column;\n        const endLineNumber = end.lineNumber;\n        const endColumn = end.column;\n        if (validationType === 1 /* StringOffsetValidationType.SurrogatePairs */) {\n            const charCodeBeforeStart = (startColumn > 1 ? this._buffer.getLineCharCode(startLineNumber, startColumn - 2) : 0);\n            const charCodeBeforeEnd = (endColumn > 1 && endColumn <= this._buffer.getLineLength(endLineNumber) ? this._buffer.getLineCharCode(endLineNumber, endColumn - 2) : 0);\n            const startInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeStart);\n            const endInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeEnd);\n            if (!startInsideSurrogatePair && !endInsideSurrogatePair) {\n                return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n            }\n            if (startLineNumber === endLineNumber && startColumn === endColumn) {\n                // do not expand a collapsed range, simply move it to a valid location\n                return new Range(startLineNumber, startColumn - 1, endLineNumber, endColumn - 1);\n            }\n            if (startInsideSurrogatePair && endInsideSurrogatePair) {\n                // expand range at both ends\n                return new Range(startLineNumber, startColumn - 1, endLineNumber, endColumn + 1);\n            }\n            if (startInsideSurrogatePair) {\n                // only expand range at the start\n                return new Range(startLineNumber, startColumn - 1, endLineNumber, endColumn);\n            }\n            // only expand range at the end\n            return new Range(startLineNumber, startColumn, endLineNumber, endColumn + 1);\n        }\n        return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n    }\n    modifyPosition(rawPosition, offset) {\n        this._assertNotDisposed();\n        const candidate = this.getOffsetAt(rawPosition) + offset;\n        return this.getPositionAt(Math.min(this._buffer.getLength(), Math.max(0, candidate)));\n    }\n    getFullModelRange() {\n        this._assertNotDisposed();\n        const lineCount = this.getLineCount();\n        return new Range(1, 1, lineCount, this.getLineMaxColumn(lineCount));\n    }\n    findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount) {\n        return this._buffer.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);\n    }\n    findMatches(searchString, rawSearchScope, isRegex, matchCase, wordSeparators, captureMatches, limitResultCount = LIMIT_FIND_COUNT) {\n        this._assertNotDisposed();\n        let searchRanges = null;\n        if (rawSearchScope !== null) {\n            if (!Array.isArray(rawSearchScope)) {\n                rawSearchScope = [rawSearchScope];\n            }\n            if (rawSearchScope.every((searchScope) => Range.isIRange(searchScope))) {\n                searchRanges = rawSearchScope.map((searchScope) => this.validateRange(searchScope));\n            }\n        }\n        if (searchRanges === null) {\n            searchRanges = [this.getFullModelRange()];\n        }\n        searchRanges = searchRanges.sort((d1, d2) => d1.startLineNumber - d2.startLineNumber || d1.startColumn - d2.startColumn);\n        const uniqueSearchRanges = [];\n        uniqueSearchRanges.push(searchRanges.reduce((prev, curr) => {\n            if (Range.areIntersecting(prev, curr)) {\n                return prev.plusRange(curr);\n            }\n            uniqueSearchRanges.push(prev);\n            return curr;\n        }));\n        let matchMapper;\n        if (!isRegex && searchString.indexOf('\\n') < 0) {\n            // not regex, not multi line\n            const searchParams = new SearchParams(searchString, isRegex, matchCase, wordSeparators);\n            const searchData = searchParams.parseSearchRequest();\n            if (!searchData) {\n                return [];\n            }\n            matchMapper = (searchRange) => this.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);\n        }\n        else {\n            matchMapper = (searchRange) => TextModelSearch.findMatches(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchRange, captureMatches, limitResultCount);\n        }\n        return uniqueSearchRanges.map(matchMapper).reduce((arr, matches) => arr.concat(matches), []);\n    }\n    findNextMatch(searchString, rawSearchStart, isRegex, matchCase, wordSeparators, captureMatches) {\n        this._assertNotDisposed();\n        const searchStart = this.validatePosition(rawSearchStart);\n        if (!isRegex && searchString.indexOf('\\n') < 0) {\n            const searchParams = new SearchParams(searchString, isRegex, matchCase, wordSeparators);\n            const searchData = searchParams.parseSearchRequest();\n            if (!searchData) {\n                return null;\n            }\n            const lineCount = this.getLineCount();\n            let searchRange = new Range(searchStart.lineNumber, searchStart.column, lineCount, this.getLineMaxColumn(lineCount));\n            let ret = this.findMatchesLineByLine(searchRange, searchData, captureMatches, 1);\n            TextModelSearch.findNextMatch(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);\n            if (ret.length > 0) {\n                return ret[0];\n            }\n            searchRange = new Range(1, 1, searchStart.lineNumber, this.getLineMaxColumn(searchStart.lineNumber));\n            ret = this.findMatchesLineByLine(searchRange, searchData, captureMatches, 1);\n            if (ret.length > 0) {\n                return ret[0];\n            }\n            return null;\n        }\n        return TextModelSearch.findNextMatch(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);\n    }\n    findPreviousMatch(searchString, rawSearchStart, isRegex, matchCase, wordSeparators, captureMatches) {\n        this._assertNotDisposed();\n        const searchStart = this.validatePosition(rawSearchStart);\n        return TextModelSearch.findPreviousMatch(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);\n    }\n    //#endregion\n    //#region Editing\n    pushStackElement() {\n        this._commandManager.pushStackElement();\n    }\n    popStackElement() {\n        this._commandManager.popStackElement();\n    }\n    pushEOL(eol) {\n        const currentEOL = (this.getEOL() === '\\n' ? 0 /* model.EndOfLineSequence.LF */ : 1 /* model.EndOfLineSequence.CRLF */);\n        if (currentEOL === eol) {\n            return;\n        }\n        try {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            this._eventEmitter.beginDeferredEmit();\n            if (this._initialUndoRedoSnapshot === null) {\n                this._initialUndoRedoSnapshot = this._undoRedoService.createSnapshot(this.uri);\n            }\n            this._commandManager.pushEOL(eol);\n        }\n        finally {\n            this._eventEmitter.endDeferredEmit();\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    _validateEditOperation(rawOperation) {\n        if (rawOperation instanceof model.ValidAnnotatedEditOperation) {\n            return rawOperation;\n        }\n        return new model.ValidAnnotatedEditOperation(rawOperation.identifier || null, this.validateRange(rawOperation.range), rawOperation.text, rawOperation.forceMoveMarkers || false, rawOperation.isAutoWhitespaceEdit || false, rawOperation._isTracked || false);\n    }\n    _validateEditOperations(rawOperations) {\n        const result = [];\n        for (let i = 0, len = rawOperations.length; i < len; i++) {\n            result[i] = this._validateEditOperation(rawOperations[i]);\n        }\n        return result;\n    }\n    pushEditOperations(beforeCursorState, editOperations, cursorStateComputer, group) {\n        try {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            this._eventEmitter.beginDeferredEmit();\n            return this._pushEditOperations(beforeCursorState, this._validateEditOperations(editOperations), cursorStateComputer, group);\n        }\n        finally {\n            this._eventEmitter.endDeferredEmit();\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    _pushEditOperations(beforeCursorState, editOperations, cursorStateComputer, group) {\n        if (this._options.trimAutoWhitespace && this._trimAutoWhitespaceLines) {\n            // Go through each saved line number and insert a trim whitespace edit\n            // if it is safe to do so (no conflicts with other edits).\n            const incomingEdits = editOperations.map((op) => {\n                return {\n                    range: this.validateRange(op.range),\n                    text: op.text\n                };\n            });\n            // Sometimes, auto-formatters change ranges automatically which can cause undesired auto whitespace trimming near the cursor\n            // We'll use the following heuristic: if the edits occur near the cursor, then it's ok to trim auto whitespace\n            let editsAreNearCursors = true;\n            if (beforeCursorState) {\n                for (let i = 0, len = beforeCursorState.length; i < len; i++) {\n                    const sel = beforeCursorState[i];\n                    let foundEditNearSel = false;\n                    for (let j = 0, lenJ = incomingEdits.length; j < lenJ; j++) {\n                        const editRange = incomingEdits[j].range;\n                        const selIsAbove = editRange.startLineNumber > sel.endLineNumber;\n                        const selIsBelow = sel.startLineNumber > editRange.endLineNumber;\n                        if (!selIsAbove && !selIsBelow) {\n                            foundEditNearSel = true;\n                            break;\n                        }\n                    }\n                    if (!foundEditNearSel) {\n                        editsAreNearCursors = false;\n                        break;\n                    }\n                }\n            }\n            if (editsAreNearCursors) {\n                for (let i = 0, len = this._trimAutoWhitespaceLines.length; i < len; i++) {\n                    const trimLineNumber = this._trimAutoWhitespaceLines[i];\n                    const maxLineColumn = this.getLineMaxColumn(trimLineNumber);\n                    let allowTrimLine = true;\n                    for (let j = 0, lenJ = incomingEdits.length; j < lenJ; j++) {\n                        const editRange = incomingEdits[j].range;\n                        const editText = incomingEdits[j].text;\n                        if (trimLineNumber < editRange.startLineNumber || trimLineNumber > editRange.endLineNumber) {\n                            // `trimLine` is completely outside this edit\n                            continue;\n                        }\n                        // At this point:\n                        //   editRange.startLineNumber <= trimLine <= editRange.endLineNumber\n                        if (trimLineNumber === editRange.startLineNumber && editRange.startColumn === maxLineColumn\n                            && editRange.isEmpty() && editText && editText.length > 0 && editText.charAt(0) === '\\n') {\n                            // This edit inserts a new line (and maybe other text) after `trimLine`\n                            continue;\n                        }\n                        if (trimLineNumber === editRange.startLineNumber && editRange.startColumn === 1\n                            && editRange.isEmpty() && editText && editText.length > 0 && editText.charAt(editText.length - 1) === '\\n') {\n                            // This edit inserts a new line (and maybe other text) before `trimLine`\n                            continue;\n                        }\n                        // Looks like we can't trim this line as it would interfere with an incoming edit\n                        allowTrimLine = false;\n                        break;\n                    }\n                    if (allowTrimLine) {\n                        const trimRange = new Range(trimLineNumber, 1, trimLineNumber, maxLineColumn);\n                        editOperations.push(new model.ValidAnnotatedEditOperation(null, trimRange, null, false, false, false));\n                    }\n                }\n            }\n            this._trimAutoWhitespaceLines = null;\n        }\n        if (this._initialUndoRedoSnapshot === null) {\n            this._initialUndoRedoSnapshot = this._undoRedoService.createSnapshot(this.uri);\n        }\n        return this._commandManager.pushEditOperation(beforeCursorState, editOperations, cursorStateComputer, group);\n    }\n    _applyUndo(changes, eol, resultingAlternativeVersionId, resultingSelection) {\n        const edits = changes.map((change) => {\n            const rangeStart = this.getPositionAt(change.newPosition);\n            const rangeEnd = this.getPositionAt(change.newEnd);\n            return {\n                range: new Range(rangeStart.lineNumber, rangeStart.column, rangeEnd.lineNumber, rangeEnd.column),\n                text: change.oldText\n            };\n        });\n        this._applyUndoRedoEdits(edits, eol, true, false, resultingAlternativeVersionId, resultingSelection);\n    }\n    _applyRedo(changes, eol, resultingAlternativeVersionId, resultingSelection) {\n        const edits = changes.map((change) => {\n            const rangeStart = this.getPositionAt(change.oldPosition);\n            const rangeEnd = this.getPositionAt(change.oldEnd);\n            return {\n                range: new Range(rangeStart.lineNumber, rangeStart.column, rangeEnd.lineNumber, rangeEnd.column),\n                text: change.newText\n            };\n        });\n        this._applyUndoRedoEdits(edits, eol, false, true, resultingAlternativeVersionId, resultingSelection);\n    }\n    _applyUndoRedoEdits(edits, eol, isUndoing, isRedoing, resultingAlternativeVersionId, resultingSelection) {\n        try {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            this._eventEmitter.beginDeferredEmit();\n            this._isUndoing = isUndoing;\n            this._isRedoing = isRedoing;\n            this.applyEdits(edits, false);\n            this.setEOL(eol);\n            this._overwriteAlternativeVersionId(resultingAlternativeVersionId);\n        }\n        finally {\n            this._isUndoing = false;\n            this._isRedoing = false;\n            this._eventEmitter.endDeferredEmit(resultingSelection);\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    applyEdits(rawOperations, computeUndoEdits = false) {\n        try {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            this._eventEmitter.beginDeferredEmit();\n            const operations = this._validateEditOperations(rawOperations);\n            return this._doApplyEdits(operations, computeUndoEdits);\n        }\n        finally {\n            this._eventEmitter.endDeferredEmit();\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    _doApplyEdits(rawOperations, computeUndoEdits) {\n        const oldLineCount = this._buffer.getLineCount();\n        const result = this._buffer.applyEdits(rawOperations, this._options.trimAutoWhitespace, computeUndoEdits);\n        const newLineCount = this._buffer.getLineCount();\n        const contentChanges = result.changes;\n        this._trimAutoWhitespaceLines = result.trimAutoWhitespaceLineNumbers;\n        if (contentChanges.length !== 0) {\n            // We do a first pass to update decorations\n            // because we want to read decorations in the second pass\n            // where we will emit content change events\n            // and we want to read the final decorations\n            for (let i = 0, len = contentChanges.length; i < len; i++) {\n                const change = contentChanges[i];\n                this._decorationsTree.acceptReplace(change.rangeOffset, change.rangeLength, change.text.length, change.forceMoveMarkers);\n            }\n            const rawContentChanges = [];\n            this._increaseVersionId();\n            let lineCount = oldLineCount;\n            for (let i = 0, len = contentChanges.length; i < len; i++) {\n                const change = contentChanges[i];\n                const [eolCount] = countEOL(change.text);\n                this._onDidChangeDecorations.fire();\n                const startLineNumber = change.range.startLineNumber;\n                const endLineNumber = change.range.endLineNumber;\n                const deletingLinesCnt = endLineNumber - startLineNumber;\n                const insertingLinesCnt = eolCount;\n                const editingLinesCnt = Math.min(deletingLinesCnt, insertingLinesCnt);\n                const changeLineCountDelta = (insertingLinesCnt - deletingLinesCnt);\n                const currentEditStartLineNumber = newLineCount - lineCount - changeLineCountDelta + startLineNumber;\n                const firstEditLineNumber = currentEditStartLineNumber;\n                const lastInsertedLineNumber = currentEditStartLineNumber + insertingLinesCnt;\n                const decorationsWithInjectedTextInEditedRange = this._decorationsTree.getInjectedTextInInterval(this, this.getOffsetAt(new Position(firstEditLineNumber, 1)), this.getOffsetAt(new Position(lastInsertedLineNumber, this.getLineMaxColumn(lastInsertedLineNumber))), 0);\n                const injectedTextInEditedRange = LineInjectedText.fromDecorations(decorationsWithInjectedTextInEditedRange);\n                const injectedTextInEditedRangeQueue = new ArrayQueue(injectedTextInEditedRange);\n                for (let j = editingLinesCnt; j >= 0; j--) {\n                    const editLineNumber = startLineNumber + j;\n                    const currentEditLineNumber = currentEditStartLineNumber + j;\n                    injectedTextInEditedRangeQueue.takeFromEndWhile(r => r.lineNumber > currentEditLineNumber);\n                    const decorationsInCurrentLine = injectedTextInEditedRangeQueue.takeFromEndWhile(r => r.lineNumber === currentEditLineNumber);\n                    rawContentChanges.push(new ModelRawLineChanged(editLineNumber, this.getLineContent(currentEditLineNumber), decorationsInCurrentLine));\n                }\n                if (editingLinesCnt < deletingLinesCnt) {\n                    // Must delete some lines\n                    const spliceStartLineNumber = startLineNumber + editingLinesCnt;\n                    rawContentChanges.push(new ModelRawLinesDeleted(spliceStartLineNumber + 1, endLineNumber));\n                }\n                if (editingLinesCnt < insertingLinesCnt) {\n                    const injectedTextInEditedRangeQueue = new ArrayQueue(injectedTextInEditedRange);\n                    // Must insert some lines\n                    const spliceLineNumber = startLineNumber + editingLinesCnt;\n                    const cnt = insertingLinesCnt - editingLinesCnt;\n                    const fromLineNumber = newLineCount - lineCount - cnt + spliceLineNumber + 1;\n                    const injectedTexts = [];\n                    const newLines = [];\n                    for (let i = 0; i < cnt; i++) {\n                        const lineNumber = fromLineNumber + i;\n                        newLines[i] = this.getLineContent(lineNumber);\n                        injectedTextInEditedRangeQueue.takeWhile(r => r.lineNumber < lineNumber);\n                        injectedTexts[i] = injectedTextInEditedRangeQueue.takeWhile(r => r.lineNumber === lineNumber);\n                    }\n                    rawContentChanges.push(new ModelRawLinesInserted(spliceLineNumber + 1, startLineNumber + insertingLinesCnt, newLines, injectedTexts));\n                }\n                lineCount += changeLineCountDelta;\n            }\n            this._emitContentChangedEvent(new ModelRawContentChangedEvent(rawContentChanges, this.getVersionId(), this._isUndoing, this._isRedoing), {\n                changes: contentChanges,\n                eol: this._buffer.getEOL(),\n                isEolChange: false,\n                versionId: this.getVersionId(),\n                isUndoing: this._isUndoing,\n                isRedoing: this._isRedoing,\n                isFlush: false\n            });\n        }\n        return (result.reverseEdits === null ? undefined : result.reverseEdits);\n    }\n    undo() {\n        return this._undoRedoService.undo(this.uri);\n    }\n    canUndo() {\n        return this._undoRedoService.canUndo(this.uri);\n    }\n    redo() {\n        return this._undoRedoService.redo(this.uri);\n    }\n    canRedo() {\n        return this._undoRedoService.canRedo(this.uri);\n    }\n    //#endregion\n    //#region Decorations\n    handleBeforeFireDecorationsChangedEvent(affectedInjectedTextLines) {\n        // This is called before the decoration changed event is fired.\n        if (affectedInjectedTextLines === null || affectedInjectedTextLines.size === 0) {\n            return;\n        }\n        const affectedLines = Array.from(affectedInjectedTextLines);\n        const lineChangeEvents = affectedLines.map(lineNumber => new ModelRawLineChanged(lineNumber, this.getLineContent(lineNumber), this._getInjectedTextInLine(lineNumber)));\n        this._onDidChangeInjectedText.fire(new ModelInjectedTextChangedEvent(lineChangeEvents));\n    }\n    changeDecorations(callback, ownerId = 0) {\n        this._assertNotDisposed();\n        try {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            return this._changeDecorations(ownerId, callback);\n        }\n        finally {\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    _changeDecorations(ownerId, callback) {\n        const changeAccessor = {\n            addDecoration: (range, options) => {\n                return this._deltaDecorationsImpl(ownerId, [], [{ range: range, options: options }])[0];\n            },\n            changeDecoration: (id, newRange) => {\n                this._changeDecorationImpl(id, newRange);\n            },\n            changeDecorationOptions: (id, options) => {\n                this._changeDecorationOptionsImpl(id, _normalizeOptions(options));\n            },\n            removeDecoration: (id) => {\n                this._deltaDecorationsImpl(ownerId, [id], []);\n            },\n            deltaDecorations: (oldDecorations, newDecorations) => {\n                if (oldDecorations.length === 0 && newDecorations.length === 0) {\n                    // nothing to do\n                    return [];\n                }\n                return this._deltaDecorationsImpl(ownerId, oldDecorations, newDecorations);\n            }\n        };\n        let result = null;\n        try {\n            result = callback(changeAccessor);\n        }\n        catch (e) {\n            onUnexpectedError(e);\n        }\n        // Invalidate change accessor\n        changeAccessor.addDecoration = invalidFunc;\n        changeAccessor.changeDecoration = invalidFunc;\n        changeAccessor.changeDecorationOptions = invalidFunc;\n        changeAccessor.removeDecoration = invalidFunc;\n        changeAccessor.deltaDecorations = invalidFunc;\n        return result;\n    }\n    deltaDecorations(oldDecorations, newDecorations, ownerId = 0) {\n        this._assertNotDisposed();\n        if (!oldDecorations) {\n            oldDecorations = [];\n        }\n        if (oldDecorations.length === 0 && newDecorations.length === 0) {\n            // nothing to do\n            return [];\n        }\n        try {\n            this._deltaDecorationCallCnt++;\n            if (this._deltaDecorationCallCnt > 1) {\n                console.warn(`Invoking deltaDecorations recursively could lead to leaking decorations.`);\n                onUnexpectedError(new Error(`Invoking deltaDecorations recursively could lead to leaking decorations.`));\n            }\n            this._onDidChangeDecorations.beginDeferredEmit();\n            return this._deltaDecorationsImpl(ownerId, oldDecorations, newDecorations);\n        }\n        finally {\n            this._onDidChangeDecorations.endDeferredEmit();\n            this._deltaDecorationCallCnt--;\n        }\n    }\n    _getTrackedRange(id) {\n        return this.getDecorationRange(id);\n    }\n    _setTrackedRange(id, newRange, newStickiness) {\n        const node = (id ? this._decorations[id] : null);\n        if (!node) {\n            if (!newRange) {\n                // node doesn't exist, the request is to delete => nothing to do\n                return null;\n            }\n            // node doesn't exist, the request is to set => add the tracked range\n            return this._deltaDecorationsImpl(0, [], [{ range: newRange, options: TRACKED_RANGE_OPTIONS[newStickiness] }], true)[0];\n        }\n        if (!newRange) {\n            // node exists, the request is to delete => delete node\n            this._decorationsTree.delete(node);\n            delete this._decorations[node.id];\n            return null;\n        }\n        // node exists, the request is to set => change the tracked range and its options\n        const range = this._validateRangeRelaxedNoAllocations(newRange);\n        const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n        const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n        this._decorationsTree.delete(node);\n        node.reset(this.getVersionId(), startOffset, endOffset, range);\n        node.setOptions(TRACKED_RANGE_OPTIONS[newStickiness]);\n        this._decorationsTree.insert(node);\n        return node.id;\n    }\n    removeAllDecorationsWithOwnerId(ownerId) {\n        if (this._isDisposed) {\n            return;\n        }\n        const nodes = this._decorationsTree.collectNodesFromOwner(ownerId);\n        for (let i = 0, len = nodes.length; i < len; i++) {\n            const node = nodes[i];\n            this._decorationsTree.delete(node);\n            delete this._decorations[node.id];\n        }\n    }\n    getDecorationOptions(decorationId) {\n        const node = this._decorations[decorationId];\n        if (!node) {\n            return null;\n        }\n        return node.options;\n    }\n    getDecorationRange(decorationId) {\n        const node = this._decorations[decorationId];\n        if (!node) {\n            return null;\n        }\n        return this._decorationsTree.getNodeRange(this, node);\n    }\n    getLineDecorations(lineNumber, ownerId = 0, filterOutValidation = false) {\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            return [];\n        }\n        return this.getLinesDecorations(lineNumber, lineNumber, ownerId, filterOutValidation);\n    }\n    getLinesDecorations(_startLineNumber, _endLineNumber, ownerId = 0, filterOutValidation = false, onlyMarginDecorations = false) {\n        const lineCount = this.getLineCount();\n        const startLineNumber = Math.min(lineCount, Math.max(1, _startLineNumber));\n        const endLineNumber = Math.min(lineCount, Math.max(1, _endLineNumber));\n        const endColumn = this.getLineMaxColumn(endLineNumber);\n        const range = new Range(startLineNumber, 1, endLineNumber, endColumn);\n        const decorations = this._getDecorationsInRange(range, ownerId, filterOutValidation, onlyMarginDecorations);\n        pushMany(decorations, this._decorationProvider.getDecorationsInRange(range, ownerId, filterOutValidation));\n        return decorations;\n    }\n    getDecorationsInRange(range, ownerId = 0, filterOutValidation = false, onlyMinimapDecorations = false, onlyMarginDecorations = false) {\n        const validatedRange = this.validateRange(range);\n        const decorations = this._getDecorationsInRange(validatedRange, ownerId, filterOutValidation, onlyMarginDecorations);\n        pushMany(decorations, this._decorationProvider.getDecorationsInRange(validatedRange, ownerId, filterOutValidation, onlyMinimapDecorations));\n        return decorations;\n    }\n    getOverviewRulerDecorations(ownerId = 0, filterOutValidation = false) {\n        return this._decorationsTree.getAll(this, ownerId, filterOutValidation, true, false);\n    }\n    getInjectedTextDecorations(ownerId = 0) {\n        return this._decorationsTree.getAllInjectedText(this, ownerId);\n    }\n    _getInjectedTextInLine(lineNumber) {\n        const startOffset = this._buffer.getOffsetAt(lineNumber, 1);\n        const endOffset = startOffset + this._buffer.getLineLength(lineNumber);\n        const result = this._decorationsTree.getInjectedTextInInterval(this, startOffset, endOffset, 0);\n        return LineInjectedText.fromDecorations(result).filter(t => t.lineNumber === lineNumber);\n    }\n    getAllDecorations(ownerId = 0, filterOutValidation = false) {\n        let result = this._decorationsTree.getAll(this, ownerId, filterOutValidation, false, false);\n        result = result.concat(this._decorationProvider.getAllDecorations(ownerId, filterOutValidation));\n        return result;\n    }\n    getAllMarginDecorations(ownerId = 0) {\n        return this._decorationsTree.getAll(this, ownerId, false, false, true);\n    }\n    _getDecorationsInRange(filterRange, filterOwnerId, filterOutValidation, onlyMarginDecorations) {\n        const startOffset = this._buffer.getOffsetAt(filterRange.startLineNumber, filterRange.startColumn);\n        const endOffset = this._buffer.getOffsetAt(filterRange.endLineNumber, filterRange.endColumn);\n        return this._decorationsTree.getAllInInterval(this, startOffset, endOffset, filterOwnerId, filterOutValidation, onlyMarginDecorations);\n    }\n    getRangeAt(start, end) {\n        return this._buffer.getRangeAt(start, end - start);\n    }\n    _changeDecorationImpl(decorationId, _range) {\n        const node = this._decorations[decorationId];\n        if (!node) {\n            return;\n        }\n        if (node.options.after) {\n            const oldRange = this.getDecorationRange(decorationId);\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(oldRange.endLineNumber);\n        }\n        if (node.options.before) {\n            const oldRange = this.getDecorationRange(decorationId);\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(oldRange.startLineNumber);\n        }\n        const range = this._validateRangeRelaxedNoAllocations(_range);\n        const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n        const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n        this._decorationsTree.delete(node);\n        node.reset(this.getVersionId(), startOffset, endOffset, range);\n        this._decorationsTree.insert(node);\n        this._onDidChangeDecorations.checkAffectedAndFire(node.options);\n        if (node.options.after) {\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(range.endLineNumber);\n        }\n        if (node.options.before) {\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(range.startLineNumber);\n        }\n    }\n    _changeDecorationOptionsImpl(decorationId, options) {\n        const node = this._decorations[decorationId];\n        if (!node) {\n            return;\n        }\n        const nodeWasInOverviewRuler = (node.options.overviewRuler && node.options.overviewRuler.color ? true : false);\n        const nodeIsInOverviewRuler = (options.overviewRuler && options.overviewRuler.color ? true : false);\n        this._onDidChangeDecorations.checkAffectedAndFire(node.options);\n        this._onDidChangeDecorations.checkAffectedAndFire(options);\n        if (node.options.after || options.after) {\n            const nodeRange = this._decorationsTree.getNodeRange(this, node);\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.endLineNumber);\n        }\n        if (node.options.before || options.before) {\n            const nodeRange = this._decorationsTree.getNodeRange(this, node);\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.startLineNumber);\n        }\n        const movedInOverviewRuler = nodeWasInOverviewRuler !== nodeIsInOverviewRuler;\n        const changedWhetherInjectedText = isOptionsInjectedText(options) !== isNodeInjectedText(node);\n        if (movedInOverviewRuler || changedWhetherInjectedText) {\n            this._decorationsTree.delete(node);\n            node.setOptions(options);\n            this._decorationsTree.insert(node);\n        }\n        else {\n            node.setOptions(options);\n        }\n    }\n    _deltaDecorationsImpl(ownerId, oldDecorationsIds, newDecorations, suppressEvents = false) {\n        const versionId = this.getVersionId();\n        const oldDecorationsLen = oldDecorationsIds.length;\n        let oldDecorationIndex = 0;\n        const newDecorationsLen = newDecorations.length;\n        let newDecorationIndex = 0;\n        this._onDidChangeDecorations.beginDeferredEmit();\n        try {\n            const result = new Array(newDecorationsLen);\n            while (oldDecorationIndex < oldDecorationsLen || newDecorationIndex < newDecorationsLen) {\n                let node = null;\n                if (oldDecorationIndex < oldDecorationsLen) {\n                    // (1) get ourselves an old node\n                    do {\n                        node = this._decorations[oldDecorationsIds[oldDecorationIndex++]];\n                    } while (!node && oldDecorationIndex < oldDecorationsLen);\n                    // (2) remove the node from the tree (if it exists)\n                    if (node) {\n                        if (node.options.after) {\n                            const nodeRange = this._decorationsTree.getNodeRange(this, node);\n                            this._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.endLineNumber);\n                        }\n                        if (node.options.before) {\n                            const nodeRange = this._decorationsTree.getNodeRange(this, node);\n                            this._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.startLineNumber);\n                        }\n                        this._decorationsTree.delete(node);\n                        if (!suppressEvents) {\n                            this._onDidChangeDecorations.checkAffectedAndFire(node.options);\n                        }\n                    }\n                }\n                if (newDecorationIndex < newDecorationsLen) {\n                    // (3) create a new node if necessary\n                    if (!node) {\n                        const internalDecorationId = (++this._lastDecorationId);\n                        const decorationId = `${this._instanceId};${internalDecorationId}`;\n                        node = new IntervalNode(decorationId, 0, 0);\n                        this._decorations[decorationId] = node;\n                    }\n                    // (4) initialize node\n                    const newDecoration = newDecorations[newDecorationIndex];\n                    const range = this._validateRangeRelaxedNoAllocations(newDecoration.range);\n                    const options = _normalizeOptions(newDecoration.options);\n                    const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n                    const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n                    node.ownerId = ownerId;\n                    node.reset(versionId, startOffset, endOffset, range);\n                    node.setOptions(options);\n                    if (node.options.after) {\n                        this._onDidChangeDecorations.recordLineAffectedByInjectedText(range.endLineNumber);\n                    }\n                    if (node.options.before) {\n                        this._onDidChangeDecorations.recordLineAffectedByInjectedText(range.startLineNumber);\n                    }\n                    if (!suppressEvents) {\n                        this._onDidChangeDecorations.checkAffectedAndFire(options);\n                    }\n                    this._decorationsTree.insert(node);\n                    result[newDecorationIndex] = node.id;\n                    newDecorationIndex++;\n                }\n                else {\n                    if (node) {\n                        delete this._decorations[node.id];\n                    }\n                }\n            }\n            return result;\n        }\n        finally {\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    //#endregion\n    //#region Tokenization\n    // TODO move them to the tokenization part.\n    getLanguageId() {\n        return this.tokenization.getLanguageId();\n    }\n    setLanguage(languageIdOrSelection, source) {\n        if (typeof languageIdOrSelection === 'string') {\n            this._languageSelectionListener.clear();\n            this._setLanguage(languageIdOrSelection, source);\n        }\n        else {\n            this._languageSelectionListener.value = languageIdOrSelection.onDidChange(() => this._setLanguage(languageIdOrSelection.languageId, source));\n            this._setLanguage(languageIdOrSelection.languageId, source);\n        }\n    }\n    _setLanguage(languageId, source) {\n        this.tokenization.setLanguageId(languageId, source);\n        this._languageService.requestRichLanguageFeatures(languageId);\n    }\n    getLanguageIdAtPosition(lineNumber, column) {\n        return this.tokenization.getLanguageIdAtPosition(lineNumber, column);\n    }\n    getWordAtPosition(position) {\n        return this._tokenizationTextModelPart.getWordAtPosition(position);\n    }\n    getWordUntilPosition(position) {\n        return this._tokenizationTextModelPart.getWordUntilPosition(position);\n    }\n    //#endregion\n    normalizePosition(position, affinity) {\n        return position;\n    }\n    /**\n     * Gets the column at which indentation stops at a given line.\n     * @internal\n    */\n    getLineIndentColumn(lineNumber) {\n        // Columns start with 1.\n        return indentOfLine(this.getLineContent(lineNumber)) + 1;\n    }\n};\nTextModel = TextModel_1 = __decorate([\n    __param(4, IUndoRedoService),\n    __param(5, ILanguageService),\n    __param(6, ILanguageConfigurationService),\n    __param(7, IInstantiationService)\n], TextModel);\nexport { TextModel };\nexport function indentOfLine(line) {\n    let indent = 0;\n    for (const c of line) {\n        if (c === ' ' || c === '\\t') {\n            indent++;\n        }\n        else {\n            break;\n        }\n    }\n    return indent;\n}\n//#region Decorations\nfunction isNodeInOverviewRuler(node) {\n    return (node.options.overviewRuler && node.options.overviewRuler.color ? true : false);\n}\nfunction isOptionsInjectedText(options) {\n    return !!options.after || !!options.before;\n}\nfunction isNodeInjectedText(node) {\n    return !!node.options.after || !!node.options.before;\n}\nclass DecorationsTrees {\n    constructor() {\n        this._decorationsTree0 = new IntervalTree();\n        this._decorationsTree1 = new IntervalTree();\n        this._injectedTextDecorationsTree = new IntervalTree();\n    }\n    ensureAllNodesHaveRanges(host) {\n        this.getAll(host, 0, false, false, false);\n    }\n    _ensureNodesHaveRanges(host, nodes) {\n        for (const node of nodes) {\n            if (node.range === null) {\n                node.range = host.getRangeAt(node.cachedAbsoluteStart, node.cachedAbsoluteEnd);\n            }\n        }\n        return nodes;\n    }\n    getAllInInterval(host, start, end, filterOwnerId, filterOutValidation, onlyMarginDecorations) {\n        const versionId = host.getVersionId();\n        const result = this._intervalSearch(start, end, filterOwnerId, filterOutValidation, versionId, onlyMarginDecorations);\n        return this._ensureNodesHaveRanges(host, result);\n    }\n    _intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations) {\n        const r0 = this._decorationsTree0.intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n        const r1 = this._decorationsTree1.intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n        const r2 = this._injectedTextDecorationsTree.intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n        return r0.concat(r1).concat(r2);\n    }\n    getInjectedTextInInterval(host, start, end, filterOwnerId) {\n        const versionId = host.getVersionId();\n        const result = this._injectedTextDecorationsTree.intervalSearch(start, end, filterOwnerId, false, versionId, false);\n        return this._ensureNodesHaveRanges(host, result).filter((i) => i.options.showIfCollapsed || !i.range.isEmpty());\n    }\n    getAllInjectedText(host, filterOwnerId) {\n        const versionId = host.getVersionId();\n        const result = this._injectedTextDecorationsTree.search(filterOwnerId, false, versionId, false);\n        return this._ensureNodesHaveRanges(host, result).filter((i) => i.options.showIfCollapsed || !i.range.isEmpty());\n    }\n    getAll(host, filterOwnerId, filterOutValidation, overviewRulerOnly, onlyMarginDecorations) {\n        const versionId = host.getVersionId();\n        const result = this._search(filterOwnerId, filterOutValidation, overviewRulerOnly, versionId, onlyMarginDecorations);\n        return this._ensureNodesHaveRanges(host, result);\n    }\n    _search(filterOwnerId, filterOutValidation, overviewRulerOnly, cachedVersionId, onlyMarginDecorations) {\n        if (overviewRulerOnly) {\n            return this._decorationsTree1.search(filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n        }\n        else {\n            const r0 = this._decorationsTree0.search(filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n            const r1 = this._decorationsTree1.search(filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n            const r2 = this._injectedTextDecorationsTree.search(filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n            return r0.concat(r1).concat(r2);\n        }\n    }\n    collectNodesFromOwner(ownerId) {\n        const r0 = this._decorationsTree0.collectNodesFromOwner(ownerId);\n        const r1 = this._decorationsTree1.collectNodesFromOwner(ownerId);\n        const r2 = this._injectedTextDecorationsTree.collectNodesFromOwner(ownerId);\n        return r0.concat(r1).concat(r2);\n    }\n    collectNodesPostOrder() {\n        const r0 = this._decorationsTree0.collectNodesPostOrder();\n        const r1 = this._decorationsTree1.collectNodesPostOrder();\n        const r2 = this._injectedTextDecorationsTree.collectNodesPostOrder();\n        return r0.concat(r1).concat(r2);\n    }\n    insert(node) {\n        if (isNodeInjectedText(node)) {\n            this._injectedTextDecorationsTree.insert(node);\n        }\n        else if (isNodeInOverviewRuler(node)) {\n            this._decorationsTree1.insert(node);\n        }\n        else {\n            this._decorationsTree0.insert(node);\n        }\n    }\n    delete(node) {\n        if (isNodeInjectedText(node)) {\n            this._injectedTextDecorationsTree.delete(node);\n        }\n        else if (isNodeInOverviewRuler(node)) {\n            this._decorationsTree1.delete(node);\n        }\n        else {\n            this._decorationsTree0.delete(node);\n        }\n    }\n    getNodeRange(host, node) {\n        const versionId = host.getVersionId();\n        if (node.cachedVersionId !== versionId) {\n            this._resolveNode(node, versionId);\n        }\n        if (node.range === null) {\n            node.range = host.getRangeAt(node.cachedAbsoluteStart, node.cachedAbsoluteEnd);\n        }\n        return node.range;\n    }\n    _resolveNode(node, cachedVersionId) {\n        if (isNodeInjectedText(node)) {\n            this._injectedTextDecorationsTree.resolveNode(node, cachedVersionId);\n        }\n        else if (isNodeInOverviewRuler(node)) {\n            this._decorationsTree1.resolveNode(node, cachedVersionId);\n        }\n        else {\n            this._decorationsTree0.resolveNode(node, cachedVersionId);\n        }\n    }\n    acceptReplace(offset, length, textLength, forceMoveMarkers) {\n        this._decorationsTree0.acceptReplace(offset, length, textLength, forceMoveMarkers);\n        this._decorationsTree1.acceptReplace(offset, length, textLength, forceMoveMarkers);\n        this._injectedTextDecorationsTree.acceptReplace(offset, length, textLength, forceMoveMarkers);\n    }\n}\nfunction cleanClassName(className) {\n    return className.replace(/[^a-z0-9\\-_]/gi, ' ');\n}\nclass DecorationOptions {\n    constructor(options) {\n        this.color = options.color || '';\n        this.darkColor = options.darkColor || '';\n    }\n}\nexport class ModelDecorationOverviewRulerOptions extends DecorationOptions {\n    constructor(options) {\n        super(options);\n        this._resolvedColor = null;\n        this.position = (typeof options.position === 'number' ? options.position : model.OverviewRulerLane.Center);\n    }\n    getColor(theme) {\n        if (!this._resolvedColor) {\n            if (theme.type !== 'light' && this.darkColor) {\n                this._resolvedColor = this._resolveColor(this.darkColor, theme);\n            }\n            else {\n                this._resolvedColor = this._resolveColor(this.color, theme);\n            }\n        }\n        return this._resolvedColor;\n    }\n    invalidateCachedColor() {\n        this._resolvedColor = null;\n    }\n    _resolveColor(color, theme) {\n        if (typeof color === 'string') {\n            return color;\n        }\n        const c = color ? theme.getColor(color.id) : null;\n        if (!c) {\n            return '';\n        }\n        return c.toString();\n    }\n}\nexport class ModelDecorationGlyphMarginOptions {\n    constructor(options) {\n        this.position = options?.position ?? model.GlyphMarginLane.Center;\n        this.persistLane = options?.persistLane;\n    }\n}\nexport class ModelDecorationMinimapOptions extends DecorationOptions {\n    constructor(options) {\n        super(options);\n        this.position = options.position;\n        this.sectionHeaderStyle = options.sectionHeaderStyle ?? null;\n        this.sectionHeaderText = options.sectionHeaderText ?? null;\n    }\n    getColor(theme) {\n        if (!this._resolvedColor) {\n            if (theme.type !== 'light' && this.darkColor) {\n                this._resolvedColor = this._resolveColor(this.darkColor, theme);\n            }\n            else {\n                this._resolvedColor = this._resolveColor(this.color, theme);\n            }\n        }\n        return this._resolvedColor;\n    }\n    invalidateCachedColor() {\n        this._resolvedColor = undefined;\n    }\n    _resolveColor(color, theme) {\n        if (typeof color === 'string') {\n            return Color.fromHex(color);\n        }\n        return theme.getColor(color.id);\n    }\n}\nexport class ModelDecorationInjectedTextOptions {\n    static from(options) {\n        if (options instanceof ModelDecorationInjectedTextOptions) {\n            return options;\n        }\n        return new ModelDecorationInjectedTextOptions(options);\n    }\n    constructor(options) {\n        this.content = options.content || '';\n        this.inlineClassName = options.inlineClassName || null;\n        this.inlineClassNameAffectsLetterSpacing = options.inlineClassNameAffectsLetterSpacing || false;\n        this.attachedData = options.attachedData || null;\n        this.cursorStops = options.cursorStops || null;\n    }\n}\nexport class ModelDecorationOptions {\n    static register(options) {\n        return new ModelDecorationOptions(options);\n    }\n    static createDynamic(options) {\n        return new ModelDecorationOptions(options);\n    }\n    constructor(options) {\n        this.description = options.description;\n        this.blockClassName = options.blockClassName ? cleanClassName(options.blockClassName) : null;\n        this.blockDoesNotCollapse = options.blockDoesNotCollapse ?? null;\n        this.blockIsAfterEnd = options.blockIsAfterEnd ?? null;\n        this.blockPadding = options.blockPadding ?? null;\n        this.stickiness = options.stickiness || 0 /* model.TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */;\n        this.zIndex = options.zIndex || 0;\n        this.className = options.className ? cleanClassName(options.className) : null;\n        this.shouldFillLineOnLineBreak = options.shouldFillLineOnLineBreak ?? null;\n        this.hoverMessage = options.hoverMessage || null;\n        this.glyphMarginHoverMessage = options.glyphMarginHoverMessage || null;\n        this.lineNumberHoverMessage = options.lineNumberHoverMessage || null;\n        this.isWholeLine = options.isWholeLine || false;\n        this.showIfCollapsed = options.showIfCollapsed || false;\n        this.collapseOnReplaceEdit = options.collapseOnReplaceEdit || false;\n        this.overviewRuler = options.overviewRuler ? new ModelDecorationOverviewRulerOptions(options.overviewRuler) : null;\n        this.minimap = options.minimap ? new ModelDecorationMinimapOptions(options.minimap) : null;\n        this.glyphMargin = options.glyphMarginClassName ? new ModelDecorationGlyphMarginOptions(options.glyphMargin) : null;\n        this.glyphMarginClassName = options.glyphMarginClassName ? cleanClassName(options.glyphMarginClassName) : null;\n        this.linesDecorationsClassName = options.linesDecorationsClassName ? cleanClassName(options.linesDecorationsClassName) : null;\n        this.lineNumberClassName = options.lineNumberClassName ? cleanClassName(options.lineNumberClassName) : null;\n        this.linesDecorationsTooltip = options.linesDecorationsTooltip ? strings.htmlAttributeEncodeValue(options.linesDecorationsTooltip) : null;\n        this.firstLineDecorationClassName = options.firstLineDecorationClassName ? cleanClassName(options.firstLineDecorationClassName) : null;\n        this.marginClassName = options.marginClassName ? cleanClassName(options.marginClassName) : null;\n        this.inlineClassName = options.inlineClassName ? cleanClassName(options.inlineClassName) : null;\n        this.inlineClassNameAffectsLetterSpacing = options.inlineClassNameAffectsLetterSpacing || false;\n        this.beforeContentClassName = options.beforeContentClassName ? cleanClassName(options.beforeContentClassName) : null;\n        this.afterContentClassName = options.afterContentClassName ? cleanClassName(options.afterContentClassName) : null;\n        this.after = options.after ? ModelDecorationInjectedTextOptions.from(options.after) : null;\n        this.before = options.before ? ModelDecorationInjectedTextOptions.from(options.before) : null;\n        this.hideInCommentTokens = options.hideInCommentTokens ?? false;\n        this.hideInStringTokens = options.hideInStringTokens ?? false;\n    }\n}\nModelDecorationOptions.EMPTY = ModelDecorationOptions.register({ description: 'empty' });\n/**\n * The order carefully matches the values of the enum.\n */\nconst TRACKED_RANGE_OPTIONS = [\n    ModelDecorationOptions.register({ description: 'tracked-range-always-grows-when-typing-at-edges', stickiness: 0 /* model.TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */ }),\n    ModelDecorationOptions.register({ description: 'tracked-range-never-grows-when-typing-at-edges', stickiness: 1 /* model.TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */ }),\n    ModelDecorationOptions.register({ description: 'tracked-range-grows-only-when-typing-before', stickiness: 2 /* model.TrackedRangeStickiness.GrowsOnlyWhenTypingBefore */ }),\n    ModelDecorationOptions.register({ description: 'tracked-range-grows-only-when-typing-after', stickiness: 3 /* model.TrackedRangeStickiness.GrowsOnlyWhenTypingAfter */ }),\n];\nfunction _normalizeOptions(options) {\n    if (options instanceof ModelDecorationOptions) {\n        return options;\n    }\n    return ModelDecorationOptions.createDynamic(options);\n}\nclass DidChangeDecorationsEmitter extends Disposable {\n    constructor(handleBeforeFire) {\n        super();\n        this.handleBeforeFire = handleBeforeFire;\n        this._actual = this._register(new Emitter());\n        this.event = this._actual.event;\n        this._affectedInjectedTextLines = null;\n        this._deferredCnt = 0;\n        this._shouldFireDeferred = false;\n        this._affectsMinimap = false;\n        this._affectsOverviewRuler = false;\n        this._affectsGlyphMargin = false;\n        this._affectsLineNumber = false;\n    }\n    beginDeferredEmit() {\n        this._deferredCnt++;\n    }\n    endDeferredEmit() {\n        this._deferredCnt--;\n        if (this._deferredCnt === 0) {\n            if (this._shouldFireDeferred) {\n                this.doFire();\n            }\n            this._affectedInjectedTextLines?.clear();\n            this._affectedInjectedTextLines = null;\n        }\n    }\n    recordLineAffectedByInjectedText(lineNumber) {\n        if (!this._affectedInjectedTextLines) {\n            this._affectedInjectedTextLines = new Set();\n        }\n        this._affectedInjectedTextLines.add(lineNumber);\n    }\n    checkAffectedAndFire(options) {\n        this._affectsMinimap ||= !!options.minimap?.position;\n        this._affectsOverviewRuler ||= !!options.overviewRuler?.color;\n        this._affectsGlyphMargin ||= !!options.glyphMarginClassName;\n        this._affectsLineNumber ||= !!options.lineNumberClassName;\n        this.tryFire();\n    }\n    fire() {\n        this._affectsMinimap = true;\n        this._affectsOverviewRuler = true;\n        this._affectsGlyphMargin = true;\n        this.tryFire();\n    }\n    tryFire() {\n        if (this._deferredCnt === 0) {\n            this.doFire();\n        }\n        else {\n            this._shouldFireDeferred = true;\n        }\n    }\n    doFire() {\n        this.handleBeforeFire(this._affectedInjectedTextLines);\n        const event = {\n            affectsMinimap: this._affectsMinimap,\n            affectsOverviewRuler: this._affectsOverviewRuler,\n            affectsGlyphMargin: this._affectsGlyphMargin,\n            affectsLineNumber: this._affectsLineNumber,\n        };\n        this._shouldFireDeferred = false;\n        this._affectsMinimap = false;\n        this._affectsOverviewRuler = false;\n        this._affectsGlyphMargin = false;\n        this._actual.fire(event);\n    }\n}\n//#endregion\nclass DidChangeContentEmitter extends Disposable {\n    constructor() {\n        super();\n        /**\n         * Both `fastEvent` and `slowEvent` work the same way and contain the same events, but first we invoke `fastEvent` and then `slowEvent`.\n         */\n        this._fastEmitter = this._register(new Emitter());\n        this.fastEvent = this._fastEmitter.event;\n        this._slowEmitter = this._register(new Emitter());\n        this.slowEvent = this._slowEmitter.event;\n        this._deferredCnt = 0;\n        this._deferredEvent = null;\n    }\n    beginDeferredEmit() {\n        this._deferredCnt++;\n    }\n    endDeferredEmit(resultingSelection = null) {\n        this._deferredCnt--;\n        if (this._deferredCnt === 0) {\n            if (this._deferredEvent !== null) {\n                this._deferredEvent.rawContentChangedEvent.resultingSelection = resultingSelection;\n                const e = this._deferredEvent;\n                this._deferredEvent = null;\n                this._fastEmitter.fire(e);\n                this._slowEmitter.fire(e);\n            }\n        }\n    }\n    fire(e) {\n        if (this._deferredCnt > 0) {\n            if (this._deferredEvent) {\n                this._deferredEvent = this._deferredEvent.merge(e);\n            }\n            else {\n                this._deferredEvent = e;\n            }\n            return;\n        }\n        this._fastEmitter.fire(e);\n        this._slowEmitter.fire(e);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Disposable } from '../../../base/common/lifecycle.js';\nexport class TextModelPart extends Disposable {\n    constructor() {\n        super(...arguments);\n        this._isDisposed = false;\n    }\n    dispose() {\n        super.dispose();\n        this._isDisposed = true;\n    }\n    assertNotDisposed() {\n        if (this._isDisposed) {\n            throw new Error('TextModelPart is disposed!');\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n * Returns:\n *  - -1 => the line consists of whitespace\n *  - otherwise => the indent level is returned value\n */\nexport function computeIndentLevel(line, tabSize) {\n    let indent = 0;\n    let i = 0;\n    const len = line.length;\n    while (i < len) {\n        const chCode = line.charCodeAt(i);\n        if (chCode === 32 /* CharCode.Space */) {\n            indent++;\n        }\n        else if (chCode === 9 /* CharCode.Tab */) {\n            indent = indent - indent % tabSize + tabSize;\n        }\n        else {\n            break;\n        }\n        i++;\n    }\n    if (i === len) {\n        return -1; // line only consists of whitespace\n    }\n    return indent;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar ModelService_1;\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable, DisposableStore } from '../../../base/common/lifecycle.js';\nimport * as platform from '../../../base/common/platform.js';\nimport { TextModel } from '../model/textModel.js';\nimport { EDITOR_MODEL_DEFAULTS } from '../core/textModelDefaults.js';\nimport { PLAINTEXT_LANGUAGE_ID } from '../languages/modesRegistry.js';\nimport { ITextResourcePropertiesService } from './textResourceConfiguration.js';\nimport { IConfigurationService } from '../../../platform/configuration/common/configuration.js';\nimport { IUndoRedoService } from '../../../platform/undoRedo/common/undoRedo.js';\nimport { StringSHA1 } from '../../../base/common/hash.js';\nimport { isEditStackElement } from '../model/editStack.js';\nimport { Schemas } from '../../../base/common/network.js';\nimport { equals } from '../../../base/common/objects.js';\nimport { IInstantiationService } from '../../../platform/instantiation/common/instantiation.js';\nfunction MODEL_ID(resource) {\n    return resource.toString();\n}\nclass ModelData {\n    constructor(model, onWillDispose, onDidChangeLanguage) {\n        this.model = model;\n        this._modelEventListeners = new DisposableStore();\n        this.model = model;\n        this._modelEventListeners.add(model.onWillDispose(() => onWillDispose(model)));\n        this._modelEventListeners.add(model.onDidChangeLanguage((e) => onDidChangeLanguage(model, e)));\n    }\n    dispose() {\n        this._modelEventListeners.dispose();\n    }\n}\nconst DEFAULT_EOL = (platform.isLinux || platform.isMacintosh) ? 1 /* DefaultEndOfLine.LF */ : 2 /* DefaultEndOfLine.CRLF */;\nclass DisposedModelInfo {\n    constructor(uri, initialUndoRedoSnapshot, time, sharesUndoRedoStack, heapSize, sha1, versionId, alternativeVersionId) {\n        this.uri = uri;\n        this.initialUndoRedoSnapshot = initialUndoRedoSnapshot;\n        this.time = time;\n        this.sharesUndoRedoStack = sharesUndoRedoStack;\n        this.heapSize = heapSize;\n        this.sha1 = sha1;\n        this.versionId = versionId;\n        this.alternativeVersionId = alternativeVersionId;\n    }\n}\nlet ModelService = class ModelService extends Disposable {\n    static { ModelService_1 = this; }\n    static { this.MAX_MEMORY_FOR_CLOSED_FILES_UNDO_STACK = 20 * 1024 * 1024; }\n    constructor(_configurationService, _resourcePropertiesService, _undoRedoService, _instantiationService) {\n        super();\n        this._configurationService = _configurationService;\n        this._resourcePropertiesService = _resourcePropertiesService;\n        this._undoRedoService = _undoRedoService;\n        this._instantiationService = _instantiationService;\n        this._onModelAdded = this._register(new Emitter());\n        this.onModelAdded = this._onModelAdded.event;\n        this._onModelRemoved = this._register(new Emitter());\n        this.onModelRemoved = this._onModelRemoved.event;\n        this._onModelModeChanged = this._register(new Emitter());\n        this.onModelLanguageChanged = this._onModelModeChanged.event;\n        this._modelCreationOptionsByLanguageAndResource = Object.create(null);\n        this._models = {};\n        this._disposedModels = new Map();\n        this._disposedModelsHeapSize = 0;\n        this._register(this._configurationService.onDidChangeConfiguration(e => this._updateModelOptions(e)));\n        this._updateModelOptions(undefined);\n    }\n    static _readModelOptions(config, isForSimpleWidget) {\n        let tabSize = EDITOR_MODEL_DEFAULTS.tabSize;\n        if (config.editor && typeof config.editor.tabSize !== 'undefined') {\n            const parsedTabSize = parseInt(config.editor.tabSize, 10);\n            if (!isNaN(parsedTabSize)) {\n                tabSize = parsedTabSize;\n            }\n            if (tabSize < 1) {\n                tabSize = 1;\n            }\n        }\n        let indentSize = 'tabSize';\n        if (config.editor && typeof config.editor.indentSize !== 'undefined' && config.editor.indentSize !== 'tabSize') {\n            const parsedIndentSize = parseInt(config.editor.indentSize, 10);\n            if (!isNaN(parsedIndentSize)) {\n                indentSize = Math.max(parsedIndentSize, 1);\n            }\n        }\n        let insertSpaces = EDITOR_MODEL_DEFAULTS.insertSpaces;\n        if (config.editor && typeof config.editor.insertSpaces !== 'undefined') {\n            insertSpaces = (config.editor.insertSpaces === 'false' ? false : Boolean(config.editor.insertSpaces));\n        }\n        let newDefaultEOL = DEFAULT_EOL;\n        const eol = config.eol;\n        if (eol === '\\r\\n') {\n            newDefaultEOL = 2 /* DefaultEndOfLine.CRLF */;\n        }\n        else if (eol === '\\n') {\n            newDefaultEOL = 1 /* DefaultEndOfLine.LF */;\n        }\n        let trimAutoWhitespace = EDITOR_MODEL_DEFAULTS.trimAutoWhitespace;\n        if (config.editor && typeof config.editor.trimAutoWhitespace !== 'undefined') {\n            trimAutoWhitespace = (config.editor.trimAutoWhitespace === 'false' ? false : Boolean(config.editor.trimAutoWhitespace));\n        }\n        let detectIndentation = EDITOR_MODEL_DEFAULTS.detectIndentation;\n        if (config.editor && typeof config.editor.detectIndentation !== 'undefined') {\n            detectIndentation = (config.editor.detectIndentation === 'false' ? false : Boolean(config.editor.detectIndentation));\n        }\n        let largeFileOptimizations = EDITOR_MODEL_DEFAULTS.largeFileOptimizations;\n        if (config.editor && typeof config.editor.largeFileOptimizations !== 'undefined') {\n            largeFileOptimizations = (config.editor.largeFileOptimizations === 'false' ? false : Boolean(config.editor.largeFileOptimizations));\n        }\n        let bracketPairColorizationOptions = EDITOR_MODEL_DEFAULTS.bracketPairColorizationOptions;\n        if (config.editor?.bracketPairColorization && typeof config.editor.bracketPairColorization === 'object') {\n            bracketPairColorizationOptions = {\n                enabled: !!config.editor.bracketPairColorization.enabled,\n                independentColorPoolPerBracketType: !!config.editor.bracketPairColorization.independentColorPoolPerBracketType\n            };\n        }\n        return {\n            isForSimpleWidget: isForSimpleWidget,\n            tabSize: tabSize,\n            indentSize: indentSize,\n            insertSpaces: insertSpaces,\n            detectIndentation: detectIndentation,\n            defaultEOL: newDefaultEOL,\n            trimAutoWhitespace: trimAutoWhitespace,\n            largeFileOptimizations: largeFileOptimizations,\n            bracketPairColorizationOptions\n        };\n    }\n    _getEOL(resource, language) {\n        if (resource) {\n            return this._resourcePropertiesService.getEOL(resource, language);\n        }\n        const eol = this._configurationService.getValue('files.eol', { overrideIdentifier: language });\n        if (eol && typeof eol === 'string' && eol !== 'auto') {\n            return eol;\n        }\n        return platform.OS === 3 /* platform.OperatingSystem.Linux */ || platform.OS === 2 /* platform.OperatingSystem.Macintosh */ ? '\\n' : '\\r\\n';\n    }\n    _shouldRestoreUndoStack() {\n        const result = this._configurationService.getValue('files.restoreUndoStack');\n        if (typeof result === 'boolean') {\n            return result;\n        }\n        return true;\n    }\n    getCreationOptions(languageIdOrSelection, resource, isForSimpleWidget) {\n        const language = (typeof languageIdOrSelection === 'string' ? languageIdOrSelection : languageIdOrSelection.languageId);\n        let creationOptions = this._modelCreationOptionsByLanguageAndResource[language + resource];\n        if (!creationOptions) {\n            const editor = this._configurationService.getValue('editor', { overrideIdentifier: language, resource });\n            const eol = this._getEOL(resource, language);\n            creationOptions = ModelService_1._readModelOptions({ editor, eol }, isForSimpleWidget);\n            this._modelCreationOptionsByLanguageAndResource[language + resource] = creationOptions;\n        }\n        return creationOptions;\n    }\n    _updateModelOptions(e) {\n        const oldOptionsByLanguageAndResource = this._modelCreationOptionsByLanguageAndResource;\n        this._modelCreationOptionsByLanguageAndResource = Object.create(null);\n        // Update options on all models\n        const keys = Object.keys(this._models);\n        for (let i = 0, len = keys.length; i < len; i++) {\n            const modelId = keys[i];\n            const modelData = this._models[modelId];\n            const language = modelData.model.getLanguageId();\n            const uri = modelData.model.uri;\n            if (e && !e.affectsConfiguration('editor', { overrideIdentifier: language, resource: uri }) && !e.affectsConfiguration('files.eol', { overrideIdentifier: language, resource: uri })) {\n                continue; // perf: skip if this model is not affected by configuration change\n            }\n            const oldOptions = oldOptionsByLanguageAndResource[language + uri];\n            const newOptions = this.getCreationOptions(language, uri, modelData.model.isForSimpleWidget);\n            ModelService_1._setModelOptionsForModel(modelData.model, newOptions, oldOptions);\n        }\n    }\n    static _setModelOptionsForModel(model, newOptions, currentOptions) {\n        if (currentOptions && currentOptions.defaultEOL !== newOptions.defaultEOL && model.getLineCount() === 1) {\n            model.setEOL(newOptions.defaultEOL === 1 /* DefaultEndOfLine.LF */ ? 0 /* EndOfLineSequence.LF */ : 1 /* EndOfLineSequence.CRLF */);\n        }\n        if (currentOptions\n            && (currentOptions.detectIndentation === newOptions.detectIndentation)\n            && (currentOptions.insertSpaces === newOptions.insertSpaces)\n            && (currentOptions.tabSize === newOptions.tabSize)\n            && (currentOptions.indentSize === newOptions.indentSize)\n            && (currentOptions.trimAutoWhitespace === newOptions.trimAutoWhitespace)\n            && equals(currentOptions.bracketPairColorizationOptions, newOptions.bracketPairColorizationOptions)) {\n            // Same indent opts, no need to touch the model\n            return;\n        }\n        if (newOptions.detectIndentation) {\n            model.detectIndentation(newOptions.insertSpaces, newOptions.tabSize);\n            model.updateOptions({\n                trimAutoWhitespace: newOptions.trimAutoWhitespace,\n                bracketColorizationOptions: newOptions.bracketPairColorizationOptions\n            });\n        }\n        else {\n            model.updateOptions({\n                insertSpaces: newOptions.insertSpaces,\n                tabSize: newOptions.tabSize,\n                indentSize: newOptions.indentSize,\n                trimAutoWhitespace: newOptions.trimAutoWhitespace,\n                bracketColorizationOptions: newOptions.bracketPairColorizationOptions\n            });\n        }\n    }\n    // --- begin IModelService\n    _insertDisposedModel(disposedModelData) {\n        this._disposedModels.set(MODEL_ID(disposedModelData.uri), disposedModelData);\n        this._disposedModelsHeapSize += disposedModelData.heapSize;\n    }\n    _removeDisposedModel(resource) {\n        const disposedModelData = this._disposedModels.get(MODEL_ID(resource));\n        if (disposedModelData) {\n            this._disposedModelsHeapSize -= disposedModelData.heapSize;\n        }\n        this._disposedModels.delete(MODEL_ID(resource));\n        return disposedModelData;\n    }\n    _ensureDisposedModelsHeapSize(maxModelsHeapSize) {\n        if (this._disposedModelsHeapSize > maxModelsHeapSize) {\n            // we must remove some old undo stack elements to free up some memory\n            const disposedModels = [];\n            this._disposedModels.forEach(entry => {\n                if (!entry.sharesUndoRedoStack) {\n                    disposedModels.push(entry);\n                }\n            });\n            disposedModels.sort((a, b) => a.time - b.time);\n            while (disposedModels.length > 0 && this._disposedModelsHeapSize > maxModelsHeapSize) {\n                const disposedModel = disposedModels.shift();\n                this._removeDisposedModel(disposedModel.uri);\n                if (disposedModel.initialUndoRedoSnapshot !== null) {\n                    this._undoRedoService.restoreSnapshot(disposedModel.initialUndoRedoSnapshot);\n                }\n            }\n        }\n    }\n    _createModelData(value, languageIdOrSelection, resource, isForSimpleWidget) {\n        // create & save the model\n        const options = this.getCreationOptions(languageIdOrSelection, resource, isForSimpleWidget);\n        const model = this._instantiationService.createInstance(TextModel, value, languageIdOrSelection, options, resource);\n        if (resource && this._disposedModels.has(MODEL_ID(resource))) {\n            const disposedModelData = this._removeDisposedModel(resource);\n            const elements = this._undoRedoService.getElements(resource);\n            const sha1Computer = this._getSHA1Computer();\n            const sha1IsEqual = (sha1Computer.canComputeSHA1(model)\n                ? sha1Computer.computeSHA1(model) === disposedModelData.sha1\n                : false);\n            if (sha1IsEqual || disposedModelData.sharesUndoRedoStack) {\n                for (const element of elements.past) {\n                    if (isEditStackElement(element) && element.matchesResource(resource)) {\n                        element.setModel(model);\n                    }\n                }\n                for (const element of elements.future) {\n                    if (isEditStackElement(element) && element.matchesResource(resource)) {\n                        element.setModel(model);\n                    }\n                }\n                this._undoRedoService.setElementsValidFlag(resource, true, (element) => (isEditStackElement(element) && element.matchesResource(resource)));\n                if (sha1IsEqual) {\n                    model._overwriteVersionId(disposedModelData.versionId);\n                    model._overwriteAlternativeVersionId(disposedModelData.alternativeVersionId);\n                    model._overwriteInitialUndoRedoSnapshot(disposedModelData.initialUndoRedoSnapshot);\n                }\n            }\n            else {\n                if (disposedModelData.initialUndoRedoSnapshot !== null) {\n                    this._undoRedoService.restoreSnapshot(disposedModelData.initialUndoRedoSnapshot);\n                }\n            }\n        }\n        const modelId = MODEL_ID(model.uri);\n        if (this._models[modelId]) {\n            // There already exists a model with this id => this is a programmer error\n            throw new Error('ModelService: Cannot add model because it already exists!');\n        }\n        const modelData = new ModelData(model, (model) => this._onWillDispose(model), (model, e) => this._onDidChangeLanguage(model, e));\n        this._models[modelId] = modelData;\n        return modelData;\n    }\n    createModel(value, languageSelection, resource, isForSimpleWidget = false) {\n        let modelData;\n        if (languageSelection) {\n            modelData = this._createModelData(value, languageSelection, resource, isForSimpleWidget);\n        }\n        else {\n            modelData = this._createModelData(value, PLAINTEXT_LANGUAGE_ID, resource, isForSimpleWidget);\n        }\n        this._onModelAdded.fire(modelData.model);\n        return modelData.model;\n    }\n    getModels() {\n        const ret = [];\n        const keys = Object.keys(this._models);\n        for (let i = 0, len = keys.length; i < len; i++) {\n            const modelId = keys[i];\n            ret.push(this._models[modelId].model);\n        }\n        return ret;\n    }\n    getModel(resource) {\n        const modelId = MODEL_ID(resource);\n        const modelData = this._models[modelId];\n        if (!modelData) {\n            return null;\n        }\n        return modelData.model;\n    }\n    // --- end IModelService\n    _schemaShouldMaintainUndoRedoElements(resource) {\n        return (resource.scheme === Schemas.file\n            || resource.scheme === Schemas.vscodeRemote\n            || resource.scheme === Schemas.vscodeUserData\n            || resource.scheme === Schemas.vscodeNotebookCell\n            || resource.scheme === 'fake-fs' // for tests\n        );\n    }\n    _onWillDispose(model) {\n        const modelId = MODEL_ID(model.uri);\n        const modelData = this._models[modelId];\n        const sharesUndoRedoStack = (this._undoRedoService.getUriComparisonKey(model.uri) !== model.uri.toString());\n        let maintainUndoRedoStack = false;\n        let heapSize = 0;\n        if (sharesUndoRedoStack || (this._shouldRestoreUndoStack() && this._schemaShouldMaintainUndoRedoElements(model.uri))) {\n            const elements = this._undoRedoService.getElements(model.uri);\n            if (elements.past.length > 0 || elements.future.length > 0) {\n                for (const element of elements.past) {\n                    if (isEditStackElement(element) && element.matchesResource(model.uri)) {\n                        maintainUndoRedoStack = true;\n                        heapSize += element.heapSize(model.uri);\n                        element.setModel(model.uri); // remove reference from text buffer instance\n                    }\n                }\n                for (const element of elements.future) {\n                    if (isEditStackElement(element) && element.matchesResource(model.uri)) {\n                        maintainUndoRedoStack = true;\n                        heapSize += element.heapSize(model.uri);\n                        element.setModel(model.uri); // remove reference from text buffer instance\n                    }\n                }\n            }\n        }\n        const maxMemory = ModelService_1.MAX_MEMORY_FOR_CLOSED_FILES_UNDO_STACK;\n        const sha1Computer = this._getSHA1Computer();\n        if (!maintainUndoRedoStack) {\n            if (!sharesUndoRedoStack) {\n                const initialUndoRedoSnapshot = modelData.model.getInitialUndoRedoSnapshot();\n                if (initialUndoRedoSnapshot !== null) {\n                    this._undoRedoService.restoreSnapshot(initialUndoRedoSnapshot);\n                }\n            }\n        }\n        else if (!sharesUndoRedoStack && (heapSize > maxMemory || !sha1Computer.canComputeSHA1(model))) {\n            // the undo stack for this file would never fit in the configured memory or the file is very large, so don't bother with it.\n            const initialUndoRedoSnapshot = modelData.model.getInitialUndoRedoSnapshot();\n            if (initialUndoRedoSnapshot !== null) {\n                this._undoRedoService.restoreSnapshot(initialUndoRedoSnapshot);\n            }\n        }\n        else {\n            this._ensureDisposedModelsHeapSize(maxMemory - heapSize);\n            // We only invalidate the elements, but they remain in the undo-redo service.\n            this._undoRedoService.setElementsValidFlag(model.uri, false, (element) => (isEditStackElement(element) && element.matchesResource(model.uri)));\n            this._insertDisposedModel(new DisposedModelInfo(model.uri, modelData.model.getInitialUndoRedoSnapshot(), Date.now(), sharesUndoRedoStack, heapSize, sha1Computer.computeSHA1(model), model.getVersionId(), model.getAlternativeVersionId()));\n        }\n        delete this._models[modelId];\n        modelData.dispose();\n        // clean up cache\n        delete this._modelCreationOptionsByLanguageAndResource[model.getLanguageId() + model.uri];\n        this._onModelRemoved.fire(model);\n    }\n    _onDidChangeLanguage(model, e) {\n        const oldLanguageId = e.oldLanguage;\n        const newLanguageId = model.getLanguageId();\n        const oldOptions = this.getCreationOptions(oldLanguageId, model.uri, model.isForSimpleWidget);\n        const newOptions = this.getCreationOptions(newLanguageId, model.uri, model.isForSimpleWidget);\n        ModelService_1._setModelOptionsForModel(model, newOptions, oldOptions);\n        this._onModelModeChanged.fire({ model, oldLanguageId: oldLanguageId });\n    }\n    _getSHA1Computer() {\n        return new DefaultModelSHA1Computer();\n    }\n};\nModelService = ModelService_1 = __decorate([\n    __param(0, IConfigurationService),\n    __param(1, ITextResourcePropertiesService),\n    __param(2, IUndoRedoService),\n    __param(3, IInstantiationService)\n], ModelService);\nexport { ModelService };\nexport class DefaultModelSHA1Computer {\n    static { this.MAX_MODEL_SIZE = 10 * 1024 * 1024; } // takes 200ms to compute a sha1 on a 10MB model on a new machine\n    canComputeSHA1(model) {\n        return (model.getValueLength() <= DefaultModelSHA1Computer.MAX_MODEL_SIZE);\n    }\n    computeSHA1(model) {\n        // compute the sha1\n        const shaComputer = new StringSHA1();\n        const snapshot = model.createSnapshot();\n        let text;\n        while ((text = snapshot.read())) {\n            shaComputer.update(text);\n        }\n        return shaComputer.digest();\n    }\n}\n","import { createDecorator } from '../../../platform/instantiation/common/instantiation.js';\nexport const ITextResourceConfigurationService = createDecorator('textResourceConfigurationService');\nexport const ITextResourcePropertiesService = createDecorator('textResourcePropertiesService');\n","import { createDecorator } from '../../../platform/instantiation/common/instantiation.js';\nexport const ITreeSitterParserService = createDecorator('treeSitterParserService');\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n * An event describing that a model has been reset to a new value.\n * @internal\n */\nexport class ModelRawFlush {\n    constructor() {\n        this.changeType = 1 /* RawContentChangedType.Flush */;\n    }\n}\n/**\n * Represents text injected on a line\n * @internal\n */\nexport class LineInjectedText {\n    static applyInjectedText(lineText, injectedTexts) {\n        if (!injectedTexts || injectedTexts.length === 0) {\n            return lineText;\n        }\n        let result = '';\n        let lastOriginalOffset = 0;\n        for (const injectedText of injectedTexts) {\n            result += lineText.substring(lastOriginalOffset, injectedText.column - 1);\n            lastOriginalOffset = injectedText.column - 1;\n            result += injectedText.options.content;\n        }\n        result += lineText.substring(lastOriginalOffset);\n        return result;\n    }\n    static fromDecorations(decorations) {\n        const result = [];\n        for (const decoration of decorations) {\n            if (decoration.options.before && decoration.options.before.content.length > 0) {\n                result.push(new LineInjectedText(decoration.ownerId, decoration.range.startLineNumber, decoration.range.startColumn, decoration.options.before, 0));\n            }\n            if (decoration.options.after && decoration.options.after.content.length > 0) {\n                result.push(new LineInjectedText(decoration.ownerId, decoration.range.endLineNumber, decoration.range.endColumn, decoration.options.after, 1));\n            }\n        }\n        result.sort((a, b) => {\n            if (a.lineNumber === b.lineNumber) {\n                if (a.column === b.column) {\n                    return a.order - b.order;\n                }\n                return a.column - b.column;\n            }\n            return a.lineNumber - b.lineNumber;\n        });\n        return result;\n    }\n    constructor(ownerId, lineNumber, column, options, order) {\n        this.ownerId = ownerId;\n        this.lineNumber = lineNumber;\n        this.column = column;\n        this.options = options;\n        this.order = order;\n    }\n}\n/**\n * An event describing that a line has changed in a model.\n * @internal\n */\nexport class ModelRawLineChanged {\n    constructor(lineNumber, detail, injectedText) {\n        this.changeType = 2 /* RawContentChangedType.LineChanged */;\n        this.lineNumber = lineNumber;\n        this.detail = detail;\n        this.injectedText = injectedText;\n    }\n}\n/**\n * An event describing that line(s) have been deleted in a model.\n * @internal\n */\nexport class ModelRawLinesDeleted {\n    constructor(fromLineNumber, toLineNumber) {\n        this.changeType = 3 /* RawContentChangedType.LinesDeleted */;\n        this.fromLineNumber = fromLineNumber;\n        this.toLineNumber = toLineNumber;\n    }\n}\n/**\n * An event describing that line(s) have been inserted in a model.\n * @internal\n */\nexport class ModelRawLinesInserted {\n    constructor(fromLineNumber, toLineNumber, detail, injectedTexts) {\n        this.changeType = 4 /* RawContentChangedType.LinesInserted */;\n        this.injectedTexts = injectedTexts;\n        this.fromLineNumber = fromLineNumber;\n        this.toLineNumber = toLineNumber;\n        this.detail = detail;\n    }\n}\n/**\n * An event describing that a model has had its EOL changed.\n * @internal\n */\nexport class ModelRawEOLChanged {\n    constructor() {\n        this.changeType = 5 /* RawContentChangedType.EOLChanged */;\n    }\n}\n/**\n * An event describing a change in the text of a model.\n * @internal\n */\nexport class ModelRawContentChangedEvent {\n    constructor(changes, versionId, isUndoing, isRedoing) {\n        this.changes = changes;\n        this.versionId = versionId;\n        this.isUndoing = isUndoing;\n        this.isRedoing = isRedoing;\n        this.resultingSelection = null;\n    }\n    containsEvent(type) {\n        for (let i = 0, len = this.changes.length; i < len; i++) {\n            const change = this.changes[i];\n            if (change.changeType === type) {\n                return true;\n            }\n        }\n        return false;\n    }\n    static merge(a, b) {\n        const changes = [].concat(a.changes).concat(b.changes);\n        const versionId = b.versionId;\n        const isUndoing = (a.isUndoing || b.isUndoing);\n        const isRedoing = (a.isRedoing || b.isRedoing);\n        return new ModelRawContentChangedEvent(changes, versionId, isUndoing, isRedoing);\n    }\n}\n/**\n * An event describing a change in injected text.\n * @internal\n */\nexport class ModelInjectedTextChangedEvent {\n    constructor(changes) {\n        this.changes = changes;\n    }\n}\n/**\n * @internal\n */\nexport class InternalModelContentChangeEvent {\n    constructor(rawContentChangedEvent, contentChangedEvent) {\n        this.rawContentChangedEvent = rawContentChangedEvent;\n        this.contentChangedEvent = contentChangedEvent;\n    }\n    merge(other) {\n        const rawContentChangedEvent = ModelRawContentChangedEvent.merge(this.rawContentChangedEvent, other.rawContentChangedEvent);\n        const contentChangedEvent = InternalModelContentChangeEvent._mergeChangeEvents(this.contentChangedEvent, other.contentChangedEvent);\n        return new InternalModelContentChangeEvent(rawContentChangedEvent, contentChangedEvent);\n    }\n    static _mergeChangeEvents(a, b) {\n        const changes = [].concat(a.changes).concat(b.changes);\n        const eol = b.eol;\n        const versionId = b.versionId;\n        const isUndoing = (a.isUndoing || b.isUndoing);\n        const isRedoing = (a.isRedoing || b.isRedoing);\n        const isFlush = (a.isFlush || b.isFlush);\n        const isEolChange = a.isEolChange && b.isEolChange; // both must be true to not confuse listeners who skip such edits\n        return {\n            changes: changes,\n            eol: eol,\n            isEolChange: isEolChange,\n            versionId: versionId,\n            isUndoing: isUndoing,\n            isRedoing: isRedoing,\n            isFlush: isFlush,\n        };\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport var HorizontalGuidesState;\n(function (HorizontalGuidesState) {\n    HorizontalGuidesState[HorizontalGuidesState[\"Disabled\"] = 0] = \"Disabled\";\n    HorizontalGuidesState[HorizontalGuidesState[\"EnabledForActive\"] = 1] = \"EnabledForActive\";\n    HorizontalGuidesState[HorizontalGuidesState[\"Enabled\"] = 2] = \"Enabled\";\n})(HorizontalGuidesState || (HorizontalGuidesState = {}));\nexport class IndentGuide {\n    constructor(visibleColumn, column, className, \n    /**\n     * If set, this indent guide is a horizontal guide (no vertical part).\n     * It starts at visibleColumn and continues until endColumn.\n    */\n    horizontalLine, \n    /**\n     * If set (!= -1), only show this guide for wrapped lines that don't contain this model column, but are after it.\n    */\n    forWrappedLinesAfterColumn, forWrappedLinesBeforeOrAtColumn) {\n        this.visibleColumn = visibleColumn;\n        this.column = column;\n        this.className = className;\n        this.horizontalLine = horizontalLine;\n        this.forWrappedLinesAfterColumn = forWrappedLinesAfterColumn;\n        this.forWrappedLinesBeforeOrAtColumn = forWrappedLinesBeforeOrAtColumn;\n        if ((visibleColumn !== -1) === (column !== -1)) {\n            throw new Error();\n        }\n    }\n}\nexport class IndentGuideHorizontalLine {\n    constructor(top, endColumn) {\n        this.top = top;\n        this.endColumn = endColumn;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { TokenMetadata } from '../encodedTokenAttributes.js';\nexport class LineTokens {\n    static { this.defaultTokenMetadata = ((0 /* FontStyle.None */ << 11 /* MetadataConsts.FONT_STYLE_OFFSET */)\n        | (1 /* ColorId.DefaultForeground */ << 15 /* MetadataConsts.FOREGROUND_OFFSET */)\n        | (2 /* ColorId.DefaultBackground */ << 24 /* MetadataConsts.BACKGROUND_OFFSET */)) >>> 0; }\n    static createEmpty(lineContent, decoder) {\n        const defaultMetadata = LineTokens.defaultTokenMetadata;\n        const tokens = new Uint32Array(2);\n        tokens[0] = lineContent.length;\n        tokens[1] = defaultMetadata;\n        return new LineTokens(tokens, lineContent, decoder);\n    }\n    static createFromTextAndMetadata(data, decoder) {\n        let offset = 0;\n        let fullText = '';\n        const tokens = new Array();\n        for (const { text, metadata } of data) {\n            tokens.push(offset + text.length, metadata);\n            offset += text.length;\n            fullText += text;\n        }\n        return new LineTokens(new Uint32Array(tokens), fullText, decoder);\n    }\n    constructor(tokens, text, decoder) {\n        this._lineTokensBrand = undefined;\n        this._tokens = tokens;\n        this._tokensCount = (this._tokens.length >>> 1);\n        this._text = text;\n        this.languageIdCodec = decoder;\n    }\n    equals(other) {\n        if (other instanceof LineTokens) {\n            return this.slicedEquals(other, 0, this._tokensCount);\n        }\n        return false;\n    }\n    slicedEquals(other, sliceFromTokenIndex, sliceTokenCount) {\n        if (this._text !== other._text) {\n            return false;\n        }\n        if (this._tokensCount !== other._tokensCount) {\n            return false;\n        }\n        const from = (sliceFromTokenIndex << 1);\n        const to = from + (sliceTokenCount << 1);\n        for (let i = from; i < to; i++) {\n            if (this._tokens[i] !== other._tokens[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    getLineContent() {\n        return this._text;\n    }\n    getCount() {\n        return this._tokensCount;\n    }\n    getStartOffset(tokenIndex) {\n        if (tokenIndex > 0) {\n            return this._tokens[(tokenIndex - 1) << 1];\n        }\n        return 0;\n    }\n    getMetadata(tokenIndex) {\n        const metadata = this._tokens[(tokenIndex << 1) + 1];\n        return metadata;\n    }\n    getLanguageId(tokenIndex) {\n        const metadata = this._tokens[(tokenIndex << 1) + 1];\n        const languageId = TokenMetadata.getLanguageId(metadata);\n        return this.languageIdCodec.decodeLanguageId(languageId);\n    }\n    getStandardTokenType(tokenIndex) {\n        const metadata = this._tokens[(tokenIndex << 1) + 1];\n        return TokenMetadata.getTokenType(metadata);\n    }\n    getForeground(tokenIndex) {\n        const metadata = this._tokens[(tokenIndex << 1) + 1];\n        return TokenMetadata.getForeground(metadata);\n    }\n    getClassName(tokenIndex) {\n        const metadata = this._tokens[(tokenIndex << 1) + 1];\n        return TokenMetadata.getClassNameFromMetadata(metadata);\n    }\n    getInlineStyle(tokenIndex, colorMap) {\n        const metadata = this._tokens[(tokenIndex << 1) + 1];\n        return TokenMetadata.getInlineStyleFromMetadata(metadata, colorMap);\n    }\n    getPresentation(tokenIndex) {\n        const metadata = this._tokens[(tokenIndex << 1) + 1];\n        return TokenMetadata.getPresentationFromMetadata(metadata);\n    }\n    getEndOffset(tokenIndex) {\n        return this._tokens[tokenIndex << 1];\n    }\n    /**\n     * Find the token containing offset `offset`.\n     * @param offset The search offset\n     * @return The index of the token containing the offset.\n     */\n    findTokenIndexAtOffset(offset) {\n        return LineTokens.findIndexInTokensArray(this._tokens, offset);\n    }\n    inflate() {\n        return this;\n    }\n    sliceAndInflate(startOffset, endOffset, deltaOffset) {\n        return new SliceLineTokens(this, startOffset, endOffset, deltaOffset);\n    }\n    static convertToEndOffset(tokens, lineTextLength) {\n        const tokenCount = (tokens.length >>> 1);\n        const lastTokenIndex = tokenCount - 1;\n        for (let tokenIndex = 0; tokenIndex < lastTokenIndex; tokenIndex++) {\n            tokens[tokenIndex << 1] = tokens[(tokenIndex + 1) << 1];\n        }\n        tokens[lastTokenIndex << 1] = lineTextLength;\n    }\n    static findIndexInTokensArray(tokens, desiredIndex) {\n        if (tokens.length <= 2) {\n            return 0;\n        }\n        let low = 0;\n        let high = (tokens.length >>> 1) - 1;\n        while (low < high) {\n            const mid = low + Math.floor((high - low) / 2);\n            const endOffset = tokens[(mid << 1)];\n            if (endOffset === desiredIndex) {\n                return mid + 1;\n            }\n            else if (endOffset < desiredIndex) {\n                low = mid + 1;\n            }\n            else if (endOffset > desiredIndex) {\n                high = mid;\n            }\n        }\n        return low;\n    }\n    /**\n     * @pure\n     * @param insertTokens Must be sorted by offset.\n    */\n    withInserted(insertTokens) {\n        if (insertTokens.length === 0) {\n            return this;\n        }\n        let nextOriginalTokenIdx = 0;\n        let nextInsertTokenIdx = 0;\n        let text = '';\n        const newTokens = new Array();\n        let originalEndOffset = 0;\n        while (true) {\n            const nextOriginalTokenEndOffset = nextOriginalTokenIdx < this._tokensCount ? this._tokens[nextOriginalTokenIdx << 1] : -1;\n            const nextInsertToken = nextInsertTokenIdx < insertTokens.length ? insertTokens[nextInsertTokenIdx] : null;\n            if (nextOriginalTokenEndOffset !== -1 && (nextInsertToken === null || nextOriginalTokenEndOffset <= nextInsertToken.offset)) {\n                // original token ends before next insert token\n                text += this._text.substring(originalEndOffset, nextOriginalTokenEndOffset);\n                const metadata = this._tokens[(nextOriginalTokenIdx << 1) + 1];\n                newTokens.push(text.length, metadata);\n                nextOriginalTokenIdx++;\n                originalEndOffset = nextOriginalTokenEndOffset;\n            }\n            else if (nextInsertToken) {\n                if (nextInsertToken.offset > originalEndOffset) {\n                    // insert token is in the middle of the next token.\n                    text += this._text.substring(originalEndOffset, nextInsertToken.offset);\n                    const metadata = this._tokens[(nextOriginalTokenIdx << 1) + 1];\n                    newTokens.push(text.length, metadata);\n                    originalEndOffset = nextInsertToken.offset;\n                }\n                text += nextInsertToken.text;\n                newTokens.push(text.length, nextInsertToken.tokenMetadata);\n                nextInsertTokenIdx++;\n            }\n            else {\n                break;\n            }\n        }\n        return new LineTokens(new Uint32Array(newTokens), text, this.languageIdCodec);\n    }\n    getTokenText(tokenIndex) {\n        const startOffset = this.getStartOffset(tokenIndex);\n        const endOffset = this.getEndOffset(tokenIndex);\n        const text = this._text.substring(startOffset, endOffset);\n        return text;\n    }\n    forEach(callback) {\n        const tokenCount = this.getCount();\n        for (let tokenIndex = 0; tokenIndex < tokenCount; tokenIndex++) {\n            callback(tokenIndex);\n        }\n    }\n}\nclass SliceLineTokens {\n    constructor(source, startOffset, endOffset, deltaOffset) {\n        this._source = source;\n        this._startOffset = startOffset;\n        this._endOffset = endOffset;\n        this._deltaOffset = deltaOffset;\n        this._firstTokenIndex = source.findTokenIndexAtOffset(startOffset);\n        this.languageIdCodec = source.languageIdCodec;\n        this._tokensCount = 0;\n        for (let i = this._firstTokenIndex, len = source.getCount(); i < len; i++) {\n            const tokenStartOffset = source.getStartOffset(i);\n            if (tokenStartOffset >= endOffset) {\n                break;\n            }\n            this._tokensCount++;\n        }\n    }\n    getMetadata(tokenIndex) {\n        return this._source.getMetadata(this._firstTokenIndex + tokenIndex);\n    }\n    getLanguageId(tokenIndex) {\n        return this._source.getLanguageId(this._firstTokenIndex + tokenIndex);\n    }\n    getLineContent() {\n        return this._source.getLineContent().substring(this._startOffset, this._endOffset);\n    }\n    equals(other) {\n        if (other instanceof SliceLineTokens) {\n            return (this._startOffset === other._startOffset\n                && this._endOffset === other._endOffset\n                && this._deltaOffset === other._deltaOffset\n                && this._source.slicedEquals(other._source, this._firstTokenIndex, this._tokensCount));\n        }\n        return false;\n    }\n    getCount() {\n        return this._tokensCount;\n    }\n    getStandardTokenType(tokenIndex) {\n        return this._source.getStandardTokenType(this._firstTokenIndex + tokenIndex);\n    }\n    getForeground(tokenIndex) {\n        return this._source.getForeground(this._firstTokenIndex + tokenIndex);\n    }\n    getEndOffset(tokenIndex) {\n        const tokenEndOffset = this._source.getEndOffset(this._firstTokenIndex + tokenIndex);\n        return Math.min(this._endOffset, tokenEndOffset) - this._startOffset + this._deltaOffset;\n    }\n    getClassName(tokenIndex) {\n        return this._source.getClassName(this._firstTokenIndex + tokenIndex);\n    }\n    getInlineStyle(tokenIndex, colorMap) {\n        return this._source.getInlineStyle(this._firstTokenIndex + tokenIndex, colorMap);\n    }\n    getPresentation(tokenIndex) {\n        return this._source.getPresentation(this._firstTokenIndex + tokenIndex);\n    }\n    findTokenIndexAtOffset(offset) {\n        return this._source.findTokenIndexAtOffset(offset + this._startOffset - this._deltaOffset) - this._firstTokenIndex;\n    }\n    getTokenText(tokenIndex) {\n        const adjustedTokenIndex = this._firstTokenIndex + tokenIndex;\n        const tokenStartOffset = this._source.getStartOffset(adjustedTokenIndex);\n        const tokenEndOffset = this._source.getEndOffset(adjustedTokenIndex);\n        let text = this._source.getTokenText(adjustedTokenIndex);\n        if (tokenStartOffset < this._startOffset) {\n            text = text.substring(this._startOffset - tokenStartOffset);\n        }\n        if (tokenEndOffset > this._endOffset) {\n            text = text.substring(0, text.length - (tokenEndOffset - this._endOffset));\n        }\n        return text;\n    }\n    forEach(callback) {\n        for (let tokenIndex = 0; tokenIndex < this.getCount(); tokenIndex++) {\n            callback(tokenIndex);\n        }\n    }\n}\nexport function getStandardTokenTypeAtPosition(model, position) {\n    const lineNumber = position.lineNumber;\n    if (!model.tokenization.isCheapToTokenize(lineNumber)) {\n        return undefined;\n    }\n    model.tokenization.forceTokenization(lineNumber);\n    const lineTokens = model.tokenization.getLineTokens(lineNumber);\n    const tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n    const tokenType = lineTokens.getStandardTokenType(tokenIndex);\n    return tokenType;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class SyncDescriptor {\n    constructor(ctor, staticArguments = [], supportsDelayedInstantiation = false) {\n        this.ctor = ctor;\n        this.staticArguments = staticArguments;\n        this.supportsDelayedInstantiation = supportsDelayedInstantiation;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { SyncDescriptor } from './descriptors.js';\nconst _registry = [];\nexport function registerSingleton(id, ctorOrDescriptor, supportsDelayedInstantiation) {\n    if (!(ctorOrDescriptor instanceof SyncDescriptor)) {\n        ctorOrDescriptor = new SyncDescriptor(ctorOrDescriptor, [], Boolean(supportsDelayedInstantiation));\n    }\n    _registry.push([id, ctorOrDescriptor]);\n}\nexport function getSingletonServiceDescriptors() {\n    return _registry;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { createDecorator } from '../../instantiation/common/instantiation.js';\nexport const IUndoRedoService = createDecorator('undoRedoService');\nexport class ResourceEditStackSnapshot {\n    constructor(resource, elements) {\n        this.resource = resource;\n        this.elements = elements;\n    }\n}\nexport class UndoRedoGroup {\n    static { this._ID = 0; }\n    constructor() {\n        this.id = UndoRedoGroup._ID++;\n        this.order = 1;\n    }\n    nextOrder() {\n        if (this.id === 0) {\n            return 0;\n        }\n        return this.order++;\n    }\n    static { this.None = new UndoRedoGroup(); }\n}\nexport class UndoRedoSource {\n    static { this._ID = 0; }\n    constructor() {\n        this.id = UndoRedoSource._ID++;\n        this.order = 1;\n    }\n    nextOrder() {\n        if (this.id === 0) {\n            return 0;\n        }\n        return this.order++;\n    }\n    static { this.None = new UndoRedoSource(); }\n}\n"],"names":["hasBuffer","Buffer","textDecoder","Uint8Array","VSBuffer","wrap","actual","isBuffer","from","buffer","byteOffset","byteLength","constructor","this","toString","TextDecoder","decode","readUInt16LE","source","offset","writeUInt16LE","destination","value","readUInt32BE","writeUInt32BE","readUInt8","writeUInt8","CursorColumns","_nextVisibleColumn","codePoint","visibleColumn","tabSize","nextRenderTabStop","visibleColumnFromColumn","lineContent","column","textLen","Math","min","length","text","substring","iterator","result","eol","nextGraphemeLength","columnFromVisibleColumn","lineContentLength","beforeVisibleColumn","beforeColumn","afterVisibleColumn","afterColumn","nextIndentTabStop","indentSize","prevRenderTabStop","max","prevIndentTabStop","normalizeIndentation","str","insertSpaces","firstNonWhitespaceIndex","spacesCnt","i","charAt","tabsCnt","floor","_normalizeIndentationFromWhitespace","_utf16LE_TextDecoder","_utf16BE_TextDecoder","_platformTextDecoder","getUTF16LE_TextDecoder","getPlatformTextDecoder","decodeUTF16LE","len","view","Uint16Array","resultLen","charCode","String","fromCharCode","join","compatDecodeUTF16LE","StringBuilder","capacity","_capacity","_buffer","_completedStrings","_bufferLength","reset","build","_flushBuffer","_buildBuffer","bufferString","appendCharCode","remainingSpace","appendASCIICharCode","appendString","strLen","charCodeAt","escapeNewLine","replace","TextChange","oldLength","oldText","oldEnd","oldPosition","newLength","newText","newEnd","newPosition","_writeStringSize","_writeString","b","_readString","writeSize","write","read","dest","push","compressConsecutiveTextChanges","prevEdits","currEdits","TextChangeCompressor","compress","_prevEdits","_currEdits","_result","_resultLen","_prevLen","_prevDeltaOffset","_currLen","_currDeltaOffset","prevIndex","currIndex","prevEdit","_getPrev","currEdit","_getCurr","_acceptCurr","_acceptPrev","e1","e2","_splitCurr","_splitPrev","mergePrev","mergeCurr","merged","_merge","_removeNoOps","_rebaseCurr","_rebasePrev","prevDeltaOffset","currDeltaOffset","edit","preText","substr","postText","edits","prev","curr","EDITOR_MODEL_DEFAULTS","detectIndentation","trimAutoWhitespace","largeFileOptimizations","bracketPairColorizationOptions","enabled","independentColorPoolPerBracketType","IndentAction","StandardAutoClosingPairConditional","_neutralCharacter","_neutralCharacterSearched","open","close","_inString","_inComment","_inRegEx","Array","isArray","notIn","isOK","standardToken","shouldAutoClose","context","getTokenCount","tokenIndex","findTokenIndexAtOffset","standardTokenType","getStandardTokenType","_findNeutralCharacterInRange","toCharCode","character","includes","findNeutralCharacter","AutoClosingPairs","autoClosingPairs","autoClosingPairsOpenByStart","Map","autoClosingPairsOpenByEnd","autoClosingPairsCloseByStart","autoClosingPairsCloseByEnd","autoClosingPairsCloseSingleChar","pair","appendEntry","target","key","has","get","set","CharacterPairSupport","DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED_QUOTES","DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED_BRACKETS","config","_autoClosingPairs","map","el","brackets","__electricCharacterSupport","docComment","_autoCloseBeforeForQuotes","autoCloseBefore","_autoCloseBeforeForBrackets","_surroundingPairs","surroundingPairs","getAutoClosingPairs","getAutoCloseBeforeSet","forQuotes","getSurroundingPairs","BracketElectricCharacterSupport","richEditBrackets","_richEditBrackets","getElectricCharacters","bracket","lastChar","onElectricCharacter","reversedBracketRegex","reversedRegex","getLineContent","r","findPrevBracketInRange","bracketText","startColumn","endColumn","toLowerCase","textIsOpenBracket","textBeforeBracket","getActualLineContentBefore","test","matchOpenBracket","resetGlobalRegex","reg","global","lastIndex","IndentRulesSupport","indentationRules","_indentationRules","shouldIncrease","increaseIndentPattern","shouldDecrease","decreaseIndentPattern","shouldIndentNextLine","indentNextLinePattern","shouldIgnore","unIndentedLinePattern","getIndentMetadata","ret","OnEnterSupport","opts","_brackets","forEach","openRegExp","_createOpenBracketRegExp","closeRegExp","_createCloseBracketRegExp","_regExpRules","onEnterRules","onEnter","autoIndent","previousLineText","beforeEnterText","afterEnterText","rule","beforeText","afterText","every","obj","action","indentAction","IndentOutdent","Indent","strings","_safeRegExp","def","RegExp","err","LanguageBracketsConfiguration","languageId","bracketPairs","filterValidBrackets","openingBracketInfos","closing","Set","info","OpeningBracketKind","closingBracketInfos","opening","openingColorized","ClosingBracketKind","add","colorizedBracketPairs","filter","p","_openingBrackets","cachedValues","k","v","_closingBrackets","openingBrackets","values","closingBrackets","getOpeningBracketInfo","getClosingBracketInfo","getBracketInfo","getBracketRegExp","options","keys","BracketKindBase","openedBrackets","super","isOpeningBracket","openingColorizedBrackets","closes","other","closesColorized","getOpeningBrackets","__param","paramIndex","decorator","LanguageConfigurationServiceChangeEvent","affects","ILanguageConfigurationService","LanguageConfigurationService","configurationService","languageService","_registry","_register","LanguageConfigurationRegistry","onDidChangeEmitter","onDidChange","event","configurations","languageConfigKeys","Object","customizedLanguageConfigKeys","onDidChangeConfiguration","e","globalConfigChanged","change","some","localConfigChanged","overrides","overrideLangName","clear","fire","undefined","isRegisteredLanguageId","delete","register","configuration","priority","getLanguageConfiguration","registry","languageConfig","ResolvedLanguageConfiguration","customizedConfig","getValue","overrideIdentifier","validateBracketPairs","getCustomizedLanguageConfig","data","combineLanguageConfigurations","underlyingConfig","computeConfig","decorators","desc","d","c","arguments","getOwnPropertyDescriptor","Reflect","decorate","defineProperty","__decorate","getIndentationAtPosition","model","lineNumber","lineText","indentation","ComposedLanguageConfiguration","_resolved","_entries","_order","entry","LanguageConfigurationContribution","splice","getResolvedConfiguration","_resolve","sort","cmp","configs","comments","wordPattern","folding","order","a","LanguageConfigurationChangeEvent","_onDidChange","offSide","entries","disposable","dispose","_electricCharacter","_onEnterSupport","_handleComments","characterPair","wordDefinition","indentRulesSupport","foldingRules","bracketsNew","getWordDefinition","electricCharacter","conf","commentRule","lineComment","lineCommentToken","blockComment","blockStart","blockEnd","blockCommentStartToken","blockCommentEndToken","NullState","clone","equals","nullTokenize","state","nullTokenizeEncoded","tokens","Uint32Array","createScopedLineTokens","tokenCount","getCount","desiredLanguageId","getLanguageId","lastTokenIndex","firstTokenIndex","ScopedLineTokens","getStartOffset","getEndOffset","firstCharOffset","lastCharOffset","_scopedLineTokensBrand","_actual","_firstTokenIndex","_lastTokenIndex","_lastCharOffset","languageIdCodec","getLineLength","toIViewLineTokens","sliceAndInflate","ignoreBracketsInToken","RichEditBracket","index","forwardRegex","_richEditBracketBrand","_openSet","_toSet","_closeSet","isOpen","isClose","arr","element","RichEditBrackets","_richEditBracketsBrand","N","group","areOverlapping","aOpen","aClose","bOpen","bClose","mergeGroups","g1","g2","newG","oldG","j","g","currentOpen","currentClose","groupFuzzyBrackets","currentIndex","pieces","concat","collectSuperstrings","unique","lengthcmp","reverse","createBracketOrRegExp","getRegexForBracketPair","toReversedString","getReversedRegexForBracketPair","getRegexForBrackets","getReversedRegexForBrackets","textIsBracket","maxBracketLength","indexOf","seen","prepareBracketForRegExp","insertWordBoundaries","regexStr","lastInput","lastOutput","BracketsUtils","_findPrevBracketInText","reversedText","m","match","matchOffset","matchLength","absoluteMatchOffset","startOffset","endOffset","reversedSubstr","findNextBracketInText","bracketRegex","findNextBracketInRange","BaseAstNode","_length","PairAstNode","create","openingBracket","child","closingBracket","missingOpeningBracketIds","getEmpty","kind","listHeight","childrenLength","getChild","idx","Error","children","canBeReused","openBracketIds","intersects","deepClone","computeMinIndentation","textModel","Number","MAX_SAFE_INTEGER","ListAstNode","create23","item1","item2","item3","immutable","missingBracketIds","merge","Immutable23ListAstNode","TwoThreeListAstNode","ImmutableArrayListAstNode","_missingOpeningBracketIds","cachedMinIndentation","throwIfImmutable","makeLastElementMutable","childCount","lastChild","mutable","toMutable","setChild","makeFirstElementMutable","firstChild","lastLength","handleChildrenChanged","count","unopenedBrackets","minIndentation","childOffset","_item3","_item1","_item2","node","appendChildOfSameHeight","unappendChild","prependChildOfSameHeight","unprependChild","ArrayListAstNode","_children","item","pop","unshift","shift","emptyArray","ImmutableLeafAstNode","TextAstNode","_openedBracketIds","start","startLineNumber","columnCount","lineCount","endLineNumber","firstNonWsColumn","getLineFirstNonWhitespaceColumn","getOptions","BracketAstNode","bracketInfo","bracketIds","InvalidBracketAstNode","openedBracketIds","TextEditInfo","fromModelContentChanges","changes","range","lift","getStartPosition","getEndPosition","BeforeEditPositionMapper","nextEditIdx","deltaOldToNewLineCount","deltaOldToNewColumnCount","deltaLineIdxInOld","TextEditInfoCache","getOffsetBeforeChange","adjustNextEdit","translateCurToOld","getDistanceToNextChange","nextEdit","nextChangeOffset","translateOldToCur","offsetObj","oldOffsetObj","newOffset","nextEditEndOffsetInCur","endOffsetAfterObj","nextEditEndOffsetInCurObj","nextEditEndOffsetBeforeInCurObj","endOffsetBeforeObj","lineDelta","previousColumnDelta","columnDelta","textLength","BracketTokens","createFromLanguage","denseKeyProvider","getId","getKey","openingTextId","hasRegExp","_regExpGlobal","getRegExpStr","isEmpty","escaped","regExpGlobal","regExpStr","getToken","findClosingTokenText","openingBracketIds","closingText","size","LanguageAgnosticBracketTokens","languageIdToBracketTokens","didLanguageChange","getSingleLanguageBracketTokens","singleLanguageBracketTokens","combineTextEditInfos","textEditInfoFirst","textEditInfoSecond","s0ToS1Map","toLengthMapping","s1ToS2Map","modified","lengthBefore","lengthAfter","curItem","dequeue","nextS0ToS1MapWithS1LengthOf","s1Length","takeWhile","remainingItem","splitAt","LengthMapping","pushEdit","lastResult","s0offset","s1ToS2","s0Length","s","s0EndOffset","s1","s0startOffset","remainingLengthAfter","textEditInfos","lastOffset","textEditInfo","spaceLength","lengthDiff","startLineCount","startColumnCount","endLineCount","endColumnCount","toLength","lengthZero","lengthIsZero","factor","lengthToObj","l","lengthGetLineCount","lengthGetColumnCountIfZeroLineCount","lengthAdd","l1","l2","sumLengths","items","lengthFn","reduce","lengthEquals","length1","length2","lengthDiffNonNegative","lineCount1","lineCount2","colCount2","lengthLessThan","lengthLessThanEqual","lengthGreaterThanEqual","positionToLength","position","lengthsToRange","lengthStart","lengthEnd","colCount","lengthOfString","lines","concat23TreesOfSameHeight","createImmutableLists","heightDiff","node1","node2","abs","list","nodeToAppend","curNode","parents","nodeToAppendOfCorrectHeight","parent","append","nodeToPrependOfCorrectHeight","prepend","NodeReader","nextNodes","offsets","idxs","readLongestNodeAt","predicate","lastOrUndefined","curNodeOffset","nextNodeAfterCurrent","nextChildIdx","getNextChildIdx","currentOffset","currentNode","curIdx","parseDocument","tokenizer","oldNode","Parser","_itemsConstructed","_itemsFromCache","oldNodeReader","positionMapper","parseList","level","tryReadChildFromCache","token","peek","parseChild","readNode","height","slice","first","second","concat23Trees","maxCacheableLength","cachedNode","skip","astNode","nextToken","bracketId","emptyArr","SmallImmutableSet","cache","additionalItems","cached","empty","keyProvider","newItem","newItems","identityKeyProvider","DenseKeyProvider","existing","Token","TextBufferTokenizer","bracketTokens","reader","NonPeekableTextBufferTokenizer","_offset","didPeek","peeked","textBufferLineCount","getLineCount","textBufferLastLineLength","setPosition","lineIdx","line","lineCharOffset","lineTokens","lineTokenOffset","peekedToken","tokenization","getLineTokens","startLineIdx","startLineCharOffset","lengthHeuristic","peekedBracketToken","tokenMetadata","getMetadata","isOther","getTokenType","containsBracketType","containsBalancedBrackets","regexp","exec","FastTokenizer","curLineCount","lastLineBreakOffset","lastTokenEndOffset","lastTokenEndLine","smallTextTokens0Line","smallTextTokens1Line","curOffset","uriGetComparisonKey","resource","SingleModelEditStackData","beforeCursorState","alternativeVersionId","getAlternativeVersionId","getModelEOL","beforeVersionId","afterVersionId","beforeEOL","afterEOL","afterCursorState","textChanges","_writeSelectionsSize","selections","_writeSelections","selection","selectionStartLineNumber","selectionStartColumn","positionLineNumber","positionColumn","_readSelections","serialize","necessarySize","deserialize","changeCount","SingleModelEditStackElement","type","isUri","uri","label","code","_data","matchesResource","setModel","canAppend","undo","_applyUndo","redo","_applyRedo","heapSize","MultiModelEditStackElement","resources","_editStackElementsArr","editStackElement","editStackElements","_isOpen","_editStackElementsMap","_delegate","prepareUndoRedo","split","getEOL","isEditStackElement","EditStack","undoRedoService","_model","_undoRedoService","pushStackElement","lastElement","getLastElement","popStackElement","removeElements","_getOrCreateEditStackElement","newElement","pushElement","pushEOL","setEOL","pushEditOperation","editOperations","cursorStateComputer","inverseEditOperations","applyEdits","_computeCursorState","op","textChange","GuidesTextModelPart","languageConfigurationService","_computeIndentLevel","lineIndex","getActiveIndentGuide","minLineNumber","maxLineNumber","assertNotDisposed","Boolean","up_aboveContentLineIndex","up_aboveContentLineIndent","up_belowContentLineIndex","up_belowContentLineIndent","up_resolveIndents","indent","down_aboveContentLineIndex","down_aboveContentLineIndent","down_belowContentLineIndex","down_belowContentLineIndent","down_resolveIndents","goUp","goDown","initialIndent","distance","upLineNumber","downLineNumber","upLineIndentLevel","currentIndent","ceil","_getIndentLevelForWhitespaceLine","downLineIndentLevel","getLinesBracketGuides","activePosition","getBracketPairsInRangeWithMinIndentation","getLineMaxColumn","toArray","activeBracketPairRange","bracketsContainingActivePosition","getBracketPairsInRange","fromPositions","bp","strictContainsPosition","colorProvider","BracketPairGuidesClassNames","closingBracketRange","isActive","equalsRange","includeInactive","className","getInlineClassName","nestingLevel","nestingLevelOfEqualBracketType","highlightActive","activeClassName","openingBracketRange","end","horizontalGuides","Enabled","EnabledForActive","endVisibleColumn","getVisibleColumnFromPosition","startVisibleColumn","guideVisibleColumn","minVisibleColumnIndentation","renderHorizontalEndLineAtTheBottom","visibleGuideStartLineNumber","visibleGuideEndLineNumber","guides","getLinesIndentGuides","aboveContentLineIndex","aboveContentLineIndent","belowContentLineIndex","belowContentLineIndent","resultIndex","getInlineClassNameOfLevel","BracketInfo","isInvalid","BracketPairInfo","bracketPairNode","openingBracketInfo","BracketPairWithMinIndentationInfo","BracketPairsTree","didChangeEmitter","queuedTextEditsForInitialAstWithoutTokens","queuedTextEdits","hasTokens","backgroundTokenizationState","initialAstWithoutTokens","astWithTokens","parseDocumentFromTextBuffer","handleDidChangeBackgroundTokenizationState","wasUndefined","handleDidChangeTokens","ranges","fromLineNumber","toLineNumber","handleEdits","handleContentChanged","tokenChange","flushQueue","previousAst","previousAstClone","getBracketsInRange","onlyColorizedBrackets","cb","collectBrackets","includeMinIndentation","startLength","endLength","CollectBracketPairsContext","collectBracketPairs","getFirstBracketAfter","getFirstBracketBefore","nodeOffsetStart","nodeOffsetEnd","lengths","levelPerBracketType","parentPairIsIncomplete","whileLoop","colorize","levelPerBracket","shouldContinue","openingBracketEnd","BracketPairsTextModelPart","canBuildAST","getValueLength","bracketPairsTree","bracketsRequested","handleLanguageConfigurationServiceChange","object","updateBracketPairsTree","handleDidChangeOptions","handleDidChangeLanguage","handleDidChangeContent","store","findMatchingBracketUp","_bracket","_position","maxDuration","validatePosition","getLanguageIdAtPosition","closingBracketInfo","bracketPair","findLast","bracketsSupport","stripBracketSearchCanceled","_findMatchingBracketUp","createTimeBasedContinueBracketSearchPredicate","matchBracket","containsPosition","findLastMaxBy","compareRangesUsingStarts","continueSearchPredicate","_matchBracket","_establishBracketSearchOffsets","modeBrackets","currentLanguageId","searchStartOffset","tokenEndOffset","searchEndOffset","tokenStartOffset","currentModeBrackets","bestResult","foundBracket","foundBracketText","_matchFoundBracket","BracketSearchCanceled","prevTokenIndex","prevModeBrackets","matched","_findMatchingBracketDown","totalCallCount","searchPrevMatchingBracketInRange","INSTANCE","hitText","prevSearchInToken","searchInToken","searchNextMatchingBracketInRange","findPrevBracket","bracketConfig","tokenLanguageId","_toFoundBracket","findNextBracket","findEnclosingBrackets","strictContainsRange","savedCounts","counts","resetCounts","tmp","searchInRange","getValueInRange","startTime","Date","now","_searchCanceledBrand","ColorizedBracketPairsDecorationProvider","ColorProvider","colorizationOptions","getDecorationsInRange","ownerId","filterOutValidation","onlyMinimapDecorations","id","description","inlineClassName","getAllDecorations","unexpectedClosingBracketClassName","theme","collector","colors","addRule","getColor","colorValues","isTransparent","color","SpacesDiffResult","spacesDiff","looksLikeAlignment","aLength","bLength","aSpacesCnt","aTabsCount","bSpacesCnt","bTabsCount","tabsDiff","guessIndentation","defaultTabSize","defaultInsertSpaces","linesCount","linesIndentedWithTabsCount","linesIndentedWithSpacesCount","previousLineIndentation","ALLOWED_TAB_SIZE_GUESSES","spacesDiffCount","currentLineLength","currentLineText","useCurrentLineText","currentLineHasContent","currentLineIndentation","currentLineSpacesCount","currentLineTabsCount","lenJ","getLineCharCode","currentSpacesDiff","tabSizeScore","possibleTabSize","possibleTabSizeScore","getNodeColor","metadata","setNodeColor","getNodeIsVisited","setNodeIsVisited","getNodeIsForValidation","setNodeIsForValidation","getNodeIsInGlyphMargin","setNodeIsInGlyphMargin","_setNodeStickiness","stickiness","setCollapseOnReplaceEdit","IntervalNode","left","right","delta","maxEnd","cachedVersionId","cachedAbsoluteStart","cachedAbsoluteEnd","versionId","setOptions","glyphMarginClassName","collapseOnReplaceEdit","setCachedOffsets","absoluteStart","absoluteEnd","detach","SENTINEL","IntervalTree","root","requestNormalizeDelta","intervalSearch","filterOwnerId","onlyMarginDecorations","T","intervalStart","intervalEnd","nodeMaxEnd","nodeStart","nodeEnd","include","search","collectNodesFromOwner","collectNodesPostOrder","insert","rbTreeInsert","_normalizeDeltaIfNecessary","rbTreeDelete","resolveNode","initialNode","acceptReplace","forceMoveMarkers","nodesOfInterest","searchForEditing","editDelta","recomputeMaxEnd","noOverlapReplace","nodeAcceptEdit","normalizeDelta","adjustMarkerBeforeColumn","markerOffset","markerStickToPreviousCharacter","checkOffset","moveSemantics","nodeStickiness","getNodeStickiness","startStickToPreviousCharacter","endStickToPreviousCharacter","deletingCnt","insertingCnt","commonLength","startDone","endDone","getCollapseOnReplaceEdit","deltaColumn","newNode","z","x","zAbsoluteStart","zAbsoluteEnd","aStart","aEnd","bStart","bEnd","treeInsert","recomputeMaxEndWalkToRoot","y","leftRotate","rightRotate","leftest","resetSentinel","yWasRed","w","computeMaxEnd","leftMaxEnd","rightMaxEnd","TreeNode","piece","size_left","lf_left","next","righttest","calculateSize","calculateLF","lineFeedCnt","tree","rbDelete","recomputeTreeMetadata","newSizeLeft","newLFLeft","lf_delta","updateTreeMetadata","fixInsert","lineFeedCntDelta","AverageBufferSize","createUintArray","LineStarts","lineStarts","cr","lf","crlf","isBasicASCII","createLineStartsFast","readonly","rLength","chr","Piece","bufferIndex","StringBuffer","PieceTreeSnapshot","BOM","_pieces","_tree","_BOM","_index","iterate","getPieceContent","PieceTreeSearchCache","limit","_limit","_cache","nodePos","nodeStartOffset","get2","nodeStartLineNumber","nodePosition","validate","hasInvalidVal","newArr","PieceTreeBase","chunks","eolNormalized","_buffers","_lastChangeBufferPos","_lineCnt","_EOL","_EOLLength","_EOLNormalized","lastNode","rbInsertRight","_searchCache","_lastVisitedLine","computeBufferMetadata","normalizeEOL","averageBufferSize","tempChunk","tempChunkLen","getNodeContent","newEOL","createSnapshot","getOffsetAt","leftLen","getAccumulatedValue","getPositionAt","lfCnt","originalOffset","out","getIndexOf","remainder","startPosition","nodeAt2","endPosition","getValueInRange2","offsetInBuffer","getLinesContent","linesLength","currentLine","danglingCR","pieceLength","pieceStartLine","pieceEndLine","pieceStartOffset","getLength","getLineRawContent","_getCharCode","matchingNode","targetOffset","findMatchesInNode","searcher","startCursor","endCursor","searchData","captureMatches","limitResultCount","startOffsetInBuffer","searchText","_wordSeparators","positionInBuffer","getLineFeedCnt","retStartColumn","retEndColumn","findMatchesLineByLine","searchRange","wordSeparators","regex","lineBreakCnt","nextLineStartOffset","_findMatchesInLine","deltaOffset","simpleSearch","searchString","searchStringLen","lastMatchIndex","nodeAt","insertPosInBuffer","appendToNode","insertContentToNodeLeft","nodesToDel","newRightPiece","shouldCheckCRLF","endWithCR","nodeCharCodeAt","newStart","startWithLF","previousPos","deleteNodeTail","newPieces","createNewPieces","tmpNode","deleteNodes","insertContentToNodeRight","rbInsertLeft","cnt","startNode","endNode","startSplitPosInBuffer","endSplitPosInBuffer","validateCRLFWithPrevNode","deleteNodeHead","validateCRLFWithNextNode","shrinkNode","nPiece","adjustCarriageReturnFromNext","low","high","mid","midStop","midStart","previousCharOffset","cursor","nodes","splitText","endIndex","endPos","newPiece","prevAccumulatedValue","accumulatedValue","originalLineNumber","pos","lineCnt","realLineCnt","expectedLineStartIndex","originalLFCnt","originalEndOffset","newEndOffset","newLineFeedCnt","size_delta","originalStartOffset","originalStartPos","originalEndPos","oldLFCnt","hitCRLF","prevStartOffset","oldLineFeedCnt","prevAccumualtedValue","offsetOfNode","val","nextNode","fixCRLF","prevNewLength","prevNewLFCnt","callback","leftRet","prevNode","PieceTreeTextBuffer","containsRTL","containsUnusualLineTerminators","_onDidChangeContent","_mightContainNonBasicASCII","_mightContainRTL","_mightContainUnusualLineTerminators","_pieceTree","mightContainRTL","mightContainUnusualLineTerminators","resetMightContainUnusualLineTerminators","mightContainNonBasicASCII","getBOM","preserveBOM","getRangeAt","lineEnding","_getEndOfLine","getValueLengthInRange","eolOffsetCompensation","desiredEOL","actualEOL","getCharacterCountInRange","fromOffset","toOffset","getLineLastNonWhitespaceColumn","rawOperations","recordTrimAutoWhitespace","computeUndoEdits","canReduceOperations","operations","_isTracked","validatedRange","textMightContainNonBasicASCII","validText","eolCount","firstLineLength","lastLineLength","strEOL","bufferEOL","sortIndex","identifier","rangeOffset","rangeLength","isAutoWhitespaceEdit","_sortOpsAscending","hasTouchingRanges","rangeEnd","nextRangeStart","isBeforeOrEqual","isBefore","_reduceOperations","reverseRanges","_getInverseEditRanges","newTrimAutoWhitespaceCandidates","reverseRange","currentLineContent","oldContent","reverseOperations","reverseRangeDeltaOffset","bufferText","reverseRangeOffset","contentChanges","_doApplyEdits","trimAutoWhitespaceLineNumbers","prevContent","_toSingleEditOperation","firstEditRange","lastEditRange","entireEditRange","lastEndLineNumber","lastEndColumn","operation","_sortOpsDescending","contentChangeRange","prevOpEndLineNumber","prevOpEndColumn","prevOp","resultRange","compareRangesUsingEnds","PieceTreeTextBufferFactory","_chunks","_bom","_cr","_lf","_crlf","_containsRTL","_containsUnusualLineTerminators","_isBasicASCII","_normalizeEOL","_getEOL","defaultEOL","totalEOLCount","totalCRCount","newLineStart","textBuffer","PieceTreeTextBufferBuilder","_hasPreviousChar","_previousChar","_tmpLineStarts","acceptChunk","chunk","_acceptChunk1","allowEmptyStrings","_acceptChunk2","createLineStarts","finish","_finish","lastChunk","newLineStarts","FixedArray","_default","_store","before","after","insertArr","arrayFill","deleteIndex","deleteCount","insertIndex","insertCount","ContiguousMultilineTokens","_startLineNumber","_tokens","appendLineTokens","ContiguousMultilineTokensBuilder","last","finalize","TokenizerWithStateStore","tokenizationSupport","initialState","getInitialState","TrackingTokenizationStateStore","getStartState","getFirstInvalidLine","TokenizerWithStateStoreAndTextModel","_textModel","_languageIdCodec","updateTokensUntilLine","builder","lineToTokenize","safeTokenize","startState","setEndState","endState","getTokenTypeIfInsertingCharacter","lineStartState","tokenizeLineWithEdit","curLineContent","newLineContent","hasAccurateTokensForLine","getFirstInvalidEndStateLineNumberOrMax","isCheapToTokenize","firstInvalidLineNumber","tokenizeHeuristically","heuristicTokens","guessStartState","nonWhitespaceColumn","likelyRelevantLines","newNonWhitespaceIndex","_tokenizationStateStore","TokenizationStateStore","_invalidEndStatesLineNumbers","RangePriorityQueueImpl","addRange","getEndState","acceptChange","newLineCount","addRangeAndResize","endLineNumberExclusive","acceptChanges","invalidateEndStateRange","getFirstInvalidEndStateLineNumber","allStatesValid","_lineEndStates","oldState","_ranges","findIndex","contains","endExclusive","idxFirstMightBeIntersecting","idxFirstIsAfter","newRange","endEx","hasEOL","tokenizeEncoded","encodeLanguageId","convertToEndOffset","DefaultBackgroundTokenizer","_tokenizerWithStateStore","_backgroundTokenStore","_isDisposed","_isScheduled","handleChanges","_beginBackgroundTokenization","isAttachedToEditor","_hasLinesToTokenize","deadline","_backgroundTokenizeWithDeadline","endTime","timeRemaining","execute","_backgroundTokenizeForAtLeast1ms","sw","elapsed","_tokenizeOneInvalidLine","setTokens","checkFinished","firstInvalidLine","backgroundTokenizationFinished","requestTokens","AttachedViews","_onDidChangeVisibleRanges","onDidChangeVisibleRanges","_views","attachView","AttachedViewImpl","detachView","handleStateChange","setVisibleLines","visibleLines","stabilized","visibleLineRanges","AttachedViewHandler","lineRanges","_lineRanges","_refreshTokens","runner","update","_computedLineRanges","cancel","schedule","AbstractTokens","_backgroundTokenizationState","_onDidChangeBackgroundTokenizationState","onDidChangeBackgroundTokenizationState","_onDidChangeTokens","onDidChangeTokens","tokenizeIfCheap","forceTokenization","TreeSitterTokens","_treeSitterService","_tokenizationSupport","_initialize","newLanguage","_lastLanguageId","content","rawTokens","createEmpty","resetTokenization","fireTokenChangeEvent","semanticTokensApplied","handleDidChangeAttached","isFlush","getParseResult","EMPTY_LINE_TOKENS","ContiguousTokensEditing","deleteBeginning","toChIndex","deleteEnding","fromChIndex","toUint32Array","lineTextLength","tokensCount","fromTokenIndex","findIndexInTokensArray","fromTokenStartOffset","lastEnd","subarray","_otherTokens","myTokens","otherTokens","otherTokensCount","chIndex","ContiguousTokensStore","_lineTokens","_len","flush","getTokens","topLevelLanguageId","rawLineTokens","getDefaultMetadata","_massageTokens","hasDifferentLanguageId","_ensureLine","_deleteLines","_insertLines","arrays","checkEquality","oldTokens","_equals","_a","_b","acceptEdit","_acceptDeleteRange","_acceptInsertText","firstLineIndex","lastLineIndex","lastLineTokens","setMultilineTokens","minChangedLineNumber","maxChangedLineNumber","hasChange","SparseTokensStore","_isComplete","isComplete","setPartial","_range","_firstRange","getRange","_lastRange","plusRange","insertPosition","removeTokens","addSparseTokens","aTokens","bTokens","_findFirstPieceWithLine","aLen","bLen","aIndex","lastEndOffset","emitToken","bIndex","bStartCharacter","getStartCharacter","bEndCharacter","getEndCharacter","bMetadata","bMask","aMask","aMergeIndex","firstCharCode","TokenizationTextModelPart_1","TokenizationTextModelPart","_bracketPairsTextModelPart","_languageId","_attachedViews","_languageService","_languageConfigurationService","_semanticTokens","_onDidChangeLanguage","onDidChangeLanguage","_onDidChangeLanguageConfiguration","onDidChangeLanguageConfiguration","_tokensDisposables","changedLanguages","createPreferredTokenProvider","createGrammarTokens","GrammarTokens","createTreeSitterTokens","createTokens","useTreeSitter","needsReset","_emitModelTokensChangedEvent","isEolChange","validateLineNumber","syntacticTokens","_isDisposing","setSemanticTokens","hasCompleteSemanticTokens","hasSomeSemanticTokens","setPartialSemanticTokens","changedRange","validateRange","getWordAtPosition","rbStartOffset","rbEndOffset","_findLanguageBoundaries","rightBiasedWord","lbStartOffset","lbEndOffset","leftBiasedWord","getWordUntilPosition","wordAtPosition","word","setLanguageId","oldLanguage","ITreeSitterParserService","attachedViews","_tokenizer","_defaultBackgroundTokenizer","_backgroundTokenizer","_debugBackgroundTokenizer","_attachedViewStates","refreshRanges","deleteAndDispose","_debugBackgroundTokens","_debugBackgroundStates","isTooLargeForTokenization","initializeTokenization","firstInvalidEndStateLineNumber","createBackgroundTokenizer","backgroundTokenizerShouldOnlyVerifyTokens","refreshAllVisibleLineTokens","joinMany","_","refreshRange","changedTokens","backgroundResult","reportMismatchingTokens","validatedPosition","TextModel_1","createTextBuffer","factory","createTextBufferFactory","snapshot","createTextBufferFactoryFromSnapshot","MODEL_ID","TextModelSnapshot","_source","_eos","resultCnt","resultLength","invalidFunc","TextModel","_MODEL_SYNC_LIMIT","LARGE_FILE_SIZE_THRESHOLD","LARGE_FILE_LINE_COUNT_THRESHOLD","LARGE_FILE_HEAP_OPERATION_THRESHOLD","DEFAULT_CREATION_OPTIONS","isForSimpleWidget","resolveOptions","guessedIndentation","_tokenizationTextModelPart","onDidChangeContent","listener","_eventEmitter","slowEvent","contentChangedEvent","onDidChangeContentOrInjectedText","fastEvent","_onDidChangeInjectedText","__isDisposing","_bracketPairs","_guidesTextModelPart","languageIdOrSelection","creationOptions","associatedResource","instantiationService","_onWillDispose","onWillDispose","_onDidChangeDecorations","DidChangeDecorationsEmitter","affectedInjectedTextLines","handleBeforeFireDecorationsChangedEvent","onDidChangeDecorations","_onDidChangeOptions","onDidChangeOptions","_onDidChangeAttached","onDidChangeAttached","DidChangeContentEmitter","_languageSelectionListener","_deltaDecorationCallCnt","_associatedResource","parse","_attachedEditorCount","_bufferDisposable","_options","_setLanguage","_decorationProvider","createInstance","bufferLineCount","bufferTextLength","_isTooLargeForTokenization","_isTooLargeForHeapOperation","_isTooLargeForSyncing","_versionId","_alternativeVersionId","_initialUndoRedoSnapshot","_instanceId","_lastDecorationId","_decorations","_decorationsTree","DecorationsTrees","_commandManager","_isUndoing","_isRedoing","_trimAutoWhitespaceLines","beginDeferredEmit","endDeferredEmit","requestRichLanguageFeatures","emptyDisposedTextBuffer","None","_assertNotDisposed","_emitContentChangedEvent","rawChange","setValue","_setValueFromTextBuffer","_createContentChanged2","isUndoing","isRedoing","getVersionId","textBufferDisposable","oldFullModelRange","getFullModelRange","oldModelValueLength","_increaseVersionId","_onBeforeEOLChange","_onAfterEOLChange","ensureAllNodesHaveRanges","allDecorations","onBeforeAttached","onBeforeDetached","getAttachedEditorCount","isTooLargeForSyncing","isTooLargeForHeapOperation","isDisposed","isDominatedByLongLines","smallLineCharCount","longLineCharCount","lineLength","getFormattingOptions","updateOptions","_newOpts","originalIndentSize","bracketColorizationOptions","newOpts","createChangeEvent","removeUnusualLineTerminators","matches","findMatches","pushEditOperations","getInitialUndoRedoSnapshot","rawPosition","_validatePosition","rawOffset","_overwriteVersionId","_overwriteAlternativeVersionId","newAlternativeVersionId","_overwriteInitialUndoRedoSnapshot","newInitialUndoRedoSnapshot","fullModelRange","fullModelValue","rawRange","getEndOfLineSequence","getLineMinColumn","_validateRangeRelaxedNoAllocations","initialStartLineNumber","initialStartColumn","isNaN","maxColumn","initialEndLineNumber","initialEndColumn","_isValidPosition","validationType","charCodeBefore","_lineNumber","_column","_isValidRange","charCodeBeforeStart","charCodeBeforeEnd","startInsideSurrogatePair","endInsideSurrogatePair","modifyPosition","candidate","rawSearchScope","isRegex","matchCase","searchRanges","searchScope","isIRange","d1","d2","uniqueSearchRanges","matchMapper","areIntersecting","parseSearchRequest","findNextMatch","rawSearchStart","searchStart","findPreviousMatch","_validateEditOperation","rawOperation","_validateEditOperations","_pushEditOperations","incomingEdits","editsAreNearCursors","sel","foundEditNearSel","editRange","selIsAbove","selIsBelow","trimLineNumber","maxLineColumn","allowTrimLine","editText","trimRange","resultingAlternativeVersionId","resultingSelection","rangeStart","_applyUndoRedoEdits","oldLineCount","rawContentChanges","deletingLinesCnt","insertingLinesCnt","editingLinesCnt","changeLineCountDelta","currentEditStartLineNumber","firstEditLineNumber","lastInsertedLineNumber","decorationsWithInjectedTextInEditedRange","getInjectedTextInInterval","injectedTextInEditedRange","fromDecorations","injectedTextInEditedRangeQueue","editLineNumber","currentEditLineNumber","takeFromEndWhile","decorationsInCurrentLine","spliceStartLineNumber","spliceLineNumber","injectedTexts","newLines","reverseEdits","canUndo","canRedo","lineChangeEvents","_getInjectedTextInLine","changeDecorations","_changeDecorations","changeAccessor","addDecoration","_deltaDecorationsImpl","changeDecoration","_changeDecorationImpl","changeDecorationOptions","_changeDecorationOptionsImpl","_normalizeOptions","removeDecoration","deltaDecorations","oldDecorations","newDecorations","console","warn","_getTrackedRange","getDecorationRange","_setTrackedRange","newStickiness","TRACKED_RANGE_OPTIONS","removeAllDecorationsWithOwnerId","getDecorationOptions","decorationId","getNodeRange","getLineDecorations","getLinesDecorations","_endLineNumber","decorations","_getDecorationsInRange","getOverviewRulerDecorations","getAll","getInjectedTextDecorations","getAllInjectedText","t","getAllMarginDecorations","filterRange","getAllInInterval","oldRange","recordLineAffectedByInjectedText","checkAffectedAndFire","nodeWasInOverviewRuler","overviewRuler","nodeIsInOverviewRuler","nodeRange","movedInOverviewRuler","changedWhetherInjectedText","isOptionsInjectedText","isNodeInjectedText","oldDecorationsIds","suppressEvents","oldDecorationsLen","oldDecorationIndex","newDecorationsLen","newDecorationIndex","internalDecorationId","newDecoration","setLanguage","normalizePosition","affinity","getLineIndentColumn","indentOfLine","isNodeInOverviewRuler","_decorationsTree0","_decorationsTree1","_injectedTextDecorationsTree","host","_ensureNodesHaveRanges","_intervalSearch","r0","r1","r2","showIfCollapsed","overviewRulerOnly","_search","_resolveNode","cleanClassName","DecorationOptions","darkColor","ModelDecorationOverviewRulerOptions","_resolvedColor","Center","_resolveColor","invalidateCachedColor","ModelDecorationGlyphMarginOptions","persistLane","ModelDecorationMinimapOptions","sectionHeaderStyle","sectionHeaderText","fromHex","ModelDecorationInjectedTextOptions","inlineClassNameAffectsLetterSpacing","attachedData","cursorStops","ModelDecorationOptions","createDynamic","blockClassName","blockDoesNotCollapse","blockIsAfterEnd","blockPadding","zIndex","shouldFillLineOnLineBreak","hoverMessage","glyphMarginHoverMessage","lineNumberHoverMessage","isWholeLine","minimap","glyphMargin","linesDecorationsClassName","lineNumberClassName","linesDecorationsTooltip","firstLineDecorationClassName","marginClassName","beforeContentClassName","afterContentClassName","hideInCommentTokens","hideInStringTokens","EMPTY","handleBeforeFire","_affectedInjectedTextLines","_deferredCnt","_shouldFireDeferred","_affectsMinimap","_affectsOverviewRuler","_affectsGlyphMargin","_affectsLineNumber","doFire","tryFire","affectsMinimap","affectsOverviewRuler","affectsGlyphMargin","affectsLineNumber","_fastEmitter","_slowEmitter","_deferredEvent","rawContentChangedEvent","TextModelPart","computeIndentLevel","chCode","ModelService_1","ModelData","_modelEventListeners","DEFAULT_EOL","DisposedModelInfo","initialUndoRedoSnapshot","time","sharesUndoRedoStack","sha1","ModelService","MAX_MEMORY_FOR_CLOSED_FILES_UNDO_STACK","_configurationService","_resourcePropertiesService","_instantiationService","_onModelAdded","onModelAdded","_onModelRemoved","onModelRemoved","_onModelModeChanged","onModelLanguageChanged","_modelCreationOptionsByLanguageAndResource","_models","_disposedModels","_disposedModelsHeapSize","_updateModelOptions","_readModelOptions","editor","parsedTabSize","parseInt","parsedIndentSize","newDefaultEOL","bracketPairColorization","language","_shouldRestoreUndoStack","getCreationOptions","oldOptionsByLanguageAndResource","modelId","modelData","affectsConfiguration","oldOptions","newOptions","_setModelOptionsForModel","currentOptions","_insertDisposedModel","disposedModelData","_removeDisposedModel","_ensureDisposedModelsHeapSize","maxModelsHeapSize","disposedModels","disposedModel","restoreSnapshot","_createModelData","elements","getElements","sha1Computer","_getSHA1Computer","sha1IsEqual","canComputeSHA1","computeSHA1","past","future","setElementsValidFlag","createModel","languageSelection","getModels","getModel","_schemaShouldMaintainUndoRedoElements","scheme","file","vscodeRemote","vscodeUserData","vscodeNotebookCell","getUriComparisonKey","maintainUndoRedoStack","maxMemory","oldLanguageId","newLanguageId","DefaultModelSHA1Computer","ITextResourcePropertiesService","MAX_MODEL_SIZE","shaComputer","digest","ITextResourceConfigurationService","ModelRawFlush","changeType","LineInjectedText","applyInjectedText","lastOriginalOffset","injectedText","decoration","ModelRawLineChanged","detail","ModelRawLinesDeleted","ModelRawLinesInserted","ModelRawEOLChanged","ModelRawContentChangedEvent","containsEvent","ModelInjectedTextChangedEvent","InternalModelContentChangeEvent","_mergeChangeEvents","HorizontalGuidesState","IndentGuide","horizontalLine","forWrappedLinesAfterColumn","forWrappedLinesBeforeOrAtColumn","IndentGuideHorizontalLine","top","LineTokens","defaultTokenMetadata","decoder","defaultMetadata","createFromTextAndMetadata","fullText","_lineTokensBrand","_tokensCount","_text","slicedEquals","sliceFromTokenIndex","sliceTokenCount","to","decodeLanguageId","getForeground","getClassName","getClassNameFromMetadata","getInlineStyle","colorMap","getInlineStyleFromMetadata","getPresentation","getPresentationFromMetadata","inflate","SliceLineTokens","desiredIndex","withInserted","insertTokens","nextOriginalTokenIdx","nextInsertTokenIdx","newTokens","nextOriginalTokenEndOffset","nextInsertToken","getTokenText","_startOffset","_endOffset","_deltaOffset","adjustedTokenIndex","getStandardTokenTypeAtPosition","SyncDescriptor","ctor","staticArguments","supportsDelayedInstantiation","registerSingleton","ctorOrDescriptor","getSingletonServiceDescriptors","IUndoRedoService","ResourceEditStackSnapshot","UndoRedoGroup","_ID","nextOrder","UndoRedoSource"],"sourceRoot":""}